/**
 * Stripe API
 * The Stripe REST API. Please see https://stripe.com/docs/api for more details.
 *
 * The version of the OpenAPI document: 2022-11-15
 * Contact: dev-platform@stripe.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { APIMethodRefundList } from '../model/aPIMethodRefundList';
import { Access } from '../model/access';
import { Access1 } from '../model/access1';
import { Access3 } from '../model/access3';
import { Account } from '../model/account';
import { AccountLink } from '../model/accountLink';
import { AccountList } from '../model/accountList';
import { AccountholderParams } from '../model/accountholderParams';
import { AccountholderParams1 } from '../model/accountholderParams1';
import { AddInvoiceItemEntry } from '../model/addInvoiceItemEntry';
import { AddressSpecs4 } from '../model/addressSpecs4';
import { AddressSpecs5 } from '../model/addressSpecs5';
import { AfterCompletionParams } from '../model/afterCompletionParams';
import { AfterExpirationParams } from '../model/afterExpirationParams';
import { AllPeopleRelationshipSpecs } from '../model/allPeopleRelationshipSpecs';
import { AllPricesRecurringParams } from '../model/allPricesRecurringParams';
import { ApmsSourcesSourceList } from '../model/apmsSourcesSourceList';
import { ApmsSourcesSourceTransactionList } from '../model/apmsSourcesSourceTransactionList';
import { ApplePayDomain } from '../model/applePayDomain';
import { ApplePayDomainList } from '../model/applePayDomainList';
import { ApplicationFee } from '../model/applicationFee';
import { AppliesToParams } from '../model/appliesToParams';
import { AppsSecret } from '../model/appsSecret';
import { AuthorizationControlsParam } from '../model/authorizationControlsParam';
import { AuthorizationControlsParamV2 } from '../model/authorizationControlsParamV2';
import { AutomaticPaymentMethodsParam } from '../model/automaticPaymentMethodsParam';
import { AutomaticTaxConfig2 } from '../model/automaticTaxConfig2';
import { AutomaticTaxParam } from '../model/automaticTaxParam';
import { AutomaticTaxParam1 } from '../model/automaticTaxParam1';
import { AutomaticTaxParam2 } from '../model/automaticTaxParam2';
import { AutomaticTaxParams } from '../model/automaticTaxParams';
import { AutomaticTaxParams1 } from '../model/automaticTaxParams1';
import { Balance } from '../model/balance';
import { BalanceSettingsParam1 } from '../model/balanceSettingsParam1';
import { BalanceTransaction } from '../model/balanceTransaction';
import { BalanceTransactionsList } from '../model/balanceTransactionsList';
import { BankAccount } from '../model/bankAccount';
import { BankConnectionsResourceLinkedAccountList } from '../model/bankConnectionsResourceLinkedAccountList';
import { BankConnectionsResourceOwnerList } from '../model/bankConnectionsResourceOwnerList';
import { BankTransferParams } from '../model/bankTransferParams';
import { BbposWisePose } from '../model/bbposWisePose';
import { BillingClocksResourceBillingClockList } from '../model/billingClocksResourceBillingClockList';
import { BillingDetailsInnerParams } from '../model/billingDetailsInnerParams';
import { BillingPortalConfiguration } from '../model/billingPortalConfiguration';
import { BillingPortalSession } from '../model/billingPortalSession';
import { BillingSpecs } from '../model/billingSpecs';
import { BusinessProfileCreateParam } from '../model/businessProfileCreateParam';
import { BusinessProfileSpecs } from '../model/businessProfileSpecs';
import { BusinessProfileUpdateParam } from '../model/businessProfileUpdateParam';
import { CapabilitiesParam } from '../model/capabilitiesParam';
import { Capability } from '../model/capability';
import { CardPresent } from '../model/cardPresent';
import { Cart } from '../model/cart';
import { CashBalance } from '../model/cashBalance';
import { CashBalanceParam } from '../model/cashBalanceParam';
import { Charge } from '../model/charge';
import { ChargeList } from '../model/chargeList';
import { CheckoutSession } from '../model/checkoutSession';
import { CompanyParam } from '../model/companyParam';
import { CompanySpecs } from '../model/companySpecs';
import { ConnectJsAccountTokenSpecs } from '../model/connectJsAccountTokenSpecs';
import { ConsentCollectionParams } from '../model/consentCollectionParams';
import { ConsentCollectionParams1 } from '../model/consentCollectionParams1';
import { CountrySpec } from '../model/countrySpec';
import { CountrySpecList } from '../model/countrySpecList';
import { Coupon } from '../model/coupon';
import { CouponsResourceCouponList } from '../model/couponsResourceCouponList';
import { CreateLocationAddressParam } from '../model/createLocationAddressParam';
import { CreditNote } from '../model/creditNote';
import { CreditNoteLineItemParams } from '../model/creditNoteLineItemParams';
import { CreditNoteLinesList } from '../model/creditNoteLinesList';
import { CreditNoteShippingCost } from '../model/creditNoteShippingCost';
import { CreditNoteShippingCost1 } from '../model/creditNoteShippingCost1';
import { CreditNotesList } from '../model/creditNotesList';
import { CustomFieldParam } from '../model/customFieldParam';
import { CustomTextParam } from '../model/customTextParam';
import { CustomUnitAmount1 } from '../model/customUnitAmount1';
import { Customer } from '../model/customer';
import { CustomerBalanceTransaction } from '../model/customerBalanceTransaction';
import { CustomerBalanceTransactionList } from '../model/customerBalanceTransactionList';
import { CustomerCashBalanceTransaction } from '../model/customerCashBalanceTransaction';
import { CustomerCashBalanceTransactionList } from '../model/customerCashBalanceTransactionList';
import { CustomerDetailsParam } from '../model/customerDetailsParam';
import { CustomerDetailsParams } from '../model/customerDetailsParams';
import { CustomerParam } from '../model/customerParam';
import { CustomerPaymentMethodResourceList } from '../model/customerPaymentMethodResourceList';
import { CustomerResourceCustomerList } from '../model/customerResourceCustomerList';
import { CustomerUpdateParams } from '../model/customerUpdateParams';
import { CvcParams } from '../model/cvcParams';
import { DataParams } from '../model/dataParams';
import { DefaultSettingsParams } from '../model/defaultSettingsParams';
import { DefaultSettingsParamsBillingThresholds } from '../model/defaultSettingsParamsBillingThresholds';
import { DeleteCustomersCustomerSourcesId200Response } from '../model/deleteCustomersCustomerSourcesId200Response';
import { DeletedAccount } from '../model/deletedAccount';
import { DeletedApplePayDomain } from '../model/deletedApplePayDomain';
import { DeletedCoupon } from '../model/deletedCoupon';
import { DeletedCustomer } from '../model/deletedCustomer';
import { DeletedDiscount } from '../model/deletedDiscount';
import { DeletedExternalAccount } from '../model/deletedExternalAccount';
import { DeletedInvoice } from '../model/deletedInvoice';
import { DeletedInvoiceitem } from '../model/deletedInvoiceitem';
import { DeletedPerson } from '../model/deletedPerson';
import { DeletedPlan } from '../model/deletedPlan';
import { DeletedProduct } from '../model/deletedProduct';
import { DeletedRadarValueList } from '../model/deletedRadarValueList';
import { DeletedRadarValueListItem } from '../model/deletedRadarValueListItem';
import { DeletedSubscriptionItem } from '../model/deletedSubscriptionItem';
import { DeletedTaxId } from '../model/deletedTaxId';
import { DeletedTerminalConfiguration } from '../model/deletedTerminalConfiguration';
import { DeletedTerminalLocation } from '../model/deletedTerminalLocation';
import { DeletedTerminalReader } from '../model/deletedTerminalReader';
import { DeletedTestHelpersTestClock } from '../model/deletedTestHelpersTestClock';
import { DeletedWebhookEndpoint } from '../model/deletedWebhookEndpoint';
import { DeliveryEstimate } from '../model/deliveryEstimate';
import { DestinationSpecs } from '../model/destinationSpecs';
import { DiscountParams } from '../model/discountParams';
import { Dispute } from '../model/dispute';
import { DisputeEvidenceParams } from '../model/disputeEvidenceParams';
import { DisputeList } from '../model/disputeList';
import { DocumentsSpecs } from '../model/documentsSpecs';
import { EncryptedPinParam } from '../model/encryptedPinParam';
import { EndUserDetailsParams } from '../model/endUserDetailsParams';
import { EphemeralKey } from '../model/ephemeralKey';
import { Event } from '../model/event';
import { EvidenceParam } from '../model/evidenceParam';
import { ExchangeRate } from '../model/exchangeRate';
import { ExchangeRateList } from '../model/exchangeRateList';
import { ExternalAccount } from '../model/externalAccount';
import { ExternalAccountList } from '../model/externalAccountList';
import { FailureDetailsParams } from '../model/failureDetailsParams';
import { FeatureAccess } from '../model/featureAccess';
import { FeatureAccess1 } from '../model/featureAccess1';
import { FeaturesCreationParam } from '../model/featuresCreationParam';
import { FeaturesUpdatingParam } from '../model/featuresUpdatingParam';
import { FeeRefund } from '../model/feeRefund';
import { FeeRefundList } from '../model/feeRefundList';
import { FileFileLinkList } from '../model/fileFileLinkList';
import { FileFileList } from '../model/fileFileList';
import { FileLink } from '../model/fileLink';
import { FileLinkCreationParams } from '../model/fileLinkCreationParams';
import { FiltersParams } from '../model/filtersParams';
import { FinancialAddresses } from '../model/financialAddresses';
import { FinancialConnectionsAccount } from '../model/financialConnectionsAccount';
import { FinancialConnectionsSession } from '../model/financialConnectionsSession';
import { FinancialReportingFinanceReportRunList } from '../model/financialReportingFinanceReportRunList';
import { FinancialReportingFinanceReportTypeList } from '../model/financialReportingFinanceReportTypeList';
import { FixedAmount } from '../model/fixedAmount';
import { FixedAmountUpdate } from '../model/fixedAmountUpdate';
import { FlowDataParam } from '../model/flowDataParam';
import { FraudDetails } from '../model/fraudDetails';
import { FromInvoice } from '../model/fromInvoice';
import { FromQuoteParams } from '../model/fromQuoteParams';
import { FundingInstructions } from '../model/fundingInstructions';
import { GelatoVerificationReportList } from '../model/gelatoVerificationReportList';
import { GelatoVerificationSessionList } from '../model/gelatoVerificationSessionList';
import { GetAccountsCreatedParameter } from '../model/getAccountsCreatedParameter';
import { GetCustomersCustomer200Response } from '../model/getCustomersCustomer200Response';
import { GetInvoicesUpcomingDiscountsParameter } from '../model/getInvoicesUpcomingDiscountsParameter';
import { GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter } from '../model/getInvoicesUpcomingSubscriptionBillingCycleAnchorParameter';
import { GetInvoicesUpcomingSubscriptionCancelAtParameter } from '../model/getInvoicesUpcomingSubscriptionCancelAtParameter';
import { GetInvoicesUpcomingSubscriptionDefaultTaxRatesParameter } from '../model/getInvoicesUpcomingSubscriptionDefaultTaxRatesParameter';
import { GetInvoicesUpcomingSubscriptionTrialEndParameter } from '../model/getInvoicesUpcomingSubscriptionTrialEndParameter';
import { GetTerminalConfigurationsConfiguration200Response } from '../model/getTerminalConfigurationsConfiguration200Response';
import { GetTerminalLocationsLocation200Response } from '../model/getTerminalLocationsLocation200Response';
import { GetTerminalReadersReader200Response } from '../model/getTerminalReadersReader200Response';
import { IdentityVerificationReport } from '../model/identityVerificationReport';
import { IdentityVerificationSession } from '../model/identityVerificationSession';
import { InboundTransfers1 } from '../model/inboundTransfers1';
import { IndividualParam } from '../model/individualParam';
import { IndividualSpecs } from '../model/individualSpecs';
import { IndividualSpecsMetadata } from '../model/individualSpecsMetadata';
import { InlineProductParams1 } from '../model/inlineProductParams1';
import { InteracPresent } from '../model/interacPresent';
import { Invoice } from '../model/invoice';
import { InvoiceCreationCreateParams } from '../model/invoiceCreationCreateParams';
import { InvoiceCreationParams } from '../model/invoiceCreationParams';
import { InvoiceCreationUpdateParams } from '../model/invoiceCreationUpdateParams';
import { InvoiceItemPreviewParams } from '../model/invoiceItemPreviewParams';
import { InvoiceLinesList } from '../model/invoiceLinesList';
import { Invoiceitem } from '../model/invoiceitem';
import { InvoicesItemsList } from '../model/invoicesItemsList';
import { InvoicesList } from '../model/invoicesList';
import { IssuingAuthorization } from '../model/issuingAuthorization';
import { IssuingAuthorizationList } from '../model/issuingAuthorizationList';
import { IssuingCard } from '../model/issuingCard';
import { IssuingCardList } from '../model/issuingCardList';
import { IssuingCardholder } from '../model/issuingCardholder';
import { IssuingCardholderList } from '../model/issuingCardholderList';
import { IssuingDispute } from '../model/issuingDispute';
import { IssuingDisputeList } from '../model/issuingDisputeList';
import { IssuingTransaction } from '../model/issuingTransaction';
import { IssuingTransactionList } from '../model/issuingTransactionList';
import { JapanAddressKanaSpecs2 } from '../model/japanAddressKanaSpecs2';
import { JapanAddressKanjiSpecs2 } from '../model/japanAddressKanjiSpecs2';
import { LineItemCreateParams } from '../model/lineItemCreateParams';
import { LineItemParams } from '../model/lineItemParams';
import { LineItemUpdateParams } from '../model/lineItemUpdateParams';
import { LineItemsCreateParams } from '../model/lineItemsCreateParams';
import { LineItemsUpdateParams } from '../model/lineItemsUpdateParams';
import { LinkedFlowsParam } from '../model/linkedFlowsParam';
import { ListAccountCapability } from '../model/listAccountCapability';
import { LoginLink } from '../model/loginLink';
import { LoginPageCreateParam } from '../model/loginPageCreateParam';
import { LoginPageUpdateParam } from '../model/loginPageUpdateParam';
import { Mandate } from '../model/mandate';
import { MandateParams } from '../model/mandateParams';
import { ModelError } from '../model/modelError';
import { NotificationEventList } from '../model/notificationEventList';
import { NotificationWebhookEndpointList } from '../model/notificationWebhookEndpointList';
import { OneTimePriceData } from '../model/oneTimePriceData';
import { OptionalFieldsAddress4 } from '../model/optionalFieldsAddress4';
import { OptionalFieldsShipping } from '../model/optionalFieldsShipping';
import { OptionalFieldsShipping1 } from '../model/optionalFieldsShipping1';
import { OrderParams } from '../model/orderParams';
import { OutboundPayments } from '../model/outboundPayments';
import { OutboundTransfers } from '../model/outboundTransfers';
import { Owner } from '../model/owner';
import { Owner1 } from '../model/owner1';
import { PackageDimensionsSpecs } from '../model/packageDimensionsSpecs';
import { Param } from '../model/param';
import { Param1 } from '../model/param1';
import { Param2 } from '../model/param2';
import { Param3 } from '../model/param3';
import { Param4 } from '../model/param4';
import { Param5 } from '../model/param5';
import { Param6 } from '../model/param6';
import { Param7 } from '../model/param7';
import { Param8 } from '../model/param8';
import { Param9 } from '../model/param9';
import { PaymentFlowsPaymentIntentList } from '../model/paymentFlowsPaymentIntentList';
import { PaymentFlowsPaymentMethodList } from '../model/paymentFlowsPaymentMethodList';
import { PaymentFlowsSetupIntentList } from '../model/paymentFlowsSetupIntentList';
import { PaymentFlowsSetupIntentSetupAttemptList } from '../model/paymentFlowsSetupIntentSetupAttemptList';
import { PaymentIntent } from '../model/paymentIntent';
import { PaymentIntentDataParams } from '../model/paymentIntentDataParams';
import { PaymentIntentDataParams1 } from '../model/paymentIntentDataParams1';
import { PaymentLink } from '../model/paymentLink';
import { PaymentLinksResourceListLineItems } from '../model/paymentLinksResourceListLineItems';
import { PaymentLinksResourcePaymentLinkList } from '../model/paymentLinksResourcePaymentLinkList';
import { PaymentMethod } from '../model/paymentMethod';
import { PaymentMethodData } from '../model/paymentMethodData';
import { PaymentMethodDataParams } from '../model/paymentMethodDataParams';
import { PaymentMethodDataParams1 } from '../model/paymentMethodDataParams1';
import { PaymentMethodOptions2 } from '../model/paymentMethodOptions2';
import { PaymentMethodOptions3 } from '../model/paymentMethodOptions3';
import { PaymentMethodOptionsParam } from '../model/paymentMethodOptionsParam';
import { PaymentMethodOptionsParam25 } from '../model/paymentMethodOptionsParam25';
import { PaymentMethodOptionsParam40 } from '../model/paymentMethodOptionsParam40';
import { PaymentMethodParam } from '../model/paymentMethodParam';
import { PaymentMethodParam1 } from '../model/paymentMethodParam1';
import { PaymentPagesCheckoutSessionList } from '../model/paymentPagesCheckoutSessionList';
import { PaymentPagesCheckoutSessionListLineItems } from '../model/paymentPagesCheckoutSessionListLineItems';
import { PaymentSettings } from '../model/paymentSettings';
import { PaymentSettings1 } from '../model/paymentSettings1';
import { PaymentSource } from '../model/paymentSource';
import { Payout } from '../model/payout';
import { PayoutList } from '../model/payoutList';
import { Period1 } from '../model/period1';
import { Person } from '../model/person';
import { PersonDocumentsSpecs } from '../model/personDocumentsSpecs';
import { PersonList } from '../model/personList';
import { PersonTokenSpecs } from '../model/personTokenSpecs';
import { PersonVerificationSpecs1 } from '../model/personVerificationSpecs1';
import { PhaseConfigurationParams } from '../model/phaseConfigurationParams';
import { PhaseConfigurationParams1 } from '../model/phaseConfigurationParams1';
import { PhoneNumberCollectionParams } from '../model/phoneNumberCollectionParams';
import { PhoneNumberCollectionParams1 } from '../model/phoneNumberCollectionParams1';
import { PiiTokenSpecs } from '../model/piiTokenSpecs';
import { Plan } from '../model/plan';
import { PlanList } from '../model/planList';
import { PlatformEarningList } from '../model/platformEarningList';
import { PlatformRestrictions } from '../model/platformRestrictions';
import { PortalConfigurationList } from '../model/portalConfigurationList';
import { PostAccountsAccountPersonsRequestDob } from '../model/postAccountsAccountPersonsRequestDob';
import { PostAccountsAccountPersonsRequestFullNameAliases } from '../model/postAccountsAccountPersonsRequestFullNameAliases';
import { PostBillingPortalConfigurationsRequestDefaultReturnUrl } from '../model/postBillingPortalConfigurationsRequestDefaultReturnUrl';
import { PostCustomersCustomerSourcesId200Response } from '../model/postCustomersCustomerSourcesId200Response';
import { PostCustomersRequestAddress } from '../model/postCustomersRequestAddress';
import { PostCustomersRequestShipping } from '../model/postCustomersRequestShipping';
import { PostFileLinksLinkRequestExpiresAt } from '../model/postFileLinksLinkRequestExpiresAt';
import { PostInvoiceitemsInvoiceitemRequestDiscounts } from '../model/postInvoiceitemsInvoiceitemRequestDiscounts';
import { PostInvoiceitemsInvoiceitemRequestTaxRates } from '../model/postInvoiceitemsInvoiceitemRequestTaxRates';
import { PostInvoiceitemsRequestDiscounts } from '../model/postInvoiceitemsRequestDiscounts';
import { PostInvoiceitemsRequestTaxCode } from '../model/postInvoiceitemsRequestTaxCode';
import { PostInvoicesInvoiceRequestCustomFields } from '../model/postInvoicesInvoiceRequestCustomFields';
import { PostInvoicesInvoiceRequestDefaultTaxRates } from '../model/postInvoicesInvoiceRequestDefaultTaxRates';
import { PostInvoicesInvoiceRequestDiscounts } from '../model/postInvoicesInvoiceRequestDiscounts';
import { PostInvoicesInvoiceRequestOnBehalfOf } from '../model/postInvoicesInvoiceRequestOnBehalfOf';
import { PostInvoicesInvoiceRequestShippingCost } from '../model/postInvoicesInvoiceRequestShippingCost';
import { PostInvoicesInvoiceRequestShippingDetails } from '../model/postInvoicesInvoiceRequestShippingDetails';
import { PostInvoicesInvoiceRequestTransferData } from '../model/postInvoicesInvoiceRequestTransferData';
import { PostInvoicesRequestAccountTaxIds } from '../model/postInvoicesRequestAccountTaxIds';
import { PostInvoicesRequestCustomFields } from '../model/postInvoicesRequestCustomFields';
import { PostInvoicesRequestDiscounts } from '../model/postInvoicesRequestDiscounts';
import { PostInvoicesRequestRenderingOptions } from '../model/postInvoicesRequestRenderingOptions';
import { PostPaymentIntentsIntentConfirmRequestMandateData } from '../model/postPaymentIntentsIntentConfirmRequestMandateData';
import { PostPaymentIntentsIntentConfirmRequestOffSession } from '../model/postPaymentIntentsIntentConfirmRequestOffSession';
import { PostPaymentIntentsIntentRequestApplicationFeeAmount } from '../model/postPaymentIntentsIntentRequestApplicationFeeAmount';
import { PostPaymentIntentsIntentRequestReceiptEmail } from '../model/postPaymentIntentsIntentRequestReceiptEmail';
import { PostPaymentIntentsIntentRequestShipping } from '../model/postPaymentIntentsIntentRequestShipping';
import { PostPaymentIntentsRequestOffSession } from '../model/postPaymentIntentsRequestOffSession';
import { PostPaymentLinksPaymentLinkRequestCustomFields } from '../model/postPaymentLinksPaymentLinkRequestCustomFields';
import { PostPaymentLinksPaymentLinkRequestPaymentMethodTypes } from '../model/postPaymentLinksPaymentLinkRequestPaymentMethodTypes';
import { PostPaymentLinksPaymentLinkRequestShippingAddressCollection } from '../model/postPaymentLinksPaymentLinkRequestShippingAddressCollection';
import { PostPaymentMethodsRequestCard } from '../model/postPaymentMethodsRequestCard';
import { PostPlansRequestProduct } from '../model/postPlansRequestProduct';
import { PostPricesPriceRequestCurrencyOptions } from '../model/postPricesPriceRequestCurrencyOptions';
import { PostPricesPriceRequestRecurring } from '../model/postPricesPriceRequestRecurring';
import { PostProductsIdRequestAttributes } from '../model/postProductsIdRequestAttributes';
import { PostProductsIdRequestImages } from '../model/postProductsIdRequestImages';
import { PostProductsIdRequestPackageDimensions } from '../model/postProductsIdRequestPackageDimensions';
import { PostProductsIdRequestUrl } from '../model/postProductsIdRequestUrl';
import { PostQuotesRequestApplicationFeeAmount } from '../model/postQuotesRequestApplicationFeeAmount';
import { PostQuotesRequestApplicationFeePercent } from '../model/postQuotesRequestApplicationFeePercent';
import { PostQuotesRequestDefaultTaxRates } from '../model/postQuotesRequestDefaultTaxRates';
import { PostQuotesRequestDiscounts } from '../model/postQuotesRequestDiscounts';
import { PostQuotesRequestOnBehalfOf } from '../model/postQuotesRequestOnBehalfOf';
import { PostQuotesRequestTransferData } from '../model/postQuotesRequestTransferData';
import { PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp } from '../model/postSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp';
import { PostSubscriptionSchedulesRequestStartDate } from '../model/postSubscriptionSchedulesRequestStartDate';
import { PostSubscriptionsRequestDefaultTaxRates } from '../model/postSubscriptionsRequestDefaultTaxRates';
import { PostSubscriptionsRequestOnBehalfOf } from '../model/postSubscriptionsRequestOnBehalfOf';
import { PostSubscriptionsRequestPendingInvoiceItemInterval } from '../model/postSubscriptionsRequestPendingInvoiceItemInterval';
import { PostSubscriptionsRequestTrialEnd } from '../model/postSubscriptionsRequestTrialEnd';
import { PostSubscriptionsSubscriptionExposedIdRequestCancelAt } from '../model/postSubscriptionsSubscriptionExposedIdRequestCancelAt';
import { PostSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates } from '../model/postSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates';
import { PostSubscriptionsSubscriptionExposedIdRequestPauseCollection } from '../model/postSubscriptionsSubscriptionExposedIdRequestPauseCollection';
import { PostSubscriptionsSubscriptionExposedIdRequestTransferData } from '../model/postSubscriptionsSubscriptionExposedIdRequestTransferData';
import { PostSubscriptionsSubscriptionExposedIdRequestTrialEnd } from '../model/postSubscriptionsSubscriptionExposedIdRequestTrialEnd';
import { PostTerminalConfigurationsConfigurationRequestBbposWiseposE } from '../model/postTerminalConfigurationsConfigurationRequestBbposWiseposE';
import { PostTerminalConfigurationsConfigurationRequestVerifoneP400 } from '../model/postTerminalConfigurationsConfigurationRequestVerifoneP400';
import { PostTerminalConfigurationsRequestTipping } from '../model/postTerminalConfigurationsRequestTipping';
import { PostTokensRequestCard } from '../model/postTokensRequestCard';
import { Price } from '../model/price';
import { PriceDataWithoutProduct } from '../model/priceDataWithoutProduct';
import { PriceList } from '../model/priceList';
import { ProcessConfig } from '../model/processConfig';
import { Product } from '../model/product';
import { ProductList } from '../model/productList';
import { PromotionCode } from '../model/promotionCode';
import { PromotionCodesResourcePromotionCodeList } from '../model/promotionCodesResourcePromotionCodeList';
import { Quote } from '../model/quote';
import { QuoteParam } from '../model/quoteParam';
import { QuotesResourceListLineItems } from '../model/quotesResourceListLineItems';
import { QuotesResourceQuoteList } from '../model/quotesResourceQuoteList';
import { RadarEarlyFraudWarning } from '../model/radarEarlyFraudWarning';
import { RadarEarlyFraudWarningList } from '../model/radarEarlyFraudWarningList';
import { RadarListListItemList } from '../model/radarListListItemList';
import { RadarListListList } from '../model/radarListListList';
import { RadarOptions } from '../model/radarOptions';
import { RadarReviewList } from '../model/radarReviewList';
import { RadarValueList } from '../model/radarValueList';
import { RadarValueListItem } from '../model/radarValueListItem';
import { ReceiverParams } from '../model/receiverParams';
import { RecipientShippingWithOptionalFieldsAddress } from '../model/recipientShippingWithOptionalFieldsAddress';
import { Recurring1 } from '../model/recurring1';
import { RecurringPriceData } from '../model/recurringPriceData';
import { RedirectParams } from '../model/redirectParams';
import { Refund } from '../model/refund';
import { RefundList } from '../model/refundList';
import { RelationshipSpecs } from '../model/relationshipSpecs';
import { ReportingReportRun } from '../model/reportingReportRun';
import { ReportingReportType } from '../model/reportingReportType';
import { RestrictionsParams } from '../model/restrictionsParams';
import { RestrictionsParams1 } from '../model/restrictionsParams1';
import { ReturnedDetailsParams } from '../model/returnedDetailsParams';
import { ReturnedDetailsParams1 } from '../model/returnedDetailsParams1';
import { Review } from '../model/review';
import { RunParameterSpecs } from '../model/runParameterSpecs';
import { ScheduledQueryRun } from '../model/scheduledQueryRun';
import { ScopeParam } from '../model/scopeParam';
import { ScopeParam1 } from '../model/scopeParam1';
import { SearchResult } from '../model/searchResult';
import { SearchResult1 } from '../model/searchResult1';
import { SearchResult2 } from '../model/searchResult2';
import { SearchResult3 } from '../model/searchResult3';
import { SearchResult4 } from '../model/searchResult4';
import { SearchResult5 } from '../model/searchResult5';
import { SearchResult6 } from '../model/searchResult6';
import { SecretKeyParam } from '../model/secretKeyParam';
import { SecretKeyParam2 } from '../model/secretKeyParam2';
import { SecretServiceResourceSecretList } from '../model/secretServiceResourceSecretList';
import { SessionOptionsParam } from '../model/sessionOptionsParam';
import { SettingsSpecs } from '../model/settingsSpecs';
import { SettingsSpecsUpdate } from '../model/settingsSpecsUpdate';
import { SetupIntent } from '../model/setupIntent';
import { SetupIntentDataParam } from '../model/setupIntentDataParam';
import { SetupIntentSingleUseParams } from '../model/setupIntentSingleUseParams';
import { ShallowOrderSpecs } from '../model/shallowOrderSpecs';
import { ShippingAddressCollectionParams } from '../model/shippingAddressCollectionParams';
import { ShippingAddressCollectionParams1 } from '../model/shippingAddressCollectionParams1';
import { ShippingCost } from '../model/shippingCost';
import { ShippingOptionParams } from '../model/shippingOptionParams';
import { ShippingOptionParams1 } from '../model/shippingOptionParams1';
import { ShippingRate } from '../model/shippingRate';
import { ShippingResourcesShippingRateList } from '../model/shippingResourcesShippingRateList';
import { ShippingSpecs } from '../model/shippingSpecs';
import { SigmaScheduledQueryRunList } from '../model/sigmaScheduledQueryRunList';
import { Source } from '../model/source';
import { SourceParams } from '../model/sourceParams';
import { StatusTransitionTimestampSpecs } from '../model/statusTransitionTimestampSpecs';
import { Subscription } from '../model/subscription';
import { SubscriptionDataCreateParams } from '../model/subscriptionDataCreateParams';
import { SubscriptionDataParams } from '../model/subscriptionDataParams';
import { SubscriptionDataParams1 } from '../model/subscriptionDataParams1';
import { SubscriptionDataUpdateParams } from '../model/subscriptionDataUpdateParams';
import { SubscriptionItem } from '../model/subscriptionItem';
import { SubscriptionItemCreateParams } from '../model/subscriptionItemCreateParams';
import { SubscriptionItemUpdateParams } from '../model/subscriptionItemUpdateParams';
import { SubscriptionItemUpdateParamsBillingThresholds } from '../model/subscriptionItemUpdateParamsBillingThresholds';
import { SubscriptionItemUpdateParamsTaxRates } from '../model/subscriptionItemUpdateParamsTaxRates';
import { SubscriptionSchedule } from '../model/subscriptionSchedule';
import { SubscriptionSchedulesResourceScheduleList } from '../model/subscriptionSchedulesResourceScheduleList';
import { SubscriptionsItemsSubscriptionItemList } from '../model/subscriptionsItemsSubscriptionItemList';
import { SubscriptionsSubscriptionList } from '../model/subscriptionsSubscriptionList';
import { TaxCode } from '../model/taxCode';
import { TaxIDsList } from '../model/taxIDsList';
import { TaxId } from '../model/taxId';
import { TaxIdCollectionParams } from '../model/taxIdCollectionParams';
import { TaxIdCollectionParams1 } from '../model/taxIdCollectionParams1';
import { TaxParam } from '../model/taxParam';
import { TaxProductResourceTaxCodeList } from '../model/taxProductResourceTaxCodeList';
import { TaxRate } from '../model/taxRate';
import { TaxRatesList } from '../model/taxRatesList';
import { TerminalConfiguration } from '../model/terminalConfiguration';
import { TerminalConfigurationConfigurationList } from '../model/terminalConfigurationConfigurationList';
import { TerminalConnectionToken } from '../model/terminalConnectionToken';
import { TerminalLocation } from '../model/terminalLocation';
import { TerminalLocationLocationList } from '../model/terminalLocationLocationList';
import { TerminalReader } from '../model/terminalReader';
import { TerminalReaderRetrieveReader } from '../model/terminalReaderRetrieveReader';
import { TestHelpersTestClock } from '../model/testHelpersTestClock';
import { Tier } from '../model/tier';
import { Token } from '../model/token';
import { TokenCreateBankAccount } from '../model/tokenCreateBankAccount';
import { Topup } from '../model/topup';
import { TopupList } from '../model/topupList';
import { TosAcceptanceSpecs } from '../model/tosAcceptanceSpecs';
import { Transfer } from '../model/transfer';
import { TransferDataCreationParams } from '../model/transferDataCreationParams';
import { TransferDataParams1 } from '../model/transferDataParams1';
import { TransferDataSpecs } from '../model/transferDataSpecs';
import { TransferDataSpecs1 } from '../model/transferDataSpecs1';
import { TransferDataSpecs2 } from '../model/transferDataSpecs2';
import { TransferDataSpecs3 } from '../model/transferDataSpecs3';
import { TransferDataUpdateParams } from '../model/transferDataUpdateParams';
import { TransferDataUpdateParams1 } from '../model/transferDataUpdateParams1';
import { TransferDataUpdateParams2 } from '../model/transferDataUpdateParams2';
import { TransferList } from '../model/transferList';
import { TransferReversal } from '../model/transferReversal';
import { TransferReversalList } from '../model/transferReversalList';
import { TransformUsageParam } from '../model/transformUsageParam';
import { TreasuryCreditReversal } from '../model/treasuryCreditReversal';
import { TreasuryDebitReversal } from '../model/treasuryDebitReversal';
import { TreasuryFinancialAccount } from '../model/treasuryFinancialAccount';
import { TreasuryFinancialAccountFeatures } from '../model/treasuryFinancialAccountFeatures';
import { TreasuryFinancialAccountsResourceFinancialAccountList } from '../model/treasuryFinancialAccountsResourceFinancialAccountList';
import { TreasuryInboundTransfer } from '../model/treasuryInboundTransfer';
import { TreasuryInboundTransfersResourceInboundTransferList } from '../model/treasuryInboundTransfersResourceInboundTransferList';
import { TreasuryOutboundPayment } from '../model/treasuryOutboundPayment';
import { TreasuryOutboundPaymentsResourceOutboundPaymentList } from '../model/treasuryOutboundPaymentsResourceOutboundPaymentList';
import { TreasuryOutboundTransfer } from '../model/treasuryOutboundTransfer';
import { TreasuryOutboundTransfersResourceOutboundTransferList } from '../model/treasuryOutboundTransfersResourceOutboundTransferList';
import { TreasuryParam } from '../model/treasuryParam';
import { TreasuryReceivedCredit } from '../model/treasuryReceivedCredit';
import { TreasuryReceivedCreditsResourceCreditReversalList } from '../model/treasuryReceivedCreditsResourceCreditReversalList';
import { TreasuryReceivedCreditsResourceReceivedCreditList } from '../model/treasuryReceivedCreditsResourceReceivedCreditList';
import { TreasuryReceivedDebit } from '../model/treasuryReceivedDebit';
import { TreasuryReceivedDebitsResourceDebitReversalList } from '../model/treasuryReceivedDebitsResourceDebitReversalList';
import { TreasuryReceivedDebitsResourceReceivedDebitList } from '../model/treasuryReceivedDebitsResourceReceivedDebitList';
import { TreasuryTransaction } from '../model/treasuryTransaction';
import { TreasuryTransactionEntry } from '../model/treasuryTransactionEntry';
import { TreasuryTransactionsResourceTransactionEntryList } from '../model/treasuryTransactionsResourceTransactionEntryList';
import { TreasuryTransactionsResourceTransactionList } from '../model/treasuryTransactionsResourceTransactionList';
import { TrialSettingsConfig } from '../model/trialSettingsConfig';
import { UpdateApiParam } from '../model/updateApiParam';
import { UpdateParam } from '../model/updateParam';
import { UsageEventsResourceUsageRecordSummaryList } from '../model/usageEventsResourceUsageRecordSummaryList';
import { UsageRecord } from '../model/usageRecord';
import { VerifoneP400 } from '../model/verifoneP400';
import { WebhookEndpoint } from '../model/webhookEndpoint';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';
import { HttpBasicAuth, HttpBearerAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://api.stripe.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'basicAuth': new HttpBasicAuth(),
        'bearerAuth': new HttpBearerAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
    }

    set username(username: string) {
        this.authentications.basicAuth.username = username;
    }

    set password(password: string) {
        this.authentications.basicAuth.password = password;
    }

    set accessToken(accessToken: string | (() => string)) {
        this.authentications.bearerAuth.accessToken = accessToken;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * <p>With <a href=\"/docs/connect\">Connect</a>, you can delete accounts you manage.</p>  <p>Accounts created using test-mode keys can be deleted at any time. Standard accounts created using live-mode keys cannot be deleted. Custom or Express accounts created using live-mode keys can only be deleted once all balances are zero.</p>  <p>If you want to delete your own account, use the <a href=\"https://dashboard.stripe.com/account\">account information tab in your account settings</a> instead.</p>
     * @param account 
     */
    public async deleteAccountsAccount (account: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedAccount;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling deleteAccountsAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Delete a specified external account for a given account.</p>
     * @param account 
     * @param id 
     */
    public async deleteAccountsAccountExternalAccountsId (account: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedExternalAccount;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/external_accounts/{id}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling deleteAccountsAccountExternalAccountsId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteAccountsAccountExternalAccountsId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedExternalAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedExternalAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes an existing person’s relationship to the account’s legal entity. Any person with a relationship for an account can be deleted through the API, except if the person is the <code>account_opener</code>. If your integration is using the <code>executive</code> parameter, you cannot delete the only verified <code>executive</code> on file.</p>
     * @param account 
     * @param person 
     */
    public async deleteAccountsAccountPersonsPerson (account: string, person: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedPerson;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/persons/{person}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'person' + '}', encodeURIComponent(String(person)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling deleteAccountsAccountPersonsPerson.');
        }

        // verify required parameter 'person' is not null or undefined
        if (person === null || person === undefined) {
            throw new Error('Required parameter person was null or undefined when calling deleteAccountsAccountPersonsPerson.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedPerson;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedPerson");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Delete an apple pay domain.</p>
     * @param domain 
     */
    public async deleteApplePayDomainsDomain (domain: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedApplePayDomain;  }> {
        const localVarPath = this.basePath + '/v1/apple_pay/domains/{domain}'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling deleteApplePayDomainsDomain.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedApplePayDomain;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedApplePayDomain");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can delete coupons via the <a href=\"https://dashboard.stripe.com/coupons\">coupon management</a> page of the Stripe dashboard. However, deleting a coupon does not affect any customers who have already applied the coupon; it means that new customers can’t redeem the coupon. You can also delete coupons via the API.</p>
     * @param coupon 
     */
    public async deleteCouponsCoupon (coupon: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedCoupon;  }> {
        const localVarPath = this.basePath + '/v1/coupons/{coupon}'
            .replace('{' + 'coupon' + '}', encodeURIComponent(String(coupon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling deleteCouponsCoupon.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedCoupon;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedCoupon");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Permanently deletes a customer. It cannot be undone. Also immediately cancels any active subscriptions on the customer.</p>
     * @param customer 
     */
    public async deleteCustomersCustomer (customer: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedCustomer;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling deleteCustomersCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedCustomer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedCustomer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Removes the currently applied discount on a customer.</p>
     * @param customer 
     */
    public async deleteCustomersCustomerDiscount (customer: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedDiscount;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/discount'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling deleteCustomersCustomerDiscount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedDiscount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedDiscount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Delete a specified source for a given customer.</p>
     * @param customer 
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async deleteCustomersCustomerSourcesId (customer: string, id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeleteCustomersCustomerSourcesId200Response;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/sources/{id}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling deleteCustomersCustomerSourcesId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCustomersCustomerSourcesId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeleteCustomersCustomerSourcesId200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeleteCustomersCustomerSourcesId200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes an existing <code>TaxID</code> object.</p>
     * @param customer 
     * @param id 
     */
    public async deleteCustomersCustomerTaxIdsId (customer: string, id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedTaxId;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/tax_ids/{id}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling deleteCustomersCustomerTaxIdsId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCustomersCustomerTaxIdsId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedTaxId;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedTaxId");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Invalidates a short-lived API key for a given resource.</p>
     * @param key 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async deleteEphemeralKeysKey (key: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EphemeralKey;  }> {
        const localVarPath = this.basePath + '/v1/ephemeral_keys/{key}'
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteEphemeralKeysKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: EphemeralKey;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "EphemeralKey");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes an invoice item, removing it from an invoice. Deleting invoice items is only possible when they’re not attached to invoices, or if it’s attached to a draft invoice.</p>
     * @param invoiceitem 
     */
    public async deleteInvoiceitemsInvoiceitem (invoiceitem: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedInvoiceitem;  }> {
        const localVarPath = this.basePath + '/v1/invoiceitems/{invoiceitem}'
            .replace('{' + 'invoiceitem' + '}', encodeURIComponent(String(invoiceitem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceitem' is not null or undefined
        if (invoiceitem === null || invoiceitem === undefined) {
            throw new Error('Required parameter invoiceitem was null or undefined when calling deleteInvoiceitemsInvoiceitem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedInvoiceitem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedInvoiceitem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Permanently deletes a one-off invoice draft. This cannot be undone. Attempts to delete invoices that are no longer in a draft state will fail; once an invoice has been finalized or if an invoice is for a subscription, it must be <a href=\"#void_invoice\">voided</a>.</p>
     * @param invoice 
     */
    public async deleteInvoicesInvoice (invoice: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedInvoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling deleteInvoicesInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedInvoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedInvoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deleting plans means new subscribers can’t be added. Existing subscribers aren’t affected.</p>
     * @param plan 
     */
    public async deletePlansPlan (plan: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedPlan;  }> {
        const localVarPath = this.basePath + '/v1/plans/{plan}'
            .replace('{' + 'plan' + '}', encodeURIComponent(String(plan)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'plan' is not null or undefined
        if (plan === null || plan === undefined) {
            throw new Error('Required parameter plan was null or undefined when calling deletePlansPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedPlan;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedPlan");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Delete a product. Deleting a product is only possible if it has no prices associated with it. Additionally, deleting a product with <code>type=good</code> is only possible if it has no SKUs associated with it.</p>
     * @param id 
     */
    public async deleteProductsId (id: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedProduct;  }> {
        const localVarPath = this.basePath + '/v1/products/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteProductsId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedProduct;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedProduct");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes a <code>ValueListItem</code> object, removing it from its parent value list.</p>
     * @param item 
     */
    public async deleteRadarValueListItemsItem (item: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedRadarValueListItem;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_list_items/{item}'
            .replace('{' + 'item' + '}', encodeURIComponent(String(item)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling deleteRadarValueListItemsItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedRadarValueListItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedRadarValueListItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes a <code>ValueList</code> object, also deleting any items contained within the value list. To be deleted, a value list must not be referenced in any rules.</p>
     * @param valueList 
     */
    public async deleteRadarValueListsValueList (valueList: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedRadarValueList;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_lists/{value_list}'
            .replace('{' + 'value_list' + '}', encodeURIComponent(String(valueList)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'valueList' is not null or undefined
        if (valueList === null || valueList === undefined) {
            throw new Error('Required parameter valueList was null or undefined when calling deleteRadarValueListsValueList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedRadarValueList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedRadarValueList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes an item from the subscription. Removing a subscription item from a subscription will not cancel the subscription.</p>
     * @param item 
     * @param clearUsage Delete all usage for the given subscription item. Allowed only when the current plan\\\&#39;s &#x60;usage_type&#x60; is &#x60;metered&#x60;.
     * @param prorationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting &#x60;billing_cycle_anchor&#x3D;now&#x60;, or starting a trial), or if an item\\\&#39;s &#x60;quantity&#x60; changes. The default value is &#x60;create_prorations&#x60;.
     * @param prorationDate If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
     */
    public async deleteSubscriptionItemsItem (item: string, clearUsage?: boolean, prorationBehavior?: string, prorationDate?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedSubscriptionItem;  }> {
        const localVarPath = this.basePath + '/v1/subscription_items/{item}'
            .replace('{' + 'item' + '}', encodeURIComponent(String(item)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling deleteSubscriptionItemsItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (clearUsage !== undefined) {
            localVarFormParams['clear_usage'] = ObjectSerializer.serialize(clearUsage, "boolean");
        }

        if (prorationBehavior !== undefined) {
            localVarFormParams['proration_behavior'] = ObjectSerializer.serialize(prorationBehavior, "string");
        }

        if (prorationDate !== undefined) {
            localVarFormParams['proration_date'] = ObjectSerializer.serialize(prorationDate, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedSubscriptionItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedSubscriptionItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancels a customer’s subscription immediately. The customer will not be charged again for the subscription.</p>  <p>Note, however, that any pending invoice items that you’ve created will still be charged for at the end of the period, unless manually <a href=\"#delete_invoiceitem\">deleted</a>. If you’ve set the subscription to cancel at the end of the period, any pending prorations will also be left in place and collected at the end of the period. But if the subscription is set to cancel immediately, pending prorations will be removed.</p>  <p>By default, upon subscription cancellation, Stripe will stop automatic collection of all finalized invoices for the customer. This is intended to prevent unexpected payment attempts after the customer has canceled a subscription. However, you can resume automatic collection of the invoices manually after subscription cancellation to have us proceed. Or, you could check for unpaid invoices before allowing the customer to cancel the subscription at all.</p>
     * @param subscriptionExposedId 
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoiceNow Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
     * @param prorate Will generate a proration invoice item that credits remaining unused time until the subscription period end.
     */
    public async deleteSubscriptionsSubscriptionExposedId (subscriptionExposedId: string, expand?: Array<string>, invoiceNow?: boolean, prorate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions/{subscription_exposed_id}'
            .replace('{' + 'subscription_exposed_id' + '}', encodeURIComponent(String(subscriptionExposedId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionExposedId' is not null or undefined
        if (subscriptionExposedId === null || subscriptionExposedId === undefined) {
            throw new Error('Required parameter subscriptionExposedId was null or undefined when calling deleteSubscriptionsSubscriptionExposedId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoiceNow !== undefined) {
            localVarFormParams['invoice_now'] = ObjectSerializer.serialize(invoiceNow, "boolean");
        }

        if (prorate !== undefined) {
            localVarFormParams['prorate'] = ObjectSerializer.serialize(prorate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Subscription");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Removes the currently applied discount on a subscription.</p>
     * @param subscriptionExposedId 
     */
    public async deleteSubscriptionsSubscriptionExposedIdDiscount (subscriptionExposedId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedDiscount;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions/{subscription_exposed_id}/discount'
            .replace('{' + 'subscription_exposed_id' + '}', encodeURIComponent(String(subscriptionExposedId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionExposedId' is not null or undefined
        if (subscriptionExposedId === null || subscriptionExposedId === undefined) {
            throw new Error('Required parameter subscriptionExposedId was null or undefined when calling deleteSubscriptionsSubscriptionExposedIdDiscount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedDiscount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedDiscount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes a <code>Configuration</code> object.</p>
     * @param configuration 
     */
    public async deleteTerminalConfigurationsConfiguration (configuration: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedTerminalConfiguration;  }> {
        const localVarPath = this.basePath + '/v1/terminal/configurations/{configuration}'
            .replace('{' + 'configuration' + '}', encodeURIComponent(String(configuration)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'configuration' is not null or undefined
        if (configuration === null || configuration === undefined) {
            throw new Error('Required parameter configuration was null or undefined when calling deleteTerminalConfigurationsConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedTerminalConfiguration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedTerminalConfiguration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes a <code>Location</code> object.</p>
     * @param location 
     */
    public async deleteTerminalLocationsLocation (location: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedTerminalLocation;  }> {
        const localVarPath = this.basePath + '/v1/terminal/locations/{location}'
            .replace('{' + 'location' + '}', encodeURIComponent(String(location)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'location' is not null or undefined
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling deleteTerminalLocationsLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedTerminalLocation;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedTerminalLocation");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes a <code>Reader</code> object.</p>
     * @param reader 
     */
    public async deleteTerminalReadersReader (reader: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedTerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling deleteTerminalReadersReader.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedTerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedTerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes a test clock.</p>
     * @param testClock 
     */
    public async deleteTestHelpersTestClocksTestClock (testClock: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedTestHelpersTestClock;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/test_clocks/{test_clock}'
            .replace('{' + 'test_clock' + '}', encodeURIComponent(String(testClock)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'testClock' is not null or undefined
        if (testClock === null || testClock === undefined) {
            throw new Error('Required parameter testClock was null or undefined when calling deleteTestHelpersTestClocksTestClock.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedTestHelpersTestClock;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedTestHelpersTestClock");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can also delete webhook endpoints via the <a href=\"https://dashboard.stripe.com/account/webhooks\">webhook endpoint management</a> page of the Stripe dashboard.</p>
     * @param webhookEndpoint 
     */
    public async deleteWebhookEndpointsWebhookEndpoint (webhookEndpoint: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DeletedWebhookEndpoint;  }> {
        const localVarPath = this.basePath + '/v1/webhook_endpoints/{webhook_endpoint}'
            .replace('{' + 'webhook_endpoint' + '}', encodeURIComponent(String(webhookEndpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'webhookEndpoint' is not null or undefined
        if (webhookEndpoint === null || webhookEndpoint === undefined) {
            throw new Error('Required parameter webhookEndpoint was null or undefined when calling deleteWebhookEndpointsWebhookEndpoint.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DeletedWebhookEndpoint;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DeletedWebhookEndpoint");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an account.</p>
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getAccount (expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/account';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of accounts connected to your platform via <a href=\"/docs/connect\">Connect</a>. If you’re not a platform, the list is empty.</p>
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getAccounts (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccountList;  }> {
        const localVarPath = this.basePath + '/v1/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AccountList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AccountList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an account.</p>
     * @param account 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getAccountsAccount (account: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountsAccount.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of capabilities associated with the account. The capabilities are returned sorted by creation date, with the most recent capability appearing first.</p>
     * @param account 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getAccountsAccountCapabilities (account: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ListAccountCapability;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/capabilities'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountsAccountCapabilities.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ListAccountCapability;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ListAccountCapability");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves information about the specified Account Capability.</p>
     * @param account 
     * @param capability 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getAccountsAccountCapabilitiesCapability (account: string, capability: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Capability;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/capabilities/{capability}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'capability' + '}', encodeURIComponent(String(capability)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountsAccountCapabilitiesCapability.');
        }

        // verify required parameter 'capability' is not null or undefined
        if (capability === null || capability === undefined) {
            throw new Error('Required parameter capability was null or undefined when calling getAccountsAccountCapabilitiesCapability.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Capability;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Capability");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>List external accounts for an account.</p>
     * @param account 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getAccountsAccountExternalAccounts (account: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ExternalAccountList;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/external_accounts'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountsAccountExternalAccounts.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ExternalAccountList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ExternalAccountList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieve a specified external account for a given account.</p>
     * @param account 
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getAccountsAccountExternalAccountsId (account: string, id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ExternalAccount;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/external_accounts/{id}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountsAccountExternalAccountsId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getAccountsAccountExternalAccountsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ExternalAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ExternalAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of people associated with the account’s legal entity. The people are returned sorted by creation date, with the most recent people appearing first.</p>
     * @param account 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param relationship Filters on the list of people returned based on the person\&#39;s relationship to the account\&#39;s company.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getAccountsAccountPersons (account: string, endingBefore?: string, expand?: Array<string>, limit?: number, relationship?: AllPeopleRelationshipSpecs, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PersonList;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/persons'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountsAccountPersons.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (relationship !== undefined) {
            localVarQueryParameters['relationship'] = ObjectSerializer.serialize(relationship, "AllPeopleRelationshipSpecs");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PersonList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PersonList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an existing person.</p>
     * @param account 
     * @param person 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getAccountsAccountPersonsPerson (account: string, person: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Person;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/persons/{person}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'person' + '}', encodeURIComponent(String(person)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getAccountsAccountPersonsPerson.');
        }

        // verify required parameter 'person' is not null or undefined
        if (person === null || person === undefined) {
            throw new Error('Required parameter person was null or undefined when calling getAccountsAccountPersonsPerson.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Person;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Person");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>List apple pay domains.</p>
     * @param domainName 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getApplePayDomains (domainName?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ApplePayDomainList;  }> {
        const localVarPath = this.basePath + '/v1/apple_pay/domains';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (domainName !== undefined) {
            localVarQueryParameters['domain_name'] = ObjectSerializer.serialize(domainName, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ApplePayDomainList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ApplePayDomainList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieve an apple pay domain.</p>
     * @param domain 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getApplePayDomainsDomain (domain: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ApplePayDomain;  }> {
        const localVarPath = this.basePath + '/v1/apple_pay/domains/{domain}'
            .replace('{' + 'domain' + '}', encodeURIComponent(String(domain)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'domain' is not null or undefined
        if (domain === null || domain === undefined) {
            throw new Error('Required parameter domain was null or undefined when calling getApplePayDomainsDomain.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ApplePayDomain;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ApplePayDomain");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of application fees you’ve previously collected. The application fees are returned in sorted order, with the most recent fees appearing first.</p>
     * @param charge Only return application fees for the charge specified by this charge ID.
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getApplicationFees (charge?: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlatformEarningList;  }> {
        const localVarPath = this.basePath + '/v1/application_fees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (charge !== undefined) {
            localVarQueryParameters['charge'] = ObjectSerializer.serialize(charge, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PlatformEarningList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PlatformEarningList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>By default, you can see the 10 most recent refunds stored directly on the application fee object, but you can also retrieve details about a specific refund stored on the application fee.</p>
     * @param fee 
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getApplicationFeesFeeRefundsId (fee: string, id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FeeRefund;  }> {
        const localVarPath = this.basePath + '/v1/application_fees/{fee}/refunds/{id}'
            .replace('{' + 'fee' + '}', encodeURIComponent(String(fee)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'fee' is not null or undefined
        if (fee === null || fee === undefined) {
            throw new Error('Required parameter fee was null or undefined when calling getApplicationFeesFeeRefundsId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getApplicationFeesFeeRefundsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FeeRefund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FeeRefund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an application fee that your account has collected. The same information is returned when refunding the application fee.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getApplicationFeesId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ApplicationFee;  }> {
        const localVarPath = this.basePath + '/v1/application_fees/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getApplicationFeesId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ApplicationFee;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ApplicationFee");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can see a list of the refunds belonging to a specific application fee. Note that the 10 most recent refunds are always available by default on the application fee object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional refunds.</p>
     * @param id 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getApplicationFeesIdRefunds (id: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FeeRefundList;  }> {
        const localVarPath = this.basePath + '/v1/application_fees/{id}/refunds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getApplicationFeesIdRefunds.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FeeRefundList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FeeRefundList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>List all secrets stored on the given scope.</p>
     * @param scope Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getAppsSecrets (scope: ScopeParam, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SecretServiceResourceSecretList;  }> {
        const localVarPath = this.basePath + '/v1/apps/secrets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getAppsSecrets.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "ScopeParam");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SecretServiceResourceSecretList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SecretServiceResourceSecretList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Finds a secret in the secret store by name and scope.</p>
     * @param name A name for the secret that\&#39;s unique within the scope.
     * @param scope Specifies the scoping of the secret. Requests originating from UI extensions can only access account-scoped secrets or secrets scoped to their own user.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getAppsSecretsFind (name: string, scope: ScopeParam, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AppsSecret;  }> {
        const localVarPath = this.basePath + '/v1/apps/secrets/find';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getAppsSecretsFind.');
        }

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling getAppsSecretsFind.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (scope !== undefined) {
            localVarQueryParameters['scope'] = ObjectSerializer.serialize(scope, "ScopeParam");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AppsSecret;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AppsSecret");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the current account balance, based on the authentication that was used to make the request.  For a sample request, see <a href=\"/docs/connect/account-balances#accounting-for-negative-balances\">Accounting for negative balances</a>.</p>
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getBalance (expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Balance;  }> {
        const localVarPath = this.basePath + '/v1/balance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Balance;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Balance");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of transactions that have contributed to the Stripe account balance (e.g., charges, transfers, and so forth). The transactions are returned in sorted order, with the most recent transactions appearing first.</p>  <p>Note that this endpoint was previously called “Balance history” and used the path <code>/v1/balance/history</code>.</p>
     * @param availableOn This parameter is deprecated and we recommend listing by created and filtering in memory instead.
     * @param created 
     * @param currency Only return transactions in a certain currency. Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param payout For automatic Stripe payouts only, only returns transactions that were paid out on the specified payout ID.
     * @param source Only returns the original transaction.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type Only returns transactions of the given type. One of: &#x60;adjustment&#x60;, &#x60;advance&#x60;, &#x60;advance_funding&#x60;, &#x60;anticipation_repayment&#x60;, &#x60;application_fee&#x60;, &#x60;application_fee_refund&#x60;, &#x60;charge&#x60;, &#x60;connect_collection_transfer&#x60;, &#x60;contribution&#x60;, &#x60;issuing_authorization_hold&#x60;, &#x60;issuing_authorization_release&#x60;, &#x60;issuing_dispute&#x60;, &#x60;issuing_transaction&#x60;, &#x60;payment&#x60;, &#x60;payment_failure_refund&#x60;, &#x60;payment_refund&#x60;, &#x60;payout&#x60;, &#x60;payout_cancel&#x60;, &#x60;payout_failure&#x60;, &#x60;refund&#x60;, &#x60;refund_failure&#x60;, &#x60;reserve_transaction&#x60;, &#x60;reserved_funds&#x60;, &#x60;stripe_fee&#x60;, &#x60;stripe_fx_fee&#x60;, &#x60;tax_fee&#x60;, &#x60;topup&#x60;, &#x60;topup_reversal&#x60;, &#x60;transfer&#x60;, &#x60;transfer_cancel&#x60;, &#x60;transfer_failure&#x60;, or &#x60;transfer_refund&#x60;.
     */
    public async getBalanceTransactions (availableOn?: GetAccountsCreatedParameter, created?: GetAccountsCreatedParameter, currency?: string, endingBefore?: string, expand?: Array<string>, limit?: number, payout?: string, source?: string, startingAfter?: string, type?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BalanceTransactionsList;  }> {
        const localVarPath = this.basePath + '/v1/balance_transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (availableOn !== undefined) {
            localVarQueryParameters['available_on'] = ObjectSerializer.serialize(availableOn, "GetAccountsCreatedParameter");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (payout !== undefined) {
            localVarQueryParameters['payout'] = ObjectSerializer.serialize(payout, "string");
        }

        if (source !== undefined) {
            localVarQueryParameters['source'] = ObjectSerializer.serialize(source, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BalanceTransactionsList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BalanceTransactionsList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the balance transaction with the given ID.</p>  <p>Note that this endpoint previously used the path <code>/v1/balance/history/:id</code>.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getBalanceTransactionsId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BalanceTransaction;  }> {
        const localVarPath = this.basePath + '/v1/balance_transactions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getBalanceTransactionsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BalanceTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BalanceTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of configurations that describe the functionality of the customer portal.</p>
     * @param active Only return configurations that are active or inactive (e.g., pass &#x60;true&#x60; to only list active configurations).
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param isDefault Only return the default or non-default configurations (e.g., pass &#x60;true&#x60; to only list the default configuration).
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getBillingPortalConfigurations (active?: boolean, endingBefore?: string, expand?: Array<string>, isDefault?: boolean, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PortalConfigurationList;  }> {
        const localVarPath = this.basePath + '/v1/billing_portal/configurations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (isDefault !== undefined) {
            localVarQueryParameters['is_default'] = ObjectSerializer.serialize(isDefault, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PortalConfigurationList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PortalConfigurationList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a configuration that describes the functionality of the customer portal.</p>
     * @param configuration 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getBillingPortalConfigurationsConfiguration (configuration: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BillingPortalConfiguration;  }> {
        const localVarPath = this.basePath + '/v1/billing_portal/configurations/{configuration}'
            .replace('{' + 'configuration' + '}', encodeURIComponent(String(configuration)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'configuration' is not null or undefined
        if (configuration === null || configuration === undefined) {
            throw new Error('Required parameter configuration was null or undefined when calling getBillingPortalConfigurationsConfiguration.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BillingPortalConfiguration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BillingPortalConfiguration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of charges you’ve previously created. The charges are returned in sorted order, with the most recent charges appearing first.</p>
     * @param created 
     * @param customer Only return charges for the customer specified by this customer ID.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param paymentIntent Only return charges that were created by the PaymentIntent specified by this PaymentIntent ID.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param transferGroup Only return charges for this transfer group.
     */
    public async getCharges (created?: GetAccountsCreatedParameter, customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, paymentIntent?: string, startingAfter?: string, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ChargeList;  }> {
        const localVarPath = this.basePath + '/v1/charges';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (paymentIntent !== undefined) {
            localVarQueryParameters['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (transferGroup !== undefined) {
            localVarQueryParameters['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ChargeList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ChargeList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a charge that has previously been created. Supply the unique charge ID that was returned from your previous request, and Stripe will return the corresponding charge information. The same information is returned when creating or refunding the charge.</p>
     * @param charge 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getChargesCharge (charge: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Charge;  }> {
        const localVarPath = this.basePath + '/v1/charges/{charge}'
            .replace('{' + 'charge' + '}', encodeURIComponent(String(charge)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'charge' is not null or undefined
        if (charge === null || charge === undefined) {
            throw new Error('Required parameter charge was null or undefined when calling getChargesCharge.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Charge;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Charge");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can see a list of the refunds belonging to a specific charge. Note that the 10 most recent refunds are always available by default on the charge object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional refunds.</p>
     * @param charge 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getChargesChargeRefunds (charge: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RefundList;  }> {
        const localVarPath = this.basePath + '/v1/charges/{charge}/refunds'
            .replace('{' + 'charge' + '}', encodeURIComponent(String(charge)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'charge' is not null or undefined
        if (charge === null || charge === undefined) {
            throw new Error('Required parameter charge was null or undefined when calling getChargesChargeRefunds.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RefundList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RefundList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing refund.</p>
     * @param charge 
     * @param refund 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getChargesChargeRefundsRefund (charge: string, refund: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Refund;  }> {
        const localVarPath = this.basePath + '/v1/charges/{charge}/refunds/{refund}'
            .replace('{' + 'charge' + '}', encodeURIComponent(String(charge)))
            .replace('{' + 'refund' + '}', encodeURIComponent(String(refund)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'charge' is not null or undefined
        if (charge === null || charge === undefined) {
            throw new Error('Required parameter charge was null or undefined when calling getChargesChargeRefundsRefund.');
        }

        // verify required parameter 'refund' is not null or undefined
        if (refund === null || refund === undefined) {
            throw new Error('Required parameter refund was null or undefined when calling getChargesChargeRefundsRefund.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Refund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Refund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Search for charges you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
     * @param query The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for charges](https://stripe.com/docs/search#query-fields-for-charges).
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param page A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     */
    public async getChargesSearch (query: string, expand?: Array<string>, limit?: number, page?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResult;  }> {
        const localVarPath = this.basePath + '/v1/charges/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getChargesSearch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResult;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResult");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Checkout Sessions.</p>
     * @param customer Only return the Checkout Sessions for the Customer specified.
     * @param customerDetails Only return the Checkout Sessions for the Customer details specified.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param paymentIntent Only return the Checkout Session for the PaymentIntent specified.
     * @param paymentLink Only return the Checkout Sessions for the Payment Link specified.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param subscription Only return the Checkout Session for the subscription specified.
     */
    public async getCheckoutSessions (customer?: string, customerDetails?: CustomerDetailsParams, endingBefore?: string, expand?: Array<string>, limit?: number, paymentIntent?: string, paymentLink?: string, startingAfter?: string, subscription?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentPagesCheckoutSessionList;  }> {
        const localVarPath = this.basePath + '/v1/checkout/sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (customerDetails !== undefined) {
            localVarQueryParameters['customer_details'] = ObjectSerializer.serialize(customerDetails, "CustomerDetailsParams");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (paymentIntent !== undefined) {
            localVarQueryParameters['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (paymentLink !== undefined) {
            localVarQueryParameters['payment_link'] = ObjectSerializer.serialize(paymentLink, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (subscription !== undefined) {
            localVarQueryParameters['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentPagesCheckoutSessionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentPagesCheckoutSessionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a Session object.</p>
     * @param session 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCheckoutSessionsSession (session: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CheckoutSession;  }> {
        const localVarPath = this.basePath + '/v1/checkout/sessions/{session}'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling getCheckoutSessionsSession.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CheckoutSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CheckoutSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving a Checkout Session, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
     * @param session 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCheckoutSessionsSessionLineItems (session: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentPagesCheckoutSessionListLineItems;  }> {
        const localVarPath = this.basePath + '/v1/checkout/sessions/{session}/line_items'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling getCheckoutSessionsSessionLineItems.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentPagesCheckoutSessionListLineItems;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentPagesCheckoutSessionListLineItems");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Lists all Country Spec objects available in the API.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCountrySpecs (endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CountrySpecList;  }> {
        const localVarPath = this.basePath + '/v1/country_specs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CountrySpecList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CountrySpecList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a Country Spec for a given Country code.</p>
     * @param country 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCountrySpecsCountry (country: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CountrySpec;  }> {
        const localVarPath = this.basePath + '/v1/country_specs/{country}'
            .replace('{' + 'country' + '}', encodeURIComponent(String(country)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'country' is not null or undefined
        if (country === null || country === undefined) {
            throw new Error('Required parameter country was null or undefined when calling getCountrySpecsCountry.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CountrySpec;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CountrySpec");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your coupons.</p>
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCoupons (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CouponsResourceCouponList;  }> {
        const localVarPath = this.basePath + '/v1/coupons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CouponsResourceCouponList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CouponsResourceCouponList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the coupon with the given ID.</p>
     * @param coupon 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCouponsCoupon (coupon: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Coupon;  }> {
        const localVarPath = this.basePath + '/v1/coupons/{coupon}'
            .replace('{' + 'coupon' + '}', encodeURIComponent(String(coupon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling getCouponsCoupon.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Coupon;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Coupon");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of credit notes.</p>
     * @param customer Only return credit notes for the customer specified by this customer ID.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoice Only return credit notes for the invoice specified by this invoice ID.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCreditNotes (customer?: string, endingBefore?: string, expand?: Array<string>, invoice?: string, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNotesList;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoice !== undefined) {
            localVarQueryParameters['invoice'] = ObjectSerializer.serialize(invoice, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNotesList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNotesList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving a credit note, you’ll get a <strong>lines</strong> property containing the the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
     * @param creditNote 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCreditNotesCreditNoteLines (creditNote: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNoteLinesList;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes/{credit_note}/lines'
            .replace('{' + 'credit_note' + '}', encodeURIComponent(String(creditNote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'creditNote' is not null or undefined
        if (creditNote === null || creditNote === undefined) {
            throw new Error('Required parameter creditNote was null or undefined when calling getCreditNotesCreditNoteLines.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNoteLinesList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNoteLinesList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the credit note object with the given identifier.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCreditNotesId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNote;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCreditNotesId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Get a preview of a credit note without creating it.</p>
     * @param invoice ID of the invoice.
     * @param amount The integer amount in cents (or local equivalent) representing the total amount of the credit note.
     * @param creditAmount The integer amount in cents (or local equivalent) representing the amount to credit the customer\&#39;s balance, which will be automatically applied to their next invoice.
     * @param expand Specifies which fields in the response should be expanded.
     * @param lines Line items that make up the credit note.
     * @param memo The credit note\&#39;s memo appears on the credit note PDF.
     * @param metadata Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to &#x60;metadata&#x60;.
     * @param outOfBandAmount The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
     * @param reason Reason for issuing this credit note, one of &#x60;duplicate&#x60;, &#x60;fraudulent&#x60;, &#x60;order_change&#x60;, or &#x60;product_unsatisfactory&#x60;
     * @param refund ID of an existing refund to link this credit note to.
     * @param refundAmount The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
     * @param shippingCost When shipping_cost contains the shipping_rate from the invoice, the shipping_cost is included in the credit note.
     */
    public async getCreditNotesPreview (invoice: string, amount?: number, creditAmount?: number, expand?: Array<string>, lines?: Array<CreditNoteLineItemParams>, memo?: string, metadata?: { [key: string]: string; }, outOfBandAmount?: number, reason?: 'duplicate' | 'fraudulent' | 'order_change' | 'product_unsatisfactory', refund?: string, refundAmount?: number, shippingCost?: CreditNoteShippingCost1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNote;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes/preview';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling getCreditNotesPreview.');
        }

        if (amount !== undefined) {
            localVarQueryParameters['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (creditAmount !== undefined) {
            localVarQueryParameters['credit_amount'] = ObjectSerializer.serialize(creditAmount, "number");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoice !== undefined) {
            localVarQueryParameters['invoice'] = ObjectSerializer.serialize(invoice, "string");
        }

        if (lines !== undefined) {
            localVarQueryParameters['lines'] = ObjectSerializer.serialize(lines, "Array<CreditNoteLineItemParams>");
        }

        if (memo !== undefined) {
            localVarQueryParameters['memo'] = ObjectSerializer.serialize(memo, "string");
        }

        if (metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(metadata, "{ [key: string]: string; }");
        }

        if (outOfBandAmount !== undefined) {
            localVarQueryParameters['out_of_band_amount'] = ObjectSerializer.serialize(outOfBandAmount, "number");
        }

        if (reason !== undefined) {
            localVarQueryParameters['reason'] = ObjectSerializer.serialize(reason, "'duplicate' | 'fraudulent' | 'order_change' | 'product_unsatisfactory'");
        }

        if (refund !== undefined) {
            localVarQueryParameters['refund'] = ObjectSerializer.serialize(refund, "string");
        }

        if (refundAmount !== undefined) {
            localVarQueryParameters['refund_amount'] = ObjectSerializer.serialize(refundAmount, "number");
        }

        if (shippingCost !== undefined) {
            localVarQueryParameters['shipping_cost'] = ObjectSerializer.serialize(shippingCost, "CreditNoteShippingCost1");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving a credit note preview, you’ll get a <strong>lines</strong> property containing the first handful of those items. This URL you can retrieve the full (paginated) list of line items.</p>
     * @param invoice ID of the invoice.
     * @param amount The integer amount in cents (or local equivalent) representing the total amount of the credit note.
     * @param creditAmount The integer amount in cents (or local equivalent) representing the amount to credit the customer\&#39;s balance, which will be automatically applied to their next invoice.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param lines Line items that make up the credit note.
     * @param memo The credit note\&#39;s memo appears on the credit note PDF.
     * @param metadata Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format. Individual keys can be unset by posting an empty value to them. All keys can be unset by posting an empty value to &#x60;metadata&#x60;.
     * @param outOfBandAmount The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
     * @param reason Reason for issuing this credit note, one of &#x60;duplicate&#x60;, &#x60;fraudulent&#x60;, &#x60;order_change&#x60;, or &#x60;product_unsatisfactory&#x60;
     * @param refund ID of an existing refund to link this credit note to.
     * @param refundAmount The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
     * @param shippingCost When shipping_cost contains the shipping_rate from the invoice, the shipping_cost is included in the credit note.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCreditNotesPreviewLines (invoice: string, amount?: number, creditAmount?: number, endingBefore?: string, expand?: Array<string>, limit?: number, lines?: Array<CreditNoteLineItemParams>, memo?: string, metadata?: { [key: string]: string; }, outOfBandAmount?: number, reason?: 'duplicate' | 'fraudulent' | 'order_change' | 'product_unsatisfactory', refund?: string, refundAmount?: number, shippingCost?: CreditNoteShippingCost1, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNoteLinesList;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes/preview/lines';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling getCreditNotesPreviewLines.');
        }

        if (amount !== undefined) {
            localVarQueryParameters['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (creditAmount !== undefined) {
            localVarQueryParameters['credit_amount'] = ObjectSerializer.serialize(creditAmount, "number");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoice !== undefined) {
            localVarQueryParameters['invoice'] = ObjectSerializer.serialize(invoice, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (lines !== undefined) {
            localVarQueryParameters['lines'] = ObjectSerializer.serialize(lines, "Array<CreditNoteLineItemParams>");
        }

        if (memo !== undefined) {
            localVarQueryParameters['memo'] = ObjectSerializer.serialize(memo, "string");
        }

        if (metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(metadata, "{ [key: string]: string; }");
        }

        if (outOfBandAmount !== undefined) {
            localVarQueryParameters['out_of_band_amount'] = ObjectSerializer.serialize(outOfBandAmount, "number");
        }

        if (reason !== undefined) {
            localVarQueryParameters['reason'] = ObjectSerializer.serialize(reason, "'duplicate' | 'fraudulent' | 'order_change' | 'product_unsatisfactory'");
        }

        if (refund !== undefined) {
            localVarQueryParameters['refund'] = ObjectSerializer.serialize(refund, "string");
        }

        if (refundAmount !== undefined) {
            localVarQueryParameters['refund_amount'] = ObjectSerializer.serialize(refundAmount, "number");
        }

        if (shippingCost !== undefined) {
            localVarQueryParameters['shipping_cost'] = ObjectSerializer.serialize(shippingCost, "CreditNoteShippingCost1");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNoteLinesList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNoteLinesList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your customers. The customers are returned sorted by creation date, with the most recent customers appearing first.</p>
     * @param created 
     * @param email A case-sensitive filter on the list based on the customer\&#39;s &#x60;email&#x60; field. The value must be a string.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param testClock Provides a list of customers that are associated with the specified test clock. The response will not include customers with test clocks if this parameter is not set.
     */
    public async getCustomers (created?: GetAccountsCreatedParameter, email?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, testClock?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerResourceCustomerList;  }> {
        const localVarPath = this.basePath + '/v1/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (testClock !== undefined) {
            localVarQueryParameters['test_clock'] = ObjectSerializer.serialize(testClock, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerResourceCustomerList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerResourceCustomerList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a Customer object.</p>
     * @param customer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCustomersCustomer (customer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetCustomersCustomer200Response;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomer.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetCustomersCustomer200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetCustomersCustomer200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of transactions that updated the customer’s <a href=\"/docs/billing/customer/balance\">balances</a>.</p>
     * @param customer 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCustomersCustomerBalanceTransactions (customer: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransactionList;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/balance_transactions'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerBalanceTransactions.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransactionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerBalanceTransactionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a specific customer balance transaction that updated the customer’s <a href=\"/docs/billing/customer/balance\">balances</a>.</p>
     * @param customer 
     * @param transaction 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCustomersCustomerBalanceTransactionsTransaction (customer: string, transaction: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransaction;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/balance_transactions/{transaction}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerBalanceTransactionsTransaction.');
        }

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getCustomersCustomerBalanceTransactionsTransaction.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerBalanceTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a customer’s cash balance.</p>
     * @param customer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCustomersCustomerCashBalance (customer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CashBalance;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/cash_balance'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerCashBalance.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CashBalance;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CashBalance");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of transactions that modified the customer’s <a href=\"/docs/payments/customer-balance\">cash balance</a>.</p>
     * @param customer 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCustomersCustomerCashBalanceTransactions (customer: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerCashBalanceTransactionList;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/cash_balance_transactions'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerCashBalanceTransactions.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerCashBalanceTransactionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerCashBalanceTransactionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a specific cash balance transaction, which updated the customer’s <a href=\"/docs/payments/customer-balance\">cash balance</a>.</p>
     * @param customer 
     * @param transaction 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCustomersCustomerCashBalanceTransactionsTransaction (customer: string, transaction: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerCashBalanceTransaction;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/cash_balance_transactions/{transaction}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerCashBalanceTransactionsTransaction.');
        }

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getCustomersCustomerCashBalanceTransactionsTransaction.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerCashBalanceTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerCashBalanceTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of PaymentMethods for a given Customer</p>
     * @param customer 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type An optional filter on the list, based on the object &#x60;type&#x60; field. Without the filter, the list includes all current and future payment method types. If your integration expects only one type of payment method in the response, make sure to provide a type value in the request.
     */
    public async getCustomersCustomerPaymentMethods (customer: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, type?: 'acss_debit' | 'affirm' | 'afterpay_clearpay' | 'alipay' | 'au_becs_debit' | 'bacs_debit' | 'bancontact' | 'blik' | 'boleto' | 'card' | 'card_present' | 'customer_balance' | 'eps' | 'fpx' | 'giropay' | 'grabpay' | 'ideal' | 'klarna' | 'konbini' | 'link' | 'oxxo' | 'p24' | 'paynow' | 'pix' | 'promptpay' | 'sepa_debit' | 'sofort' | 'us_bank_account' | 'wechat_pay', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerPaymentMethodResourceList;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/payment_methods'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerPaymentMethods.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'acss_debit' | 'affirm' | 'afterpay_clearpay' | 'alipay' | 'au_becs_debit' | 'bacs_debit' | 'bancontact' | 'blik' | 'boleto' | 'card' | 'card_present' | 'customer_balance' | 'eps' | 'fpx' | 'giropay' | 'grabpay' | 'ideal' | 'klarna' | 'konbini' | 'link' | 'oxxo' | 'p24' | 'paynow' | 'pix' | 'promptpay' | 'sepa_debit' | 'sofort' | 'us_bank_account' | 'wechat_pay'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerPaymentMethodResourceList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerPaymentMethodResourceList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a PaymentMethod object for a given Customer.</p>
     * @param customer 
     * @param paymentMethod 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCustomersCustomerPaymentMethodsPaymentMethod (customer: string, paymentMethod: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/payment_methods/{payment_method}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'payment_method' + '}', encodeURIComponent(String(paymentMethod)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerPaymentMethodsPaymentMethod.');
        }

        // verify required parameter 'paymentMethod' is not null or undefined
        if (paymentMethod === null || paymentMethod === undefined) {
            throw new Error('Required parameter paymentMethod was null or undefined when calling getCustomersCustomerPaymentMethodsPaymentMethod.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentMethod");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>List sources for a specified customer.</p>
     * @param customer 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param object Filter sources according to a particular object type.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCustomersCustomerSources (customer: string, endingBefore?: string, expand?: Array<string>, limit?: number, object?: string, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ApmsSourcesSourceList;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/sources'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerSources.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (object !== undefined) {
            localVarQueryParameters['object'] = ObjectSerializer.serialize(object, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ApmsSourcesSourceList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ApmsSourcesSourceList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieve a specified source for a given customer.</p>
     * @param customer 
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCustomersCustomerSourcesId (customer: string, id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentSource;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/sources/{id}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerSourcesId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomersCustomerSourcesId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentSource;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentSource");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of tax IDs for a customer.</p>
     * @param customer 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getCustomersCustomerTaxIds (customer: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxIDsList;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/tax_ids'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerTaxIds.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxIDsList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxIDsList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the <code>TaxID</code> object with the given identifier.</p>
     * @param customer 
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getCustomersCustomerTaxIdsId (customer: string, id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxId;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/tax_ids/{id}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling getCustomersCustomerTaxIdsId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getCustomersCustomerTaxIdsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxId;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxId");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Search for customers you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
     * @param query The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for customers](https://stripe.com/docs/search#query-fields-for-customers).
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param page A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     */
    public async getCustomersSearch (query: string, expand?: Array<string>, limit?: number, page?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResult1;  }> {
        const localVarPath = this.basePath + '/v1/customers/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getCustomersSearch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResult1;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResult1");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your disputes.</p>
     * @param charge Only return disputes associated to the charge specified by this charge ID.
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param paymentIntent Only return disputes associated to the PaymentIntent specified by this PaymentIntent ID.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getDisputes (charge?: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, paymentIntent?: string, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: DisputeList;  }> {
        const localVarPath = this.basePath + '/v1/disputes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (charge !== undefined) {
            localVarQueryParameters['charge'] = ObjectSerializer.serialize(charge, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (paymentIntent !== undefined) {
            localVarQueryParameters['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: DisputeList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "DisputeList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the dispute with the given ID.</p>
     * @param dispute 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getDisputesDispute (dispute: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Dispute;  }> {
        const localVarPath = this.basePath + '/v1/disputes/{dispute}'
            .replace('{' + 'dispute' + '}', encodeURIComponent(String(dispute)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'dispute' is not null or undefined
        if (dispute === null || dispute === undefined) {
            throw new Error('Required parameter dispute was null or undefined when calling getDisputesDispute.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Dispute;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Dispute");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>List events, going back up to 30 days. Each event data is rendered according to Stripe API version at its creation time, specified in <a href=\"/docs/api/events/object\">event object</a> <code>api_version</code> attribute (not according to your current Stripe API version or <code>Stripe-Version</code> header).</p>
     * @param created 
     * @param deliverySuccess Filter events by whether all webhooks were successfully delivered. If false, events which are still pending or have failed all delivery attempts to a webhook endpoint will be returned.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type A string containing a specific event name, or group of events using * as a wildcard. The list will be filtered to include only events with a matching event property.
     * @param types An array of up to 20 strings containing specific event names. The list will be filtered to include only events with a matching event property. You may pass either &#x60;type&#x60; or &#x60;types&#x60;, but not both.
     */
    public async getEvents (created?: GetAccountsCreatedParameter, deliverySuccess?: boolean, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, type?: string, types?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationEventList;  }> {
        const localVarPath = this.basePath + '/v1/events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (deliverySuccess !== undefined) {
            localVarQueryParameters['delivery_success'] = ObjectSerializer.serialize(deliverySuccess, "boolean");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (types !== undefined) {
            localVarQueryParameters['types'] = ObjectSerializer.serialize(types, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationEventList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationEventList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an event. Supply the unique identifier of the event, which you might have received in a webhook.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getEventsId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Event;  }> {
        const localVarPath = this.basePath + '/v1/events/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getEventsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Event;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Event");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of objects that contain the rates at which foreign currencies are converted to one another. Only shows the currencies for which Stripe supports.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with the exchange rate for currency X your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and total number of supported payout currencies, and the default is the max.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is the currency that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with the exchange rate for currency X, your subsequent call can include &#x60;starting_after&#x3D;X&#x60; in order to fetch the next page of the list.
     */
    public async getExchangeRates (endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ExchangeRateList;  }> {
        const localVarPath = this.basePath + '/v1/exchange_rates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ExchangeRateList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ExchangeRateList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the exchange rates from the given currency to every supported currency.</p>
     * @param rateId 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getExchangeRatesRateId (rateId: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ExchangeRate;  }> {
        const localVarPath = this.basePath + '/v1/exchange_rates/{rate_id}'
            .replace('{' + 'rate_id' + '}', encodeURIComponent(String(rateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'rateId' is not null or undefined
        if (rateId === null || rateId === undefined) {
            throw new Error('Required parameter rateId was null or undefined when calling getExchangeRatesRateId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ExchangeRate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ExchangeRate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of file links.</p>
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param expired Filter links by their expiration status. By default, all links are returned.
     * @param file Only return links for the given file.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getFileLinks (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, expired?: boolean, file?: string, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileFileLinkList;  }> {
        const localVarPath = this.basePath + '/v1/file_links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expired !== undefined) {
            localVarQueryParameters['expired'] = ObjectSerializer.serialize(expired, "boolean");
        }

        if (file !== undefined) {
            localVarQueryParameters['file'] = ObjectSerializer.serialize(file, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileFileLinkList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileFileLinkList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the file link with the given ID.</p>
     * @param link 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getFileLinksLink (link: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileLink;  }> {
        const localVarPath = this.basePath + '/v1/file_links/{link}'
            .replace('{' + 'link' + '}', encodeURIComponent(String(link)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'link' is not null or undefined
        if (link === null || link === undefined) {
            throw new Error('Required parameter link was null or undefined when calling getFileLinksLink.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of the files that your account has access to. The files are returned sorted by creation date, with the most recently created files appearing first.</p>
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param purpose The file purpose to filter queries by. If none is provided, files will not be filtered by purpose.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getFiles (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, purpose?: 'account_requirement' | 'additional_verification' | 'business_icon' | 'business_logo' | 'customer_signature' | 'dispute_evidence' | 'document_provider_identity_document' | 'finance_report_run' | 'identity_document' | 'identity_document_downloadable' | 'pci_document' | 'selfie' | 'sigma_scheduled_query' | 'tax_document_user_upload' | 'terminal_reader_splashscreen', startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileFileList;  }> {
        const localVarPath = this.basePath + '/v1/files';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (purpose !== undefined) {
            localVarQueryParameters['purpose'] = ObjectSerializer.serialize(purpose, "'account_requirement' | 'additional_verification' | 'business_icon' | 'business_logo' | 'customer_signature' | 'dispute_evidence' | 'document_provider_identity_document' | 'finance_report_run' | 'identity_document' | 'identity_document_downloadable' | 'pci_document' | 'selfie' | 'sigma_scheduled_query' | 'tax_document_user_upload' | 'terminal_reader_splashscreen'");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileFileList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileFileList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing file object. Supply the unique file ID from a file, and Stripe will return the corresponding file object. To access file contents, see the <a href=\"/docs/file-upload#download-file-contents\">File Upload Guide</a>.</p>
     * @param file 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getFilesFile (file: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RequestFile;  }> {
        const localVarPath = this.basePath + '/v1/files/{file}'
            .replace('{' + 'file' + '}', encodeURIComponent(String(file)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling getFilesFile.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RequestFile;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RequestFile");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Financial Connections <code>Account</code> objects.</p>
     * @param accountHolder If present, only return accounts that belong to the specified account holder. &#x60;account_holder[customer]&#x60; and &#x60;account_holder[account]&#x60; are mutually exclusive.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param session If present, only return accounts that were collected as part of the given session.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getFinancialConnectionsAccounts (accountHolder?: AccountholderParams, endingBefore?: string, expand?: Array<string>, limit?: number, session?: string, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BankConnectionsResourceLinkedAccountList;  }> {
        const localVarPath = this.basePath + '/v1/financial_connections/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (accountHolder !== undefined) {
            localVarQueryParameters['account_holder'] = ObjectSerializer.serialize(accountHolder, "AccountholderParams");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (session !== undefined) {
            localVarQueryParameters['session'] = ObjectSerializer.serialize(session, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BankConnectionsResourceLinkedAccountList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BankConnectionsResourceLinkedAccountList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an Financial Connections <code>Account</code>.</p>
     * @param account 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getFinancialConnectionsAccountsAccount (account: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FinancialConnectionsAccount;  }> {
        const localVarPath = this.basePath + '/v1/financial_connections/accounts/{account}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getFinancialConnectionsAccountsAccount.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FinancialConnectionsAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FinancialConnectionsAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Lists all owners for a given <code>Account</code></p>
     * @param account 
     * @param ownership The ID of the ownership object to fetch owners from.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getFinancialConnectionsAccountsAccountOwners (account: string, ownership: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BankConnectionsResourceOwnerList;  }> {
        const localVarPath = this.basePath + '/v1/financial_connections/accounts/{account}/owners'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling getFinancialConnectionsAccountsAccountOwners.');
        }

        // verify required parameter 'ownership' is not null or undefined
        if (ownership === null || ownership === undefined) {
            throw new Error('Required parameter ownership was null or undefined when calling getFinancialConnectionsAccountsAccountOwners.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (ownership !== undefined) {
            localVarQueryParameters['ownership'] = ObjectSerializer.serialize(ownership, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BankConnectionsResourceOwnerList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BankConnectionsResourceOwnerList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a Financial Connections <code>Session</code></p>
     * @param session 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getFinancialConnectionsSessionsSession (session: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FinancialConnectionsSession;  }> {
        const localVarPath = this.basePath + '/v1/financial_connections/sessions/{session}'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling getFinancialConnectionsSessionsSession.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FinancialConnectionsSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FinancialConnectionsSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>List all verification reports.</p>
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type Only return VerificationReports of this type
     * @param verificationSession Only return VerificationReports created by this VerificationSession ID. It is allowed to provide a VerificationIntent ID.
     */
    public async getIdentityVerificationReports (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, type?: 'document' | 'id_number', verificationSession?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GelatoVerificationReportList;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_reports';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'document' | 'id_number'");
        }

        if (verificationSession !== undefined) {
            localVarQueryParameters['verification_session'] = ObjectSerializer.serialize(verificationSession, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GelatoVerificationReportList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GelatoVerificationReportList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an existing VerificationReport</p>
     * @param report 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getIdentityVerificationReportsReport (report: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IdentityVerificationReport;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_reports/{report}'
            .replace('{' + 'report' + '}', encodeURIComponent(String(report)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'report' is not null or undefined
        if (report === null || report === undefined) {
            throw new Error('Required parameter report was null or undefined when calling getIdentityVerificationReportsReport.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IdentityVerificationReport;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IdentityVerificationReport");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of VerificationSessions</p>
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return VerificationSessions with this status. [Learn more about the lifecycle of sessions](https://stripe.com/docs/identity/how-sessions-work).
     */
    public async getIdentityVerificationSessions (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'canceled' | 'processing' | 'requires_input' | 'verified', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GelatoVerificationSessionList;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'canceled' | 'processing' | 'requires_input' | 'verified'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GelatoVerificationSessionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GelatoVerificationSessionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a VerificationSession that was previously created.</p>  <p>When the session status is <code>requires_input</code>, you can use this method to retrieve a valid <code>client_secret</code> or <code>url</code> to allow re-submission.</p>
     * @param session 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getIdentityVerificationSessionsSession (session: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_sessions/{session}'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling getIdentityVerificationSessionsSession.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IdentityVerificationSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your invoice items. Invoice items are returned sorted by creation date, with the most recently created invoice items appearing first.</p>
     * @param created 
     * @param customer The identifier of the customer whose invoice items to return. If none is provided, all invoice items will be returned.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoice Only return invoice items belonging to this invoice. If none is provided, all invoice items will be returned. If specifying an invoice, no customer identifier is needed.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param pending Set to &#x60;true&#x60; to only show pending invoice items, which are not yet attached to any invoices. Set to &#x60;false&#x60; to only show invoice items already attached to invoices. If unspecified, no filter is applied.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getInvoiceitems (created?: GetAccountsCreatedParameter, customer?: string, endingBefore?: string, expand?: Array<string>, invoice?: string, limit?: number, pending?: boolean, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: InvoicesItemsList;  }> {
        const localVarPath = this.basePath + '/v1/invoiceitems';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoice !== undefined) {
            localVarQueryParameters['invoice'] = ObjectSerializer.serialize(invoice, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (pending !== undefined) {
            localVarQueryParameters['pending'] = ObjectSerializer.serialize(pending, "boolean");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: InvoicesItemsList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "InvoicesItemsList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the invoice item with the given ID.</p>
     * @param invoiceitem 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getInvoiceitemsInvoiceitem (invoiceitem: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoiceitem;  }> {
        const localVarPath = this.basePath + '/v1/invoiceitems/{invoiceitem}'
            .replace('{' + 'invoiceitem' + '}', encodeURIComponent(String(invoiceitem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceitem' is not null or undefined
        if (invoiceitem === null || invoiceitem === undefined) {
            throw new Error('Required parameter invoiceitem was null or undefined when calling getInvoiceitemsInvoiceitem.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoiceitem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoiceitem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can list all invoices, or list the invoices for a specific customer. The invoices are returned sorted by creation date, with the most recently created invoices appearing first.</p>
     * @param collectionMethod The collection method of the invoice to retrieve. Either &#x60;charge_automatically&#x60; or &#x60;send_invoice&#x60;.
     * @param created 
     * @param customer Only return invoices for the customer specified by this customer ID.
     * @param dueDate 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status The status of the invoice, one of &#x60;draft&#x60;, &#x60;open&#x60;, &#x60;paid&#x60;, &#x60;uncollectible&#x60;, or &#x60;void&#x60;. [Learn more](https://stripe.com/docs/billing/invoices/workflow#workflow-overview)
     * @param subscription Only return invoices for the subscription specified by this subscription ID.
     */
    public async getInvoices (collectionMethod?: 'charge_automatically' | 'send_invoice', created?: GetAccountsCreatedParameter, customer?: string, dueDate?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'draft' | 'open' | 'paid' | 'uncollectible' | 'void', subscription?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: InvoicesList;  }> {
        const localVarPath = this.basePath + '/v1/invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (collectionMethod !== undefined) {
            localVarQueryParameters['collection_method'] = ObjectSerializer.serialize(collectionMethod, "'charge_automatically' | 'send_invoice'");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (dueDate !== undefined) {
            localVarQueryParameters['due_date'] = ObjectSerializer.serialize(dueDate, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'draft' | 'open' | 'paid' | 'uncollectible' | 'void'");
        }

        if (subscription !== undefined) {
            localVarQueryParameters['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: InvoicesList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "InvoicesList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the invoice with the given ID.</p>
     * @param invoice 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getInvoicesInvoice (invoice: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling getInvoicesInvoice.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving an invoice, you’ll get a <strong>lines</strong> property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
     * @param invoice 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getInvoicesInvoiceLines (invoice: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: InvoiceLinesList;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}/lines'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling getInvoicesInvoiceLines.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: InvoiceLinesList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "InvoiceLinesList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Search for invoices you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
     * @param query The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for invoices](https://stripe.com/docs/search#query-fields-for-invoices).
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param page A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     */
    public async getInvoicesSearch (query: string, expand?: Array<string>, limit?: number, page?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResult2;  }> {
        const localVarPath = this.basePath + '/v1/invoices/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getInvoicesSearch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResult2;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResult2");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>At any time, you can preview the upcoming invoice for a customer. This will show you all the charges that are pending, including subscription renewal charges, invoice item charges, etc. It will also show you any discounts that are applicable to the invoice.</p>  <p>Note that when you are viewing an upcoming invoice, you are simply viewing a preview – the invoice has not yet been created. As such, the upcoming invoice will not show up in invoice listing calls, and you cannot use the API to pay or edit the invoice. If you want to change the amount that your customer will be billed, you can add, remove, or update pending invoice items, or update the customer’s discount.</p>  <p>You can preview the effects of updating a subscription, including a preview of what proration will take place. To ensure that the actual proration is calculated exactly the same as the previewed proration, you should pass a <code>proration_date</code> parameter when doing the actual subscription update. The value passed in should be the same as the <code>subscription_proration_date</code> returned on the upcoming invoice resource. The recommended way to get only the prorations being previewed is to consider only proration line items where <code>period[start]</code> is equal to the <code>subscription_proration_date</code> on the upcoming invoice resource.</p>
     * @param automaticTax Settings for automatic tax lookup for this invoice preview.
     * @param coupon The code of the coupon to apply. If &#x60;subscription&#x60; or &#x60;subscription_items&#x60; is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer\&#39;s subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
     * @param currency The currency to preview this invoice in. Defaults to that of &#x60;customer&#x60; if not specified.
     * @param customer The identifier of the customer whose upcoming invoice you\&#39;d like to retrieve.
     * @param customerDetails Details about the customer you want to invoice or overrides for an existing customer.
     * @param discounts The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the &#x60;coupon&#x60; parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn\&#39;t been created, use &#x60;coupon&#x60; instead.
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoiceItems List of invoice items to add or update in the upcoming invoice preview.
     * @param schedule The identifier of the unstarted schedule whose upcoming invoice you\&#39;d like to retrieve. Cannot be used with subscription or subscription fields.
     * @param subscription The identifier of the subscription for which you\&#39;d like to retrieve the upcoming invoice. If not provided, but a &#x60;subscription_items&#x60; is provided, you will preview creating a subscription with those items. If neither &#x60;subscription&#x60; nor &#x60;subscription_items&#x60; is provided, you will retrieve the next upcoming invoice from among the customer\&#39;s subscriptions.
     * @param subscriptionBillingCycleAnchor For new subscriptions, a future timestamp to anchor the subscription\&#39;s [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with &#x60;month&#x60; or &#x60;year&#x60; intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to &#x60;now&#x60; or &#x60;unchanged&#x60;.
     * @param subscriptionCancelAt Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using &#x60;proration_behavior&#x60;.
     * @param subscriptionCancelAtPeriodEnd Boolean indicating whether this subscription should cancel at the end of the current period.
     * @param subscriptionCancelNow This simulates the subscription being canceled or expired immediately.
     * @param subscriptionDefaultTaxRates If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have &#x60;tax_rates&#x60; set.
     * @param subscriptionItems A list of up to 20 subscription items, each with an attached price.
     * @param subscriptionProrationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting &#x60;billing_cycle_anchor&#x3D;now&#x60;, or starting a trial), or if an item\&#39;s &#x60;quantity&#x60; changes. The default value is &#x60;create_prorations&#x60;.
     * @param subscriptionProrationDate If previewing an update to a subscription, and doing proration, &#x60;subscription_proration_date&#x60; forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period and within the current phase of the schedule backing this subscription, if the schedule exists. If set, &#x60;subscription&#x60;, and one of &#x60;subscription_items&#x60;, or &#x60;subscription_trial_end&#x60; are required. Also, &#x60;subscription_proration_behavior&#x60; cannot be set to \&#39;none\&#39;.
     * @param subscriptionResumeAt For paused subscriptions, setting &#x60;subscription_resume_at&#x60; to &#x60;now&#x60; will preview the invoice that will be generated if the subscription is resumed.
     * @param subscriptionStartDate Date a subscription is intended to start (can be future or past)
     * @param subscriptionTrialEnd If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of &#x60;subscription_items&#x60; or &#x60;subscription&#x60; is required.
     * @param subscriptionTrialFromPlan Indicates if a plan\&#39;s &#x60;trial_period_days&#x60; should be applied to the subscription. Setting &#x60;subscription_trial_end&#x60; per subscription is preferred, and this defaults to &#x60;false&#x60;. Setting this flag to &#x60;true&#x60; together with &#x60;subscription_trial_end&#x60; is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
     */
    public async getInvoicesUpcoming (automaticTax?: AutomaticTaxParam1, coupon?: string, currency?: string, customer?: string, customerDetails?: CustomerDetailsParam, discounts?: GetInvoicesUpcomingDiscountsParameter, expand?: Array<string>, invoiceItems?: Array<InvoiceItemPreviewParams>, schedule?: string, subscription?: string, subscriptionBillingCycleAnchor?: GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter, subscriptionCancelAt?: GetInvoicesUpcomingSubscriptionCancelAtParameter, subscriptionCancelAtPeriodEnd?: boolean, subscriptionCancelNow?: boolean, subscriptionDefaultTaxRates?: GetInvoicesUpcomingSubscriptionDefaultTaxRatesParameter, subscriptionItems?: Array<SubscriptionItemUpdateParams>, subscriptionProrationBehavior?: 'always_invoice' | 'create_prorations' | 'none', subscriptionProrationDate?: number, subscriptionResumeAt?: 'now', subscriptionStartDate?: number, subscriptionTrialEnd?: GetInvoicesUpcomingSubscriptionTrialEndParameter, subscriptionTrialFromPlan?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/upcoming';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (automaticTax !== undefined) {
            localVarQueryParameters['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParam1");
        }

        if (coupon !== undefined) {
            localVarQueryParameters['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (customerDetails !== undefined) {
            localVarQueryParameters['customer_details'] = ObjectSerializer.serialize(customerDetails, "CustomerDetailsParam");
        }

        if (discounts !== undefined) {
            localVarQueryParameters['discounts'] = ObjectSerializer.serialize(discounts, "GetInvoicesUpcomingDiscountsParameter");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoiceItems !== undefined) {
            localVarQueryParameters['invoice_items'] = ObjectSerializer.serialize(invoiceItems, "Array<InvoiceItemPreviewParams>");
        }

        if (schedule !== undefined) {
            localVarQueryParameters['schedule'] = ObjectSerializer.serialize(schedule, "string");
        }

        if (subscription !== undefined) {
            localVarQueryParameters['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        if (subscriptionBillingCycleAnchor !== undefined) {
            localVarQueryParameters['subscription_billing_cycle_anchor'] = ObjectSerializer.serialize(subscriptionBillingCycleAnchor, "GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter");
        }

        if (subscriptionCancelAt !== undefined) {
            localVarQueryParameters['subscription_cancel_at'] = ObjectSerializer.serialize(subscriptionCancelAt, "GetInvoicesUpcomingSubscriptionCancelAtParameter");
        }

        if (subscriptionCancelAtPeriodEnd !== undefined) {
            localVarQueryParameters['subscription_cancel_at_period_end'] = ObjectSerializer.serialize(subscriptionCancelAtPeriodEnd, "boolean");
        }

        if (subscriptionCancelNow !== undefined) {
            localVarQueryParameters['subscription_cancel_now'] = ObjectSerializer.serialize(subscriptionCancelNow, "boolean");
        }

        if (subscriptionDefaultTaxRates !== undefined) {
            localVarQueryParameters['subscription_default_tax_rates'] = ObjectSerializer.serialize(subscriptionDefaultTaxRates, "GetInvoicesUpcomingSubscriptionDefaultTaxRatesParameter");
        }

        if (subscriptionItems !== undefined) {
            localVarQueryParameters['subscription_items'] = ObjectSerializer.serialize(subscriptionItems, "Array<SubscriptionItemUpdateParams>");
        }

        if (subscriptionProrationBehavior !== undefined) {
            localVarQueryParameters['subscription_proration_behavior'] = ObjectSerializer.serialize(subscriptionProrationBehavior, "'always_invoice' | 'create_prorations' | 'none'");
        }

        if (subscriptionProrationDate !== undefined) {
            localVarQueryParameters['subscription_proration_date'] = ObjectSerializer.serialize(subscriptionProrationDate, "number");
        }

        if (subscriptionResumeAt !== undefined) {
            localVarQueryParameters['subscription_resume_at'] = ObjectSerializer.serialize(subscriptionResumeAt, "'now'");
        }

        if (subscriptionStartDate !== undefined) {
            localVarQueryParameters['subscription_start_date'] = ObjectSerializer.serialize(subscriptionStartDate, "number");
        }

        if (subscriptionTrialEnd !== undefined) {
            localVarQueryParameters['subscription_trial_end'] = ObjectSerializer.serialize(subscriptionTrialEnd, "GetInvoicesUpcomingSubscriptionTrialEndParameter");
        }

        if (subscriptionTrialFromPlan !== undefined) {
            localVarQueryParameters['subscription_trial_from_plan'] = ObjectSerializer.serialize(subscriptionTrialFromPlan, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving an upcoming invoice, you’ll get a <strong>lines</strong> property containing the total count of line items and the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
     * @param automaticTax Settings for automatic tax lookup for this invoice preview.
     * @param coupon The code of the coupon to apply. If &#x60;subscription&#x60; or &#x60;subscription_items&#x60; is provided, the invoice returned will preview updating or creating a subscription with that coupon. Otherwise, it will preview applying that coupon to the customer for the next upcoming invoice from among the customer\&#39;s subscriptions. The invoice can be previewed without a coupon by passing this value as an empty string.
     * @param currency The currency to preview this invoice in. Defaults to that of &#x60;customer&#x60; if not specified.
     * @param customer The identifier of the customer whose upcoming invoice you\&#39;d like to retrieve.
     * @param customerDetails Details about the customer you want to invoice or overrides for an existing customer.
     * @param discounts The coupons to redeem into discounts for the invoice preview. If not specified, inherits the discount from the customer or subscription. This only works for coupons directly applied to the invoice. To apply a coupon to a subscription, you must use the &#x60;coupon&#x60; parameter instead. Pass an empty string to avoid inheriting any discounts. To preview the upcoming invoice for a subscription that hasn\&#39;t been created, use &#x60;coupon&#x60; instead.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoiceItems List of invoice items to add or update in the upcoming invoice preview.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param schedule The identifier of the unstarted schedule whose upcoming invoice you\&#39;d like to retrieve. Cannot be used with subscription or subscription fields.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param subscription The identifier of the subscription for which you\&#39;d like to retrieve the upcoming invoice. If not provided, but a &#x60;subscription_items&#x60; is provided, you will preview creating a subscription with those items. If neither &#x60;subscription&#x60; nor &#x60;subscription_items&#x60; is provided, you will retrieve the next upcoming invoice from among the customer\&#39;s subscriptions.
     * @param subscriptionBillingCycleAnchor For new subscriptions, a future timestamp to anchor the subscription\&#39;s [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with &#x60;month&#x60; or &#x60;year&#x60; intervals, the day of the month for subsequent invoices. For existing subscriptions, the value can only be set to &#x60;now&#x60; or &#x60;unchanged&#x60;.
     * @param subscriptionCancelAt Timestamp indicating when the subscription should be scheduled to cancel. Will prorate if within the current period and prorations have been enabled using &#x60;proration_behavior&#x60;.
     * @param subscriptionCancelAtPeriodEnd Boolean indicating whether this subscription should cancel at the end of the current period.
     * @param subscriptionCancelNow This simulates the subscription being canceled or expired immediately.
     * @param subscriptionDefaultTaxRates If provided, the invoice returned will preview updating or creating a subscription with these default tax rates. The default tax rates will apply to any line item that does not have &#x60;tax_rates&#x60; set.
     * @param subscriptionItems A list of up to 20 subscription items, each with an attached price.
     * @param subscriptionProrationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting &#x60;billing_cycle_anchor&#x3D;now&#x60;, or starting a trial), or if an item\&#39;s &#x60;quantity&#x60; changes. The default value is &#x60;create_prorations&#x60;.
     * @param subscriptionProrationDate If previewing an update to a subscription, and doing proration, &#x60;subscription_proration_date&#x60; forces the proration to be calculated as though the update was done at the specified time. The time given must be within the current subscription period and within the current phase of the schedule backing this subscription, if the schedule exists. If set, &#x60;subscription&#x60;, and one of &#x60;subscription_items&#x60;, or &#x60;subscription_trial_end&#x60; are required. Also, &#x60;subscription_proration_behavior&#x60; cannot be set to \&#39;none\&#39;.
     * @param subscriptionResumeAt For paused subscriptions, setting &#x60;subscription_resume_at&#x60; to &#x60;now&#x60; will preview the invoice that will be generated if the subscription is resumed.
     * @param subscriptionStartDate Date a subscription is intended to start (can be future or past)
     * @param subscriptionTrialEnd If provided, the invoice returned will preview updating or creating a subscription with that trial end. If set, one of &#x60;subscription_items&#x60; or &#x60;subscription&#x60; is required.
     * @param subscriptionTrialFromPlan Indicates if a plan\&#39;s &#x60;trial_period_days&#x60; should be applied to the subscription. Setting &#x60;subscription_trial_end&#x60; per subscription is preferred, and this defaults to &#x60;false&#x60;. Setting this flag to &#x60;true&#x60; together with &#x60;subscription_trial_end&#x60; is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
     */
    public async getInvoicesUpcomingLines (automaticTax?: AutomaticTaxParam1, coupon?: string, currency?: string, customer?: string, customerDetails?: CustomerDetailsParam, discounts?: GetInvoicesUpcomingDiscountsParameter, endingBefore?: string, expand?: Array<string>, invoiceItems?: Array<InvoiceItemPreviewParams>, limit?: number, schedule?: string, startingAfter?: string, subscription?: string, subscriptionBillingCycleAnchor?: GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter, subscriptionCancelAt?: GetInvoicesUpcomingSubscriptionCancelAtParameter, subscriptionCancelAtPeriodEnd?: boolean, subscriptionCancelNow?: boolean, subscriptionDefaultTaxRates?: GetInvoicesUpcomingSubscriptionDefaultTaxRatesParameter, subscriptionItems?: Array<SubscriptionItemUpdateParams>, subscriptionProrationBehavior?: 'always_invoice' | 'create_prorations' | 'none', subscriptionProrationDate?: number, subscriptionResumeAt?: 'now', subscriptionStartDate?: number, subscriptionTrialEnd?: GetInvoicesUpcomingSubscriptionTrialEndParameter, subscriptionTrialFromPlan?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: InvoiceLinesList;  }> {
        const localVarPath = this.basePath + '/v1/invoices/upcoming/lines';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (automaticTax !== undefined) {
            localVarQueryParameters['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParam1");
        }

        if (coupon !== undefined) {
            localVarQueryParameters['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (customerDetails !== undefined) {
            localVarQueryParameters['customer_details'] = ObjectSerializer.serialize(customerDetails, "CustomerDetailsParam");
        }

        if (discounts !== undefined) {
            localVarQueryParameters['discounts'] = ObjectSerializer.serialize(discounts, "GetInvoicesUpcomingDiscountsParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoiceItems !== undefined) {
            localVarQueryParameters['invoice_items'] = ObjectSerializer.serialize(invoiceItems, "Array<InvoiceItemPreviewParams>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (schedule !== undefined) {
            localVarQueryParameters['schedule'] = ObjectSerializer.serialize(schedule, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (subscription !== undefined) {
            localVarQueryParameters['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        if (subscriptionBillingCycleAnchor !== undefined) {
            localVarQueryParameters['subscription_billing_cycle_anchor'] = ObjectSerializer.serialize(subscriptionBillingCycleAnchor, "GetInvoicesUpcomingSubscriptionBillingCycleAnchorParameter");
        }

        if (subscriptionCancelAt !== undefined) {
            localVarQueryParameters['subscription_cancel_at'] = ObjectSerializer.serialize(subscriptionCancelAt, "GetInvoicesUpcomingSubscriptionCancelAtParameter");
        }

        if (subscriptionCancelAtPeriodEnd !== undefined) {
            localVarQueryParameters['subscription_cancel_at_period_end'] = ObjectSerializer.serialize(subscriptionCancelAtPeriodEnd, "boolean");
        }

        if (subscriptionCancelNow !== undefined) {
            localVarQueryParameters['subscription_cancel_now'] = ObjectSerializer.serialize(subscriptionCancelNow, "boolean");
        }

        if (subscriptionDefaultTaxRates !== undefined) {
            localVarQueryParameters['subscription_default_tax_rates'] = ObjectSerializer.serialize(subscriptionDefaultTaxRates, "GetInvoicesUpcomingSubscriptionDefaultTaxRatesParameter");
        }

        if (subscriptionItems !== undefined) {
            localVarQueryParameters['subscription_items'] = ObjectSerializer.serialize(subscriptionItems, "Array<SubscriptionItemUpdateParams>");
        }

        if (subscriptionProrationBehavior !== undefined) {
            localVarQueryParameters['subscription_proration_behavior'] = ObjectSerializer.serialize(subscriptionProrationBehavior, "'always_invoice' | 'create_prorations' | 'none'");
        }

        if (subscriptionProrationDate !== undefined) {
            localVarQueryParameters['subscription_proration_date'] = ObjectSerializer.serialize(subscriptionProrationDate, "number");
        }

        if (subscriptionResumeAt !== undefined) {
            localVarQueryParameters['subscription_resume_at'] = ObjectSerializer.serialize(subscriptionResumeAt, "'now'");
        }

        if (subscriptionStartDate !== undefined) {
            localVarQueryParameters['subscription_start_date'] = ObjectSerializer.serialize(subscriptionStartDate, "number");
        }

        if (subscriptionTrialEnd !== undefined) {
            localVarQueryParameters['subscription_trial_end'] = ObjectSerializer.serialize(subscriptionTrialEnd, "GetInvoicesUpcomingSubscriptionTrialEndParameter");
        }

        if (subscriptionTrialFromPlan !== undefined) {
            localVarQueryParameters['subscription_trial_from_plan'] = ObjectSerializer.serialize(subscriptionTrialFromPlan, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: InvoiceLinesList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "InvoiceLinesList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Issuing <code>Authorization</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param card Only return authorizations that belong to the given card.
     * @param cardholder Only return authorizations that belong to the given cardholder.
     * @param created Only return authorizations that were created during the given date interval.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return authorizations with the given status. One of &#x60;pending&#x60;, &#x60;closed&#x60;, or &#x60;reversed&#x60;.
     */
    public async getIssuingAuthorizations (card?: string, cardholder?: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'closed' | 'pending' | 'reversed', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingAuthorizationList;  }> {
        const localVarPath = this.basePath + '/v1/issuing/authorizations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (card !== undefined) {
            localVarQueryParameters['card'] = ObjectSerializer.serialize(card, "string");
        }

        if (cardholder !== undefined) {
            localVarQueryParameters['cardholder'] = ObjectSerializer.serialize(cardholder, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'closed' | 'pending' | 'reversed'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingAuthorizationList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingAuthorizationList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an Issuing <code>Authorization</code> object.</p>
     * @param authorization 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getIssuingAuthorizationsAuthorization (authorization: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }> {
        const localVarPath = this.basePath + '/v1/issuing/authorizations/{authorization}'
            .replace('{' + 'authorization' + '}', encodeURIComponent(String(authorization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling getIssuingAuthorizationsAuthorization.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingAuthorization");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Issuing <code>Cardholder</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param created Only return cardholders that were created during the given date interval.
     * @param email Only return cardholders that have the given email address.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param phoneNumber Only return cardholders that have the given phone number.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return cardholders that have the given status. One of &#x60;active&#x60;, &#x60;inactive&#x60;, or &#x60;blocked&#x60;.
     * @param type Only return cardholders that have the given type. One of &#x60;individual&#x60; or &#x60;company&#x60;.
     */
    public async getIssuingCardholders (created?: GetAccountsCreatedParameter, email?: string, endingBefore?: string, expand?: Array<string>, limit?: number, phoneNumber?: string, startingAfter?: string, status?: 'active' | 'blocked' | 'inactive', type?: 'company' | 'individual', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCardholderList;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cardholders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (phoneNumber !== undefined) {
            localVarQueryParameters['phone_number'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'active' | 'blocked' | 'inactive'");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'company' | 'individual'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCardholderList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCardholderList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an Issuing <code>Cardholder</code> object.</p>
     * @param cardholder 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getIssuingCardholdersCardholder (cardholder: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCardholder;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cardholders/{cardholder}'
            .replace('{' + 'cardholder' + '}', encodeURIComponent(String(cardholder)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'cardholder' is not null or undefined
        if (cardholder === null || cardholder === undefined) {
            throw new Error('Required parameter cardholder was null or undefined when calling getIssuingCardholdersCardholder.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCardholder;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCardholder");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Issuing <code>Card</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param cardholder Only return cards belonging to the Cardholder with the provided ID.
     * @param created Only return cards that were issued during the given date interval.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expMonth Only return cards that have the given expiration month.
     * @param expYear Only return cards that have the given expiration year.
     * @param expand Specifies which fields in the response should be expanded.
     * @param last4 Only return cards that have the given last four digits.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return cards that have the given status. One of &#x60;active&#x60;, &#x60;inactive&#x60;, or &#x60;canceled&#x60;.
     * @param type Only return cards that have the given type. One of &#x60;virtual&#x60; or &#x60;physical&#x60;.
     */
    public async getIssuingCards (cardholder?: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expMonth?: number, expYear?: number, expand?: Array<string>, last4?: string, limit?: number, startingAfter?: string, status?: 'active' | 'canceled' | 'inactive', type?: 'physical' | 'virtual', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCardList;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cards';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (cardholder !== undefined) {
            localVarQueryParameters['cardholder'] = ObjectSerializer.serialize(cardholder, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expMonth !== undefined) {
            localVarQueryParameters['exp_month'] = ObjectSerializer.serialize(expMonth, "number");
        }

        if (expYear !== undefined) {
            localVarQueryParameters['exp_year'] = ObjectSerializer.serialize(expYear, "number");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (last4 !== undefined) {
            localVarQueryParameters['last4'] = ObjectSerializer.serialize(last4, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'active' | 'canceled' | 'inactive'");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'physical' | 'virtual'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCardList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCardList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an Issuing <code>Card</code> object.</p>
     * @param card 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getIssuingCardsCard (card: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCard;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cards/{card}'
            .replace('{' + 'card' + '}', encodeURIComponent(String(card)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling getIssuingCardsCard.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCard;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCard");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Issuing <code>Dispute</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param created Select Issuing disputes that were created during the given date interval.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Select Issuing disputes with the given status.
     * @param transaction Select the Issuing dispute for the given transaction.
     */
    public async getIssuingDisputes (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'expired' | 'lost' | 'submitted' | 'unsubmitted' | 'won', transaction?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingDisputeList;  }> {
        const localVarPath = this.basePath + '/v1/issuing/disputes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'expired' | 'lost' | 'submitted' | 'unsubmitted' | 'won'");
        }

        if (transaction !== undefined) {
            localVarQueryParameters['transaction'] = ObjectSerializer.serialize(transaction, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingDisputeList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingDisputeList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an Issuing <code>Dispute</code> object.</p>
     * @param dispute 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getIssuingDisputesDispute (dispute: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }> {
        const localVarPath = this.basePath + '/v1/issuing/disputes/{dispute}'
            .replace('{' + 'dispute' + '}', encodeURIComponent(String(dispute)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'dispute' is not null or undefined
        if (dispute === null || dispute === undefined) {
            throw new Error('Required parameter dispute was null or undefined when calling getIssuingDisputesDispute.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingDispute");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Issuing <code>Transaction</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param card Only return transactions that belong to the given card.
     * @param cardholder Only return transactions that belong to the given cardholder.
     * @param created Only return transactions that were created during the given date interval.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type Only return transactions that have the given type. One of &#x60;capture&#x60; or &#x60;refund&#x60;.
     */
    public async getIssuingTransactions (card?: string, cardholder?: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, type?: 'capture' | 'refund', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingTransactionList;  }> {
        const localVarPath = this.basePath + '/v1/issuing/transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (card !== undefined) {
            localVarQueryParameters['card'] = ObjectSerializer.serialize(card, "string");
        }

        if (cardholder !== undefined) {
            localVarQueryParameters['cardholder'] = ObjectSerializer.serialize(cardholder, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'capture' | 'refund'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingTransactionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingTransactionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an Issuing <code>Transaction</code> object.</p>
     * @param transaction 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getIssuingTransactionsTransaction (transaction: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingTransaction;  }> {
        const localVarPath = this.basePath + '/v1/issuing/transactions/{transaction}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling getIssuingTransactionsTransaction.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a Mandate object.</p>
     * @param mandate 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getMandatesMandate (mandate: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Mandate;  }> {
        const localVarPath = this.basePath + '/v1/mandates/{mandate}'
            .replace('{' + 'mandate' + '}', encodeURIComponent(String(mandate)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'mandate' is not null or undefined
        if (mandate === null || mandate === undefined) {
            throw new Error('Required parameter mandate was null or undefined when calling getMandatesMandate.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Mandate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Mandate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of PaymentIntents.</p>
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param customer Only return PaymentIntents for the customer specified by this customer ID.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getPaymentIntents (created?: GetAccountsCreatedParameter, customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentFlowsPaymentIntentList;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentFlowsPaymentIntentList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentFlowsPaymentIntentList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a PaymentIntent that has previously been created. </p>  <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>  <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href=\"#payment_intent_object\">payment intent</a> object reference for more details.</p>
     * @param intent 
     * @param clientSecret The client secret of the PaymentIntent. Required if a publishable key is used to retrieve the source.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getPaymentIntentsIntent (intent: string, clientSecret?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling getPaymentIntentsIntent.');
        }

        if (clientSecret !== undefined) {
            localVarQueryParameters['client_secret'] = ObjectSerializer.serialize(clientSecret, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Search for PaymentIntents you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
     * @param query The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for payment intents](https://stripe.com/docs/search#query-fields-for-payment-intents).
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param page A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     */
    public async getPaymentIntentsSearch (query: string, expand?: Array<string>, limit?: number, page?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResult3;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getPaymentIntentsSearch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResult3;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResult3");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your payment links.</p>
     * @param active Only return payment links that are active or inactive (e.g., pass &#x60;false&#x60; to list all inactive payment links).
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getPaymentLinks (active?: boolean, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentLinksResourcePaymentLinkList;  }> {
        const localVarPath = this.basePath + '/v1/payment_links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentLinksResourcePaymentLinkList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentLinksResourcePaymentLinkList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieve a payment link.</p>
     * @param paymentLink 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getPaymentLinksPaymentLink (paymentLink: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentLink;  }> {
        const localVarPath = this.basePath + '/v1/payment_links/{payment_link}'
            .replace('{' + 'payment_link' + '}', encodeURIComponent(String(paymentLink)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'paymentLink' is not null or undefined
        if (paymentLink === null || paymentLink === undefined) {
            throw new Error('Required parameter paymentLink was null or undefined when calling getPaymentLinksPaymentLink.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving a payment link, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
     * @param paymentLink 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getPaymentLinksPaymentLinkLineItems (paymentLink: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentLinksResourceListLineItems;  }> {
        const localVarPath = this.basePath + '/v1/payment_links/{payment_link}/line_items'
            .replace('{' + 'payment_link' + '}', encodeURIComponent(String(paymentLink)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'paymentLink' is not null or undefined
        if (paymentLink === null || paymentLink === undefined) {
            throw new Error('Required parameter paymentLink was null or undefined when calling getPaymentLinksPaymentLinkLineItems.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentLinksResourceListLineItems;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentLinksResourceListLineItems");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of PaymentMethods for Treasury flows. If you want to list the PaymentMethods attached to a Customer for payments, you should use the <a href=\"/docs/api/payment_methods/customer_list\">List a Customer’s PaymentMethods</a> API instead.</p>
     * @param customer The ID of the customer whose PaymentMethods will be retrieved.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type An optional filter on the list, based on the object &#x60;type&#x60; field. Without the filter, the list includes all current and future payment method types. If your integration expects only one type of payment method in the response, make sure to provide a type value in the request.
     */
    public async getPaymentMethods (customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, type?: 'acss_debit' | 'affirm' | 'afterpay_clearpay' | 'alipay' | 'au_becs_debit' | 'bacs_debit' | 'bancontact' | 'blik' | 'boleto' | 'card' | 'card_present' | 'customer_balance' | 'eps' | 'fpx' | 'giropay' | 'grabpay' | 'ideal' | 'klarna' | 'konbini' | 'link' | 'oxxo' | 'p24' | 'paynow' | 'pix' | 'promptpay' | 'sepa_debit' | 'sofort' | 'us_bank_account' | 'wechat_pay', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentFlowsPaymentMethodList;  }> {
        const localVarPath = this.basePath + '/v1/payment_methods';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'acss_debit' | 'affirm' | 'afterpay_clearpay' | 'alipay' | 'au_becs_debit' | 'bacs_debit' | 'bancontact' | 'blik' | 'boleto' | 'card' | 'card_present' | 'customer_balance' | 'eps' | 'fpx' | 'giropay' | 'grabpay' | 'ideal' | 'klarna' | 'konbini' | 'link' | 'oxxo' | 'p24' | 'paynow' | 'pix' | 'promptpay' | 'sepa_debit' | 'sofort' | 'us_bank_account' | 'wechat_pay'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentFlowsPaymentMethodList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentFlowsPaymentMethodList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a PaymentMethod object attached to the StripeAccount. To retrieve a payment method attached to a Customer, you should use <a href=\"/docs/api/payment_methods/customer\">Retrieve a Customer’s PaymentMethods</a></p>
     * @param paymentMethod 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getPaymentMethodsPaymentMethod (paymentMethod: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }> {
        const localVarPath = this.basePath + '/v1/payment_methods/{payment_method}'
            .replace('{' + 'payment_method' + '}', encodeURIComponent(String(paymentMethod)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'paymentMethod' is not null or undefined
        if (paymentMethod === null || paymentMethod === undefined) {
            throw new Error('Required parameter paymentMethod was null or undefined when calling getPaymentMethodsPaymentMethod.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentMethod");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of existing payouts sent to third-party bank accounts or that Stripe has sent you. The payouts are returned in sorted order, with the most recently created payouts appearing first.</p>
     * @param arrivalDate 
     * @param created 
     * @param destination The ID of an external account - only return payouts sent to this external account.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return payouts that have the given status: &#x60;pending&#x60;, &#x60;paid&#x60;, &#x60;failed&#x60;, or &#x60;canceled&#x60;.
     */
    public async getPayouts (arrivalDate?: GetAccountsCreatedParameter, created?: GetAccountsCreatedParameter, destination?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PayoutList;  }> {
        const localVarPath = this.basePath + '/v1/payouts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (arrivalDate !== undefined) {
            localVarQueryParameters['arrival_date'] = ObjectSerializer.serialize(arrivalDate, "GetAccountsCreatedParameter");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (destination !== undefined) {
            localVarQueryParameters['destination'] = ObjectSerializer.serialize(destination, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PayoutList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PayoutList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing payout. Supply the unique payout ID from either a payout creation request or the payout list, and Stripe will return the corresponding payout information.</p>
     * @param payout 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getPayoutsPayout (payout: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Payout;  }> {
        const localVarPath = this.basePath + '/v1/payouts/{payout}'
            .replace('{' + 'payout' + '}', encodeURIComponent(String(payout)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'payout' is not null or undefined
        if (payout === null || payout === undefined) {
            throw new Error('Required parameter payout was null or undefined when calling getPayoutsPayout.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Payout;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Payout");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your plans.</p>
     * @param active Only return plans that are active or inactive (e.g., pass &#x60;false&#x60; to list all inactive plans).
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param product Only return plans for the given product.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getPlans (active?: boolean, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, product?: string, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PlanList;  }> {
        const localVarPath = this.basePath + '/v1/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (product !== undefined) {
            localVarQueryParameters['product'] = ObjectSerializer.serialize(product, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PlanList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PlanList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the plan with the given ID.</p>
     * @param plan 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getPlansPlan (plan: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Plan;  }> {
        const localVarPath = this.basePath + '/v1/plans/{plan}'
            .replace('{' + 'plan' + '}', encodeURIComponent(String(plan)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'plan' is not null or undefined
        if (plan === null || plan === undefined) {
            throw new Error('Required parameter plan was null or undefined when calling getPlansPlan.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Plan;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Plan");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your prices.</p>
     * @param active Only return prices that are active or inactive (e.g., pass &#x60;false&#x60; to list all inactive prices).
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param currency Only return prices for the given currency.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param lookupKeys Only return the price with these lookup_keys, if any exist.
     * @param product Only return prices for the given product.
     * @param recurring Only return prices with these recurring fields.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type Only return prices of type &#x60;recurring&#x60; or &#x60;one_time&#x60;.
     */
    public async getPrices (active?: boolean, created?: GetAccountsCreatedParameter, currency?: string, endingBefore?: string, expand?: Array<string>, limit?: number, lookupKeys?: Array<string>, product?: string, recurring?: AllPricesRecurringParams, startingAfter?: string, type?: 'one_time' | 'recurring', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PriceList;  }> {
        const localVarPath = this.basePath + '/v1/prices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (lookupKeys !== undefined) {
            localVarQueryParameters['lookup_keys'] = ObjectSerializer.serialize(lookupKeys, "Array<string>");
        }

        if (product !== undefined) {
            localVarQueryParameters['product'] = ObjectSerializer.serialize(product, "string");
        }

        if (recurring !== undefined) {
            localVarQueryParameters['recurring'] = ObjectSerializer.serialize(recurring, "AllPricesRecurringParams");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'one_time' | 'recurring'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PriceList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PriceList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the price with the given ID.</p>
     * @param price 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getPricesPrice (price: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Price;  }> {
        const localVarPath = this.basePath + '/v1/prices/{price}'
            .replace('{' + 'price' + '}', encodeURIComponent(String(price)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling getPricesPrice.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Price;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Price");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Search for prices you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
     * @param query The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for prices](https://stripe.com/docs/search#query-fields-for-prices).
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param page A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     */
    public async getPricesSearch (query: string, expand?: Array<string>, limit?: number, page?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResult4;  }> {
        const localVarPath = this.basePath + '/v1/prices/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getPricesSearch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResult4;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResult4");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your products. The products are returned sorted by creation date, with the most recently created products appearing first.</p>
     * @param active Only return products that are active or inactive (e.g., pass &#x60;false&#x60; to list all inactive products).
     * @param created Only return products that were created during the given date interval.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param ids Only return products with the given IDs. Cannot be used with [starting_after](https://stripe.com/docs/api#list_products-starting_after) or [ending_before](https://stripe.com/docs/api#list_products-ending_before).
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param shippable Only return products that can be shipped (i.e., physical, not digital products).
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param type Only return products of this type.
     * @param url Only return products with the given url.
     */
    public async getProducts (active?: boolean, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, ids?: Array<string>, limit?: number, shippable?: boolean, startingAfter?: string, type?: 'good' | 'service', url?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ProductList;  }> {
        const localVarPath = this.basePath + '/v1/products';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (ids !== undefined) {
            localVarQueryParameters['ids'] = ObjectSerializer.serialize(ids, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (shippable !== undefined) {
            localVarQueryParameters['shippable'] = ObjectSerializer.serialize(shippable, "boolean");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "'good' | 'service'");
        }

        if (url !== undefined) {
            localVarQueryParameters['url'] = ObjectSerializer.serialize(url, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ProductList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ProductList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing product. Supply the unique product ID from either a product creation request or the product list, and Stripe will return the corresponding product information.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getProductsId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Product;  }> {
        const localVarPath = this.basePath + '/v1/products/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getProductsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Product;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Product");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Search for products you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
     * @param query The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for products](https://stripe.com/docs/search#query-fields-for-products).
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param page A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     */
    public async getProductsSearch (query: string, expand?: Array<string>, limit?: number, page?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResult5;  }> {
        const localVarPath = this.basePath + '/v1/products/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getProductsSearch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResult5;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResult5");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your promotion codes.</p>
     * @param active Filter promotion codes by whether they are active.
     * @param code Only return promotion codes that have this case-insensitive code.
     * @param coupon Only return promotion codes for this coupon.
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param customer Only return promotion codes that are restricted to this customer.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getPromotionCodes (active?: boolean, code?: string, coupon?: string, created?: GetAccountsCreatedParameter, customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PromotionCodesResourcePromotionCodeList;  }> {
        const localVarPath = this.basePath + '/v1/promotion_codes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (coupon !== undefined) {
            localVarQueryParameters['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PromotionCodesResourcePromotionCodeList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PromotionCodesResourcePromotionCodeList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the promotion code with the given ID. In order to retrieve a promotion code by the customer-facing <code>code</code> use <a href=\"/docs/api/promotion_codes/list\">list</a> with the desired <code>code</code>.</p>
     * @param promotionCode 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getPromotionCodesPromotionCode (promotionCode: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PromotionCode;  }> {
        const localVarPath = this.basePath + '/v1/promotion_codes/{promotion_code}'
            .replace('{' + 'promotion_code' + '}', encodeURIComponent(String(promotionCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'promotionCode' is not null or undefined
        if (promotionCode === null || promotionCode === undefined) {
            throw new Error('Required parameter promotionCode was null or undefined when calling getPromotionCodesPromotionCode.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PromotionCode;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PromotionCode");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your quotes.</p>
     * @param customer The ID of the customer whose quotes will be retrieved.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status The status of the quote.
     * @param testClock Provides a list of quotes that are associated with the specified test clock. The response will not include quotes with test clocks if this and the customer parameter is not set.
     */
    public async getQuotes (customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'accepted' | 'canceled' | 'draft' | 'open', testClock?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: QuotesResourceQuoteList;  }> {
        const localVarPath = this.basePath + '/v1/quotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'accepted' | 'canceled' | 'draft' | 'open'");
        }

        if (testClock !== undefined) {
            localVarQueryParameters['test_clock'] = ObjectSerializer.serialize(testClock, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: QuotesResourceQuoteList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "QuotesResourceQuoteList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the quote with the given ID.</p>
     * @param quote 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getQuotesQuote (quote: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Quote;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling getQuotesQuote.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Quote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Quote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving a quote, there is an includable <a href=\"https://stripe.com/docs/api/quotes/object#quote_object-computed-upfront-line_items\"><strong>computed.upfront.line_items</strong></a> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of upfront line items.</p>
     * @param quote 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getQuotesQuoteComputedUpfrontLineItems (quote: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: QuotesResourceListLineItems;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}/computed_upfront_line_items'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling getQuotesQuoteComputedUpfrontLineItems.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: QuotesResourceListLineItems;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "QuotesResourceListLineItems");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When retrieving a quote, there is an includable <strong>line_items</strong> property containing the first handful of those items. There is also a URL where you can retrieve the full (paginated) list of line items.</p>
     * @param quote 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getQuotesQuoteLineItems (quote: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: QuotesResourceListLineItems;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}/line_items'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling getQuotesQuoteLineItems.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: QuotesResourceListLineItems;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "QuotesResourceListLineItems");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Download the PDF for a finalized quote</p>
     * @param quote 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getQuotesQuotePdf (quote: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Buffer;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}/pdf'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/pdf', 'application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling getQuotesQuotePdf.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            encoding: null,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Buffer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Buffer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of early fraud warnings.</p>
     * @param charge Only return early fraud warnings for the charge specified by this charge ID.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param paymentIntent Only return early fraud warnings for charges that were created by the PaymentIntent specified by this PaymentIntent ID.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getRadarEarlyFraudWarnings (charge?: string, endingBefore?: string, expand?: Array<string>, limit?: number, paymentIntent?: string, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarEarlyFraudWarningList;  }> {
        const localVarPath = this.basePath + '/v1/radar/early_fraud_warnings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (charge !== undefined) {
            localVarQueryParameters['charge'] = ObjectSerializer.serialize(charge, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (paymentIntent !== undefined) {
            localVarQueryParameters['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarEarlyFraudWarningList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarEarlyFraudWarningList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an early fraud warning that has previously been created. </p>  <p>Please refer to the <a href=\"#early_fraud_warning_object\">early fraud warning</a> object reference for more details.</p>
     * @param earlyFraudWarning 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getRadarEarlyFraudWarningsEarlyFraudWarning (earlyFraudWarning: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarEarlyFraudWarning;  }> {
        const localVarPath = this.basePath + '/v1/radar/early_fraud_warnings/{early_fraud_warning}'
            .replace('{' + 'early_fraud_warning' + '}', encodeURIComponent(String(earlyFraudWarning)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'earlyFraudWarning' is not null or undefined
        if (earlyFraudWarning === null || earlyFraudWarning === undefined) {
            throw new Error('Required parameter earlyFraudWarning was null or undefined when calling getRadarEarlyFraudWarningsEarlyFraudWarning.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarEarlyFraudWarning;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarEarlyFraudWarning");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of <code>ValueListItem</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param valueList Identifier for the parent value list this item belongs to.
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param value Return items belonging to the parent list whose value matches the specified value (using an \&quot;is like\&quot; match).
     */
    public async getRadarValueListItems (valueList: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, value?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarListListItemList;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_list_items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'valueList' is not null or undefined
        if (valueList === null || valueList === undefined) {
            throw new Error('Required parameter valueList was null or undefined when calling getRadarValueListItems.');
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (value !== undefined) {
            localVarQueryParameters['value'] = ObjectSerializer.serialize(value, "string");
        }

        if (valueList !== undefined) {
            localVarQueryParameters['value_list'] = ObjectSerializer.serialize(valueList, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarListListItemList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarListListItemList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a <code>ValueListItem</code> object.</p>
     * @param item 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getRadarValueListItemsItem (item: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarValueListItem;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_list_items/{item}'
            .replace('{' + 'item' + '}', encodeURIComponent(String(item)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling getRadarValueListItemsItem.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarValueListItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarValueListItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of <code>ValueList</code> objects. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param alias The alias used to reference the value list when writing rules.
     * @param contains A value contained within a value list - returns all value lists containing this value.
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getRadarValueLists (alias?: string, contains?: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarListListList;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (alias !== undefined) {
            localVarQueryParameters['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (contains !== undefined) {
            localVarQueryParameters['contains'] = ObjectSerializer.serialize(contains, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarListListList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarListListList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a <code>ValueList</code> object.</p>
     * @param valueList 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getRadarValueListsValueList (valueList: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarValueList;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_lists/{value_list}'
            .replace('{' + 'value_list' + '}', encodeURIComponent(String(valueList)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'valueList' is not null or undefined
        if (valueList === null || valueList === undefined) {
            throw new Error('Required parameter valueList was null or undefined when calling getRadarValueListsValueList.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarValueList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarValueList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of all refunds you’ve previously created. The refunds are returned in sorted order, with the most recent refunds appearing first. For convenience, the 10 most recent refunds are always available by default on the charge object.</p>
     * @param charge Only return refunds for the charge specified by this charge ID.
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param paymentIntent Only return refunds for the PaymentIntent specified by this ID.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getRefunds (charge?: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, paymentIntent?: string, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: APIMethodRefundList;  }> {
        const localVarPath = this.basePath + '/v1/refunds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (charge !== undefined) {
            localVarQueryParameters['charge'] = ObjectSerializer.serialize(charge, "string");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (paymentIntent !== undefined) {
            localVarQueryParameters['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: APIMethodRefundList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "APIMethodRefundList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing refund.</p>
     * @param refund 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getRefundsRefund (refund: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Refund;  }> {
        const localVarPath = this.basePath + '/v1/refunds/{refund}'
            .replace('{' + 'refund' + '}', encodeURIComponent(String(refund)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'refund' is not null or undefined
        if (refund === null || refund === undefined) {
            throw new Error('Required parameter refund was null or undefined when calling getRefundsRefund.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Refund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Refund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of Report Runs, with the most recent appearing first.</p>
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getReportingReportRuns (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FinancialReportingFinanceReportRunList;  }> {
        const localVarPath = this.basePath + '/v1/reporting/report_runs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FinancialReportingFinanceReportRunList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FinancialReportingFinanceReportRunList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing Report Run.</p>
     * @param reportRun 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getReportingReportRunsReportRun (reportRun: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ReportingReportRun;  }> {
        const localVarPath = this.basePath + '/v1/reporting/report_runs/{report_run}'
            .replace('{' + 'report_run' + '}', encodeURIComponent(String(reportRun)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reportRun' is not null or undefined
        if (reportRun === null || reportRun === undefined) {
            throw new Error('Required parameter reportRun was null or undefined when calling getReportingReportRunsReportRun.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ReportingReportRun;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ReportingReportRun");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a full list of Report Types.</p>
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getReportingReportTypes (expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FinancialReportingFinanceReportTypeList;  }> {
        const localVarPath = this.basePath + '/v1/reporting/report_types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FinancialReportingFinanceReportTypeList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FinancialReportingFinanceReportTypeList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a Report Type. (Certain report types require a <a href=\"https://stripe.com/docs/keys#test-live-modes\">live-mode API key</a>.)</p>
     * @param reportType 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getReportingReportTypesReportType (reportType: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ReportingReportType;  }> {
        const localVarPath = this.basePath + '/v1/reporting/report_types/{report_type}'
            .replace('{' + 'report_type' + '}', encodeURIComponent(String(reportType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reportType' is not null or undefined
        if (reportType === null || reportType === undefined) {
            throw new Error('Required parameter reportType was null or undefined when calling getReportingReportTypesReportType.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ReportingReportType;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ReportingReportType");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of <code>Review</code> objects that have <code>open</code> set to <code>true</code>. The objects are sorted in descending order by creation date, with the most recently created object appearing first.</p>
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getReviews (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarReviewList;  }> {
        const localVarPath = this.basePath + '/v1/reviews';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarReviewList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarReviewList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a <code>Review</code> object.</p>
     * @param review 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getReviewsReview (review: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Review;  }> {
        const localVarPath = this.basePath + '/v1/reviews/{review}'
            .replace('{' + 'review' + '}', encodeURIComponent(String(review)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'review' is not null or undefined
        if (review === null || review === undefined) {
            throw new Error('Required parameter review was null or undefined when calling getReviewsReview.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Review;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Review");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of SetupAttempts associated with a provided SetupIntent.</p>
     * @param setupIntent Only return SetupAttempts created by the SetupIntent specified by this ID.
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getSetupAttempts (setupIntent: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentFlowsSetupIntentSetupAttemptList;  }> {
        const localVarPath = this.basePath + '/v1/setup_attempts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'setupIntent' is not null or undefined
        if (setupIntent === null || setupIntent === undefined) {
            throw new Error('Required parameter setupIntent was null or undefined when calling getSetupAttempts.');
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (setupIntent !== undefined) {
            localVarQueryParameters['setup_intent'] = ObjectSerializer.serialize(setupIntent, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentFlowsSetupIntentSetupAttemptList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentFlowsSetupIntentSetupAttemptList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of SetupIntents.</p>
     * @param attachToSelf If present, the SetupIntent\&#39;s payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param customer Only return SetupIntents for the customer specified by this customer ID.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param paymentMethod Only return SetupIntents associated with the specified payment method.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getSetupIntents (attachToSelf?: boolean, created?: GetAccountsCreatedParameter, customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, paymentMethod?: string, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentFlowsSetupIntentList;  }> {
        const localVarPath = this.basePath + '/v1/setup_intents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (attachToSelf !== undefined) {
            localVarQueryParameters['attach_to_self'] = ObjectSerializer.serialize(attachToSelf, "boolean");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (paymentMethod !== undefined) {
            localVarQueryParameters['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentFlowsSetupIntentList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentFlowsSetupIntentList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a SetupIntent that has previously been created. </p>  <p>Client-side retrieval using a publishable key is allowed when the <code>client_secret</code> is provided in the query string. </p>  <p>When retrieved with a publishable key, only a subset of properties will be returned. Please refer to the <a href=\"#setup_intent_object\">SetupIntent</a> object reference for more details.</p>
     * @param intent 
     * @param clientSecret The client secret of the SetupIntent. Required if a publishable key is used to retrieve the SetupIntent.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getSetupIntentsIntent (intent: string, clientSecret?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SetupIntent;  }> {
        const localVarPath = this.basePath + '/v1/setup_intents/{intent}'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling getSetupIntentsIntent.');
        }

        if (clientSecret !== undefined) {
            localVarQueryParameters['client_secret'] = ObjectSerializer.serialize(clientSecret, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SetupIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SetupIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your shipping rates.</p>
     * @param active Only return shipping rates that are active or inactive.
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param currency Only return shipping rates for the given currency.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getShippingRates (active?: boolean, created?: GetAccountsCreatedParameter, currency?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ShippingResourcesShippingRateList;  }> {
        const localVarPath = this.basePath + '/v1/shipping_rates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (currency !== undefined) {
            localVarQueryParameters['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ShippingResourcesShippingRateList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ShippingResourcesShippingRateList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns the shipping rate object with the given ID.</p>
     * @param shippingRateToken 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getShippingRatesShippingRateToken (shippingRateToken: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ShippingRate;  }> {
        const localVarPath = this.basePath + '/v1/shipping_rates/{shipping_rate_token}'
            .replace('{' + 'shipping_rate_token' + '}', encodeURIComponent(String(shippingRateToken)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'shippingRateToken' is not null or undefined
        if (shippingRateToken === null || shippingRateToken === undefined) {
            throw new Error('Required parameter shippingRateToken was null or undefined when calling getShippingRatesShippingRateToken.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ShippingRate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ShippingRate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of scheduled query runs.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getSigmaScheduledQueryRuns (endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SigmaScheduledQueryRunList;  }> {
        const localVarPath = this.basePath + '/v1/sigma/scheduled_query_runs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SigmaScheduledQueryRunList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SigmaScheduledQueryRunList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an scheduled query run.</p>
     * @param scheduledQueryRun 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getSigmaScheduledQueryRunsScheduledQueryRun (scheduledQueryRun: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ScheduledQueryRun;  }> {
        const localVarPath = this.basePath + '/v1/sigma/scheduled_query_runs/{scheduled_query_run}'
            .replace('{' + 'scheduled_query_run' + '}', encodeURIComponent(String(scheduledQueryRun)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'scheduledQueryRun' is not null or undefined
        if (scheduledQueryRun === null || scheduledQueryRun === undefined) {
            throw new Error('Required parameter scheduledQueryRun was null or undefined when calling getSigmaScheduledQueryRunsScheduledQueryRun.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ScheduledQueryRun;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ScheduledQueryRun");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves an existing source object. Supply the unique source ID from a source creation request and Stripe will return the corresponding up-to-date source object information.</p>
     * @param source 
     * @param clientSecret The client secret of the source. Required if a publishable key is used to retrieve the source.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getSourcesSource (source: string, clientSecret?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Source;  }> {
        const localVarPath = this.basePath + '/v1/sources/{source}'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getSourcesSource.');
        }

        if (clientSecret !== undefined) {
            localVarQueryParameters['client_secret'] = ObjectSerializer.serialize(clientSecret, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Source;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Source");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>List source transactions for a given source.</p>
     * @param source 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getSourcesSourceSourceTransactions (source: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ApmsSourcesSourceTransactionList;  }> {
        const localVarPath = this.basePath + '/v1/sources/{source}/source_transactions'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling getSourcesSourceSourceTransactions.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ApmsSourcesSourceTransactionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ApmsSourcesSourceTransactionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your subscription items for a given subscription.</p>
     * @param subscription The ID of the subscription whose items will be retrieved.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getSubscriptionItems (subscription: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionsItemsSubscriptionItemList;  }> {
        const localVarPath = this.basePath + '/v1/subscription_items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscription' is not null or undefined
        if (subscription === null || subscription === undefined) {
            throw new Error('Required parameter subscription was null or undefined when calling getSubscriptionItems.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (subscription !== undefined) {
            localVarQueryParameters['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionsItemsSubscriptionItemList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionsItemsSubscriptionItemList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the subscription item with the given ID.</p>
     * @param item 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getSubscriptionItemsItem (item: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionItem;  }> {
        const localVarPath = this.basePath + '/v1/subscription_items/{item}'
            .replace('{' + 'item' + '}', encodeURIComponent(String(item)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling getSubscriptionItemsItem.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>For the specified subscription item, returns a list of summary objects. Each object in the list provides usage information that’s been summarized from multiple usage records and over a subscription billing period (e.g., 15 usage records in the month of September).</p>  <p>The list is sorted in reverse-chronological order (newest first). The first list item represents the most current usage period that hasn’t ended yet. Since new usage records can still be added, the returned summary information for the subscription item’s ID should be seen as unstable until the subscription billing period ends.</p>
     * @param subscriptionItem 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getSubscriptionItemsSubscriptionItemUsageRecordSummaries (subscriptionItem: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UsageEventsResourceUsageRecordSummaryList;  }> {
        const localVarPath = this.basePath + '/v1/subscription_items/{subscription_item}/usage_record_summaries'
            .replace('{' + 'subscription_item' + '}', encodeURIComponent(String(subscriptionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionItem' is not null or undefined
        if (subscriptionItem === null || subscriptionItem === undefined) {
            throw new Error('Required parameter subscriptionItem was null or undefined when calling getSubscriptionItemsSubscriptionItemUsageRecordSummaries.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UsageEventsResourceUsageRecordSummaryList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UsageEventsResourceUsageRecordSummaryList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the list of your subscription schedules.</p>
     * @param canceledAt Only return subscription schedules that were created canceled the given date interval.
     * @param completedAt Only return subscription schedules that completed during the given date interval.
     * @param created Only return subscription schedules that were created during the given date interval.
     * @param customer Only return subscription schedules for the given customer.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param releasedAt Only return subscription schedules that were released during the given date interval.
     * @param scheduled Only return subscription schedules that have not started yet.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getSubscriptionSchedules (canceledAt?: GetAccountsCreatedParameter, completedAt?: GetAccountsCreatedParameter, created?: GetAccountsCreatedParameter, customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, releasedAt?: GetAccountsCreatedParameter, scheduled?: boolean, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionSchedulesResourceScheduleList;  }> {
        const localVarPath = this.basePath + '/v1/subscription_schedules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (canceledAt !== undefined) {
            localVarQueryParameters['canceled_at'] = ObjectSerializer.serialize(canceledAt, "GetAccountsCreatedParameter");
        }

        if (completedAt !== undefined) {
            localVarQueryParameters['completed_at'] = ObjectSerializer.serialize(completedAt, "GetAccountsCreatedParameter");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (releasedAt !== undefined) {
            localVarQueryParameters['released_at'] = ObjectSerializer.serialize(releasedAt, "GetAccountsCreatedParameter");
        }

        if (scheduled !== undefined) {
            localVarQueryParameters['scheduled'] = ObjectSerializer.serialize(scheduled, "boolean");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionSchedulesResourceScheduleList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionSchedulesResourceScheduleList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing subscription schedule. You only need to supply the unique subscription schedule identifier that was returned upon subscription schedule creation.</p>
     * @param schedule 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getSubscriptionSchedulesSchedule (schedule: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }> {
        const localVarPath = this.basePath + '/v1/subscription_schedules/{schedule}'
            .replace('{' + 'schedule' + '}', encodeURIComponent(String(schedule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'schedule' is not null or undefined
        if (schedule === null || schedule === undefined) {
            throw new Error('Required parameter schedule was null or undefined when calling getSubscriptionSchedulesSchedule.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionSchedule");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>By default, returns a list of subscriptions that have not been canceled. In order to list canceled subscriptions, specify <code>status=canceled</code>.</p>
     * @param collectionMethod The collection method of the subscriptions to retrieve. Either &#x60;charge_automatically&#x60; or &#x60;send_invoice&#x60;.
     * @param created 
     * @param currentPeriodEnd 
     * @param currentPeriodStart 
     * @param customer The ID of the customer whose subscriptions will be retrieved.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param plan The ID of the plan whose subscriptions will be retrieved.
     * @param price Filter for subscriptions that contain this recurring price ID.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status The status of the subscriptions to retrieve. Passing in a value of &#x60;canceled&#x60; will return all canceled subscriptions, including those belonging to deleted customers. Pass &#x60;ended&#x60; to find subscriptions that are canceled and subscriptions that are expired due to [incomplete payment](https://stripe.com/docs/billing/subscriptions/overview#subscription-statuses). Passing in a value of &#x60;all&#x60; will return subscriptions of all statuses. If no value is supplied, all subscriptions that have not been canceled are returned.
     * @param testClock Filter for subscriptions that are associated with the specified test clock. The response will not include subscriptions with test clocks if this and the customer parameter is not set.
     */
    public async getSubscriptions (collectionMethod?: 'charge_automatically' | 'send_invoice', created?: GetAccountsCreatedParameter, currentPeriodEnd?: GetAccountsCreatedParameter, currentPeriodStart?: GetAccountsCreatedParameter, customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, plan?: string, price?: string, startingAfter?: string, status?: 'active' | 'all' | 'canceled' | 'ended' | 'incomplete' | 'incomplete_expired' | 'past_due' | 'paused' | 'trialing' | 'unpaid', testClock?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionsSubscriptionList;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (collectionMethod !== undefined) {
            localVarQueryParameters['collection_method'] = ObjectSerializer.serialize(collectionMethod, "'charge_automatically' | 'send_invoice'");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (currentPeriodEnd !== undefined) {
            localVarQueryParameters['current_period_end'] = ObjectSerializer.serialize(currentPeriodEnd, "GetAccountsCreatedParameter");
        }

        if (currentPeriodStart !== undefined) {
            localVarQueryParameters['current_period_start'] = ObjectSerializer.serialize(currentPeriodStart, "GetAccountsCreatedParameter");
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (plan !== undefined) {
            localVarQueryParameters['plan'] = ObjectSerializer.serialize(plan, "string");
        }

        if (price !== undefined) {
            localVarQueryParameters['price'] = ObjectSerializer.serialize(price, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'active' | 'all' | 'canceled' | 'ended' | 'incomplete' | 'incomplete_expired' | 'past_due' | 'paused' | 'trialing' | 'unpaid'");
        }

        if (testClock !== undefined) {
            localVarQueryParameters['test_clock'] = ObjectSerializer.serialize(testClock, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionsSubscriptionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionsSubscriptionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Search for subscriptions you’ve previously created using Stripe’s <a href=\"/docs/search#search-query-language\">Search Query Language</a>. Don’t use search in read-after-write flows where strict consistency is necessary. Under normal operating conditions, data is searchable in less than a minute. Occasionally, propagation of new or updated data can be up to an hour behind during outages. Search functionality is not available to merchants in India.</p>
     * @param query The search query string. See [search query language](https://stripe.com/docs/search#search-query-language) and the list of supported [query fields for subscriptions](https://stripe.com/docs/search#query-fields-for-subscriptions).
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param page A cursor for pagination across multiple pages of results. Don\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.
     */
    public async getSubscriptionsSearch (query: string, expand?: Array<string>, limit?: number, page?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SearchResult6;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'query' is not null or undefined
        if (query === null || query === undefined) {
            throw new Error('Required parameter query was null or undefined when calling getSubscriptionsSearch.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "string");
        }

        if (query !== undefined) {
            localVarQueryParameters['query'] = ObjectSerializer.serialize(query, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SearchResult6;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SearchResult6");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the subscription with the given ID.</p>
     * @param subscriptionExposedId 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getSubscriptionsSubscriptionExposedId (subscriptionExposedId: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions/{subscription_exposed_id}'
            .replace('{' + 'subscription_exposed_id' + '}', encodeURIComponent(String(subscriptionExposedId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionExposedId' is not null or undefined
        if (subscriptionExposedId === null || subscriptionExposedId === undefined) {
            throw new Error('Required parameter subscriptionExposedId was null or undefined when calling getSubscriptionsSubscriptionExposedId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Subscription");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A list of <a href=\"https://stripe.com/docs/tax/tax-categories\">all tax codes available</a> to add to Products in order to allow specific tax calculations.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getTaxCodes (endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxProductResourceTaxCodeList;  }> {
        const localVarPath = this.basePath + '/v1/tax_codes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxProductResourceTaxCodeList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxProductResourceTaxCodeList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing tax code. Supply the unique tax code ID and Stripe will return the corresponding tax code information.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTaxCodesId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxCode;  }> {
        const localVarPath = this.basePath + '/v1/tax_codes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTaxCodesId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxCode;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxCode");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your tax rates. Tax rates are returned sorted by creation date, with the most recently created tax rates appearing first.</p>
     * @param active Optional flag to filter by tax rates that are either active or inactive (archived).
     * @param created Optional range for filtering created date.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param inclusive Optional flag to filter by tax rates that are inclusive (or those that are not inclusive).
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getTaxRates (active?: boolean, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, inclusive?: boolean, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxRatesList;  }> {
        const localVarPath = this.basePath + '/v1/tax_rates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (active !== undefined) {
            localVarQueryParameters['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (inclusive !== undefined) {
            localVarQueryParameters['inclusive'] = ObjectSerializer.serialize(inclusive, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxRatesList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxRatesList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a tax rate with the given ID</p>
     * @param taxRate 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTaxRatesTaxRate (taxRate: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxRate;  }> {
        const localVarPath = this.basePath + '/v1/tax_rates/{tax_rate}'
            .replace('{' + 'tax_rate' + '}', encodeURIComponent(String(taxRate)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'taxRate' is not null or undefined
        if (taxRate === null || taxRate === undefined) {
            throw new Error('Required parameter taxRate was null or undefined when calling getTaxRatesTaxRate.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxRate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxRate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of <code>Configuration</code> objects.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param isAccountDefault if present, only return the account default or non-default configurations.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getTerminalConfigurations (endingBefore?: string, expand?: Array<string>, isAccountDefault?: boolean, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalConfigurationConfigurationList;  }> {
        const localVarPath = this.basePath + '/v1/terminal/configurations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (isAccountDefault !== undefined) {
            localVarQueryParameters['is_account_default'] = ObjectSerializer.serialize(isAccountDefault, "boolean");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalConfigurationConfigurationList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalConfigurationConfigurationList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a <code>Configuration</code> object.</p>
     * @param configuration 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTerminalConfigurationsConfiguration (configuration: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetTerminalConfigurationsConfiguration200Response;  }> {
        const localVarPath = this.basePath + '/v1/terminal/configurations/{configuration}'
            .replace('{' + 'configuration' + '}', encodeURIComponent(String(configuration)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'configuration' is not null or undefined
        if (configuration === null || configuration === undefined) {
            throw new Error('Required parameter configuration was null or undefined when calling getTerminalConfigurationsConfiguration.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetTerminalConfigurationsConfiguration200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetTerminalConfigurationsConfiguration200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of <code>Location</code> objects.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getTerminalLocations (endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalLocationLocationList;  }> {
        const localVarPath = this.basePath + '/v1/terminal/locations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalLocationLocationList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalLocationLocationList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a <code>Location</code> object.</p>
     * @param location 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTerminalLocationsLocation (location: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetTerminalLocationsLocation200Response;  }> {
        const localVarPath = this.basePath + '/v1/terminal/locations/{location}'
            .replace('{' + 'location' + '}', encodeURIComponent(String(location)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'location' is not null or undefined
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling getTerminalLocationsLocation.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetTerminalLocationsLocation200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetTerminalLocationsLocation200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of <code>Reader</code> objects.</p>
     * @param deviceType Filters readers by device type
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param location A location ID to filter the response list to only readers at the specific location
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status A status filter to filter readers to only offline or online readers
     */
    public async getTerminalReaders (deviceType?: 'bbpos_chipper2x' | 'bbpos_wisepad3' | 'bbpos_wisepos_e' | 'simulated_wisepos_e' | 'stripe_m2' | 'verifone_P400', endingBefore?: string, expand?: Array<string>, limit?: number, location?: string, startingAfter?: string, status?: 'offline' | 'online', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReaderRetrieveReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (deviceType !== undefined) {
            localVarQueryParameters['device_type'] = ObjectSerializer.serialize(deviceType, "'bbpos_chipper2x' | 'bbpos_wisepad3' | 'bbpos_wisepos_e' | 'simulated_wisepos_e' | 'stripe_m2' | 'verifone_P400'");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (location !== undefined) {
            localVarQueryParameters['location'] = ObjectSerializer.serialize(location, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'offline' | 'online'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReaderRetrieveReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReaderRetrieveReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a <code>Reader</code> object.</p>
     * @param reader 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTerminalReadersReader (reader: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetTerminalReadersReader200Response;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling getTerminalReadersReader.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetTerminalReadersReader200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetTerminalReadersReader200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your test clocks.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getTestHelpersTestClocks (endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BillingClocksResourceBillingClockList;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/test_clocks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BillingClocksResourceBillingClockList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BillingClocksResourceBillingClockList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a test clock.</p>
     * @param testClock 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTestHelpersTestClocksTestClock (testClock: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TestHelpersTestClock;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/test_clocks/{test_clock}'
            .replace('{' + 'test_clock' + '}', encodeURIComponent(String(testClock)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'testClock' is not null or undefined
        if (testClock === null || testClock === undefined) {
            throw new Error('Required parameter testClock was null or undefined when calling getTestHelpersTestClocksTestClock.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TestHelpersTestClock;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TestHelpersTestClock");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the token with the given ID.</p>
     * @param token 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTokensToken (token: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Token;  }> {
        const localVarPath = this.basePath + '/v1/tokens/{token}'
            .replace('{' + 'token' + '}', encodeURIComponent(String(token)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'token' is not null or undefined
        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling getTokensToken.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Token;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Token");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of top-ups.</p>
     * @param amount A positive integer representing how much to transfer.
     * @param created A filter on the list, based on the object &#x60;created&#x60; field. The value can be a string with an integer Unix timestamp, or it can be a dictionary with a number of different query options.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return top-ups that have the given status. One of &#x60;canceled&#x60;, &#x60;failed&#x60;, &#x60;pending&#x60; or &#x60;succeeded&#x60;.
     */
    public async getTopups (amount?: GetAccountsCreatedParameter, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'canceled' | 'failed' | 'pending' | 'succeeded', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TopupList;  }> {
        const localVarPath = this.basePath + '/v1/topups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (amount !== undefined) {
            localVarQueryParameters['amount'] = ObjectSerializer.serialize(amount, "GetAccountsCreatedParameter");
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'canceled' | 'failed' | 'pending' | 'succeeded'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TopupList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TopupList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a top-up that has previously been created. Supply the unique top-up ID that was returned from your previous request, and Stripe will return the corresponding top-up information.</p>
     * @param topup 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTopupsTopup (topup: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Topup;  }> {
        const localVarPath = this.basePath + '/v1/topups/{topup}'
            .replace('{' + 'topup' + '}', encodeURIComponent(String(topup)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'topup' is not null or undefined
        if (topup === null || topup === undefined) {
            throw new Error('Required parameter topup was null or undefined when calling getTopupsTopup.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Topup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Topup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of existing transfers sent to connected accounts. The transfers are returned in sorted order, with the most recently created transfers appearing first.</p>
     * @param created 
     * @param destination Only return transfers for the destination specified by this account ID.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param transferGroup Only return transfers with the specified transfer group.
     */
    public async getTransfers (created?: GetAccountsCreatedParameter, destination?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TransferList;  }> {
        const localVarPath = this.basePath + '/v1/transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (destination !== undefined) {
            localVarQueryParameters['destination'] = ObjectSerializer.serialize(destination, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (transferGroup !== undefined) {
            localVarQueryParameters['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TransferList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TransferList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can see a list of the reversals belonging to a specific transfer. Note that the 10 most recent reversals are always available by default on the transfer object. If you need more than those 10, you can use this API method and the <code>limit</code> and <code>starting_after</code> parameters to page through additional reversals.</p>
     * @param id 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getTransfersIdReversals (id: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TransferReversalList;  }> {
        const localVarPath = this.basePath + '/v1/transfers/{id}/reversals'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransfersIdReversals.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TransferReversalList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TransferReversalList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing transfer. Supply the unique transfer ID from either a transfer creation request or the transfer list, and Stripe will return the corresponding transfer information.</p>
     * @param transfer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTransfersTransfer (transfer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Transfer;  }> {
        const localVarPath = this.basePath + '/v1/transfers/{transfer}'
            .replace('{' + 'transfer' + '}', encodeURIComponent(String(transfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'transfer' is not null or undefined
        if (transfer === null || transfer === undefined) {
            throw new Error('Required parameter transfer was null or undefined when calling getTransfersTransfer.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Transfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Transfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>By default, you can see the 10 most recent reversals stored directly on the transfer object, but you can also retrieve details about a specific reversal stored on the transfer.</p>
     * @param id 
     * @param transfer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTransfersTransferReversalsId (id: string, transfer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TransferReversal;  }> {
        const localVarPath = this.basePath + '/v1/transfers/{transfer}/reversals/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'transfer' + '}', encodeURIComponent(String(transfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransfersTransferReversalsId.');
        }

        // verify required parameter 'transfer' is not null or undefined
        if (transfer === null || transfer === undefined) {
            throw new Error('Required parameter transfer was null or undefined when calling getTransfersTransferReversalsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TransferReversal;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TransferReversal");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of CreditReversals.</p>
     * @param financialAccount Returns objects associated with this FinancialAccount.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param receivedCredit Only return CreditReversals for the ReceivedCredit ID.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return CreditReversals for a given status.
     */
    public async getTreasuryCreditReversals (financialAccount: string, endingBefore?: string, expand?: Array<string>, limit?: number, receivedCredit?: string, startingAfter?: string, status?: 'canceled' | 'posted' | 'processing', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCreditsResourceCreditReversalList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/credit_reversals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryCreditReversals.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (receivedCredit !== undefined) {
            localVarQueryParameters['received_credit'] = ObjectSerializer.serialize(receivedCredit, "string");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'canceled' | 'posted' | 'processing'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCreditsResourceCreditReversalList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedCreditsResourceCreditReversalList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing CreditReversal by passing the unique CreditReversal ID from either the CreditReversal creation request or CreditReversal list</p>
     * @param creditReversal 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryCreditReversalsCreditReversal (creditReversal: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryCreditReversal;  }> {
        const localVarPath = this.basePath + '/v1/treasury/credit_reversals/{credit_reversal}'
            .replace('{' + 'credit_reversal' + '}', encodeURIComponent(String(creditReversal)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'creditReversal' is not null or undefined
        if (creditReversal === null || creditReversal === undefined) {
            throw new Error('Required parameter creditReversal was null or undefined when calling getTreasuryCreditReversalsCreditReversal.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryCreditReversal;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryCreditReversal");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of DebitReversals.</p>
     * @param financialAccount Returns objects associated with this FinancialAccount.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param receivedDebit Only return DebitReversals for the ReceivedDebit ID.
     * @param resolution Only return DebitReversals for a given resolution.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return DebitReversals for a given status.
     */
    public async getTreasuryDebitReversals (financialAccount: string, endingBefore?: string, expand?: Array<string>, limit?: number, receivedDebit?: string, resolution?: 'lost' | 'won', startingAfter?: string, status?: 'canceled' | 'completed' | 'processing', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebitsResourceDebitReversalList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/debit_reversals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryDebitReversals.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (receivedDebit !== undefined) {
            localVarQueryParameters['received_debit'] = ObjectSerializer.serialize(receivedDebit, "string");
        }

        if (resolution !== undefined) {
            localVarQueryParameters['resolution'] = ObjectSerializer.serialize(resolution, "'lost' | 'won'");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'canceled' | 'completed' | 'processing'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebitsResourceDebitReversalList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedDebitsResourceDebitReversalList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a DebitReversal object.</p>
     * @param debitReversal 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryDebitReversalsDebitReversal (debitReversal: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryDebitReversal;  }> {
        const localVarPath = this.basePath + '/v1/treasury/debit_reversals/{debit_reversal}'
            .replace('{' + 'debit_reversal' + '}', encodeURIComponent(String(debitReversal)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'debitReversal' is not null or undefined
        if (debitReversal === null || debitReversal === undefined) {
            throw new Error('Required parameter debitReversal was null or undefined when calling getTreasuryDebitReversalsDebitReversal.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryDebitReversal;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryDebitReversal");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of FinancialAccounts.</p>
     * @param created 
     * @param endingBefore An object ID cursor for use in pagination.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit ranging from 1 to 100 (defaults to 10).
     * @param startingAfter An object ID cursor for use in pagination.
     */
    public async getTreasuryFinancialAccounts (created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccountsResourceFinancialAccountList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/financial_accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccountsResourceFinancialAccountList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryFinancialAccountsResourceFinancialAccountList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of a FinancialAccount.</p>
     * @param financialAccount 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryFinancialAccountsFinancialAccount (financialAccount: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccount;  }> {
        const localVarPath = this.basePath + '/v1/treasury/financial_accounts/{financial_account}'
            .replace('{' + 'financial_account' + '}', encodeURIComponent(String(financialAccount)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryFinancialAccountsFinancialAccount.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryFinancialAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves Features information associated with the FinancialAccount.</p>
     * @param financialAccount 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryFinancialAccountsFinancialAccountFeatures (financialAccount: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccountFeatures;  }> {
        const localVarPath = this.basePath + '/v1/treasury/financial_accounts/{financial_account}/features'
            .replace('{' + 'financial_account' + '}', encodeURIComponent(String(financialAccount)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryFinancialAccountsFinancialAccountFeatures.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccountFeatures;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryFinancialAccountFeatures");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of InboundTransfers sent from the specified FinancialAccount.</p>
     * @param financialAccount Returns objects associated with this FinancialAccount.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return InboundTransfers that have the given status: &#x60;processing&#x60;, &#x60;succeeded&#x60;, &#x60;failed&#x60; or &#x60;canceled&#x60;.
     */
    public async getTreasuryInboundTransfers (financialAccount: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'canceled' | 'failed' | 'processing' | 'succeeded', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfersResourceInboundTransferList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/inbound_transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryInboundTransfers.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'canceled' | 'failed' | 'processing' | 'succeeded'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfersResourceInboundTransferList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryInboundTransfersResourceInboundTransferList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing InboundTransfer.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryInboundTransfersId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/treasury/inbound_transfers/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTreasuryInboundTransfersId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryInboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of OutboundPayments sent from the specified FinancialAccount.</p>
     * @param financialAccount Returns objects associated with this FinancialAccount.
     * @param customer Only return OutboundPayments sent to this customer.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return OutboundPayments that have the given status: &#x60;processing&#x60;, &#x60;failed&#x60;, &#x60;posted&#x60;, &#x60;returned&#x60;, or &#x60;canceled&#x60;.
     */
    public async getTreasuryOutboundPayments (financialAccount: string, customer?: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'canceled' | 'failed' | 'posted' | 'processing' | 'returned', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPaymentsResourceOutboundPaymentList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryOutboundPayments.');
        }

        if (customer !== undefined) {
            localVarQueryParameters['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'canceled' | 'failed' | 'posted' | 'processing' | 'returned'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPaymentsResourceOutboundPaymentList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundPaymentsResourceOutboundPaymentList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing OutboundPayment by passing the unique OutboundPayment ID from either the OutboundPayment creation request or OutboundPayment list.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryOutboundPaymentsId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_payments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTreasuryOutboundPaymentsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of OutboundTransfers sent from the specified FinancialAccount.</p>
     * @param financialAccount Returns objects associated with this FinancialAccount.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return OutboundTransfers that have the given status: &#x60;processing&#x60;, &#x60;canceled&#x60;, &#x60;failed&#x60;, &#x60;posted&#x60;, or &#x60;returned&#x60;.
     */
    public async getTreasuryOutboundTransfers (financialAccount: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'canceled' | 'failed' | 'posted' | 'processing' | 'returned', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfersResourceOutboundTransferList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryOutboundTransfers.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'canceled' | 'failed' | 'posted' | 'processing' | 'returned'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfersResourceOutboundTransferList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundTransfersResourceOutboundTransferList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing OutboundTransfer by passing the unique OutboundTransfer ID from either the OutboundTransfer creation request or OutboundTransfer list.</p>
     * @param outboundTransfer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryOutboundTransfersOutboundTransfer (outboundTransfer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_transfers/{outbound_transfer}'
            .replace('{' + 'outbound_transfer' + '}', encodeURIComponent(String(outboundTransfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'outboundTransfer' is not null or undefined
        if (outboundTransfer === null || outboundTransfer === undefined) {
            throw new Error('Required parameter outboundTransfer was null or undefined when calling getTreasuryOutboundTransfersOutboundTransfer.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of ReceivedCredits.</p>
     * @param financialAccount The FinancialAccount that received the funds.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param linkedFlows Only return ReceivedCredits described by the flow.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return ReceivedCredits that have the given status: &#x60;succeeded&#x60; or &#x60;failed&#x60;.
     */
    public async getTreasuryReceivedCredits (financialAccount: string, endingBefore?: string, expand?: Array<string>, limit?: number, linkedFlows?: LinkedFlowsParam, startingAfter?: string, status?: 'failed' | 'succeeded', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCreditsResourceReceivedCreditList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/received_credits';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryReceivedCredits.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (linkedFlows !== undefined) {
            localVarQueryParameters['linked_flows'] = ObjectSerializer.serialize(linkedFlows, "LinkedFlowsParam");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'failed' | 'succeeded'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCreditsResourceReceivedCreditList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedCreditsResourceReceivedCreditList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing ReceivedCredit by passing the unique ReceivedCredit ID from the ReceivedCredit list.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryReceivedCreditsId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCredit;  }> {
        const localVarPath = this.basePath + '/v1/treasury/received_credits/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTreasuryReceivedCreditsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCredit;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedCredit");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of ReceivedDebits.</p>
     * @param financialAccount The FinancialAccount that funds were pulled from.
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return ReceivedDebits that have the given status: &#x60;succeeded&#x60; or &#x60;failed&#x60;.
     */
    public async getTreasuryReceivedDebits (financialAccount: string, endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, status?: 'failed' | 'succeeded', options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebitsResourceReceivedDebitList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/received_debits';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryReceivedDebits.');
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'failed' | 'succeeded'");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebitsResourceReceivedDebitList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedDebitsResourceReceivedDebitList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing ReceivedDebit by passing the unique ReceivedDebit ID from the ReceivedDebit list</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryReceivedDebitsId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebit;  }> {
        const localVarPath = this.basePath + '/v1/treasury/received_debits/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTreasuryReceivedDebitsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebit;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedDebit");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a list of TransactionEntry objects.</p>
     * @param financialAccount Returns objects associated with this FinancialAccount.
     * @param created 
     * @param effectiveAt 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param orderBy The results are in reverse chronological order by &#x60;created&#x60; or &#x60;effective_at&#x60;. The default is &#x60;created&#x60;.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param transaction Only return TransactionEntries associated with this Transaction.
     */
    public async getTreasuryTransactionEntries (financialAccount: string, created?: GetAccountsCreatedParameter, effectiveAt?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, orderBy?: 'created' | 'effective_at', startingAfter?: string, transaction?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryTransactionsResourceTransactionEntryList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/transaction_entries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryTransactionEntries.');
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (effectiveAt !== undefined) {
            localVarQueryParameters['effective_at'] = ObjectSerializer.serialize(effectiveAt, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['order_by'] = ObjectSerializer.serialize(orderBy, "'created' | 'effective_at'");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (transaction !== undefined) {
            localVarQueryParameters['transaction'] = ObjectSerializer.serialize(transaction, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryTransactionsResourceTransactionEntryList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryTransactionsResourceTransactionEntryList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a TransactionEntry object.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryTransactionEntriesId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryTransactionEntry;  }> {
        const localVarPath = this.basePath + '/v1/treasury/transaction_entries/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTreasuryTransactionEntriesId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryTransactionEntry;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryTransactionEntry");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves a list of Transaction objects.</p>
     * @param financialAccount Returns objects associated with this FinancialAccount.
     * @param created 
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param orderBy The results are in reverse chronological order by &#x60;created&#x60; or &#x60;posted_at&#x60;. The default is &#x60;created&#x60;.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     * @param status Only return Transactions that have the given status: &#x60;open&#x60;, &#x60;posted&#x60;, or &#x60;void&#x60;.
     * @param statusTransitions A filter for the &#x60;status_transitions.posted_at&#x60; timestamp. When using this filter, &#x60;status&#x3D;posted&#x60; and &#x60;order_by&#x3D;posted_at&#x60; must also be specified.
     */
    public async getTreasuryTransactions (financialAccount: string, created?: GetAccountsCreatedParameter, endingBefore?: string, expand?: Array<string>, limit?: number, orderBy?: 'created' | 'posted_at', startingAfter?: string, status?: 'open' | 'posted' | 'void', statusTransitions?: StatusTransitionTimestampSpecs, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryTransactionsResourceTransactionList;  }> {
        const localVarPath = this.basePath + '/v1/treasury/transactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling getTreasuryTransactions.');
        }

        if (created !== undefined) {
            localVarQueryParameters['created'] = ObjectSerializer.serialize(created, "GetAccountsCreatedParameter");
        }

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarQueryParameters['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (orderBy !== undefined) {
            localVarQueryParameters['order_by'] = ObjectSerializer.serialize(orderBy, "'created' | 'posted_at'");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "'open' | 'posted' | 'void'");
        }

        if (statusTransitions !== undefined) {
            localVarQueryParameters['status_transitions'] = ObjectSerializer.serialize(statusTransitions, "StatusTransitionTimestampSpecs");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryTransactionsResourceTransactionList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryTransactionsResourceTransactionList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the details of an existing Transaction.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getTreasuryTransactionsId (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryTransaction;  }> {
        const localVarPath = this.basePath + '/v1/treasury/transactions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTreasuryTransactionsId.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Returns a list of your webhook endpoints.</p>
     * @param endingBefore A cursor for use in pagination. &#x60;ending_before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with &#x60;obj_bar&#x60;, your subsequent call can include &#x60;ending_before&#x3D;obj_bar&#x60; in order to fetch the previous page of the list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.
     * @param startingAfter A cursor for use in pagination. &#x60;starting_after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with &#x60;obj_foo&#x60;, your subsequent call can include &#x60;starting_after&#x3D;obj_foo&#x60; in order to fetch the next page of the list.
     */
    public async getWebhookEndpoints (endingBefore?: string, expand?: Array<string>, limit?: number, startingAfter?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: NotificationWebhookEndpointList;  }> {
        const localVarPath = this.basePath + '/v1/webhook_endpoints';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (endingBefore !== undefined) {
            localVarQueryParameters['ending_before'] = ObjectSerializer.serialize(endingBefore, "string");
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (startingAfter !== undefined) {
            localVarQueryParameters['starting_after'] = ObjectSerializer.serialize(startingAfter, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: NotificationWebhookEndpointList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "NotificationWebhookEndpointList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieves the webhook endpoint with the given ID.</p>
     * @param webhookEndpoint 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async getWebhookEndpointsWebhookEndpoint (webhookEndpoint: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WebhookEndpoint;  }> {
        const localVarPath = this.basePath + '/v1/webhook_endpoints/{webhook_endpoint}'
            .replace('{' + 'webhook_endpoint' + '}', encodeURIComponent(String(webhookEndpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'webhookEndpoint' is not null or undefined
        if (webhookEndpoint === null || webhookEndpoint === undefined) {
            throw new Error('Required parameter webhookEndpoint was null or undefined when calling getWebhookEndpointsWebhookEndpoint.');
        }

        if (expand !== undefined) {
            localVarQueryParameters['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: WebhookEndpoint;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "WebhookEndpoint");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an AccountLink object that includes a single-use Stripe URL that the platform can redirect their user to in order to take them through the Connect Onboarding flow.</p>
     * @param account The identifier of the account to create an account link for.
     * @param type The type of account link the user is requesting. Possible values are &#x60;account_onboarding&#x60; or &#x60;account_update&#x60;.
     * @param collect Which information the platform needs to collect from the user. One of &#x60;currently_due&#x60; or &#x60;eventually_due&#x60;. Default is &#x60;currently_due&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     * @param refreshUrl The URL the user will be redirected to if the account link is expired, has been previously-visited, or is otherwise invalid. The URL you specify should attempt to generate a new account link with the same parameters used to create the original account link, then redirect the user to the new account link\\\&#39;s URL so they can continue with Connect Onboarding. If a new account link cannot be generated or the redirect fails you should display a useful error to the user.
     * @param returnUrl The URL that the user will be redirected to upon leaving or completing the linked flow.
     */
    public async postAccountLinks (account: string, type: string, collect?: string, expand?: Array<string>, refreshUrl?: string, returnUrl?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AccountLink;  }> {
        const localVarPath = this.basePath + '/v1/account_links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountLinks.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling postAccountLinks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (account !== undefined) {
            localVarFormParams['account'] = ObjectSerializer.serialize(account, "string");
        }

        if (collect !== undefined) {
            localVarFormParams['collect'] = ObjectSerializer.serialize(collect, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (refreshUrl !== undefined) {
            localVarFormParams['refresh_url'] = ObjectSerializer.serialize(refreshUrl, "string");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AccountLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AccountLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>With <a href=\"/docs/connect\">Connect</a>, you can create Stripe accounts for your users. To do this, you’ll first need to <a href=\"https://dashboard.stripe.com/account/applications/settings\">register your platform</a>.</p>  <p>If you’ve already collected information for your connected accounts, you <a href=\"/docs/connect/best-practices#onboarding\">can pre-fill that information</a> when creating the account. Connect Onboarding won’t ask for the pre-filled information during account onboarding. You can pre-fill any information on the account.</p>
     * @param accountToken An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
     * @param businessProfile 
     * @param businessType The business type.
     * @param capabilities 
     * @param company 
     * @param country The country in which the account holder resides, or in which the business is legally established. This should be an ISO 3166-1 alpha-2 country code. For example, if you are in the United States and the business for which you\\\&#39;re creating an account is legally represented in Canada, you would use &#x60;CA&#x60; as the country for the account being created. Available countries include [Stripe\\\&#39;s global markets](https://stripe.com/global) as well as countries where [cross-border payouts](https://stripe.com/docs/connect/cross-border-payouts) are supported.
     * @param defaultCurrency Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account\\\&#39;s country](https://stripe.com/docs/payouts).
     * @param documents 
     * @param email The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
     * @param expand Specifies which fields in the response should be expanded.
     * @param externalAccount A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the &#x60;external_account&#x60; parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. &lt;br&gt;&lt;br&gt;By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
     * @param individual 
     * @param metadata 
     * @param settings 
     * @param tosAcceptance 
     * @param type The type of Stripe account to create. May be one of &#x60;custom&#x60;, &#x60;express&#x60; or &#x60;standard&#x60;.
     */
    public async postAccounts (accountToken?: string, businessProfile?: BusinessProfileSpecs, businessType?: string, capabilities?: CapabilitiesParam, company?: CompanySpecs, country?: string, defaultCurrency?: string, documents?: DocumentsSpecs, email?: string, expand?: Array<string>, externalAccount?: string, individual?: IndividualSpecs, metadata?: IndividualSpecsMetadata, settings?: SettingsSpecs, tosAcceptance?: TosAcceptanceSpecs, type?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountToken !== undefined) {
            localVarFormParams['account_token'] = ObjectSerializer.serialize(accountToken, "string");
        }

        if (businessProfile !== undefined) {
            localVarFormParams['business_profile'] = ObjectSerializer.serialize(businessProfile, "BusinessProfileSpecs");
        }

        if (businessType !== undefined) {
            localVarFormParams['business_type'] = ObjectSerializer.serialize(businessType, "string");
        }

        if (capabilities !== undefined) {
            localVarFormParams['capabilities'] = ObjectSerializer.serialize(capabilities, "CapabilitiesParam");
        }

        if (company !== undefined) {
            localVarFormParams['company'] = ObjectSerializer.serialize(company, "CompanySpecs");
        }

        if (country !== undefined) {
            localVarFormParams['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (defaultCurrency !== undefined) {
            localVarFormParams['default_currency'] = ObjectSerializer.serialize(defaultCurrency, "string");
        }

        if (documents !== undefined) {
            localVarFormParams['documents'] = ObjectSerializer.serialize(documents, "DocumentsSpecs");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (externalAccount !== undefined) {
            localVarFormParams['external_account'] = ObjectSerializer.serialize(externalAccount, "string");
        }

        if (individual !== undefined) {
            localVarFormParams['individual'] = ObjectSerializer.serialize(individual, "IndividualSpecs");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (settings !== undefined) {
            localVarFormParams['settings'] = ObjectSerializer.serialize(settings, "SettingsSpecs");
        }

        if (tosAcceptance !== undefined) {
            localVarFormParams['tos_acceptance'] = ObjectSerializer.serialize(tosAcceptance, "TosAcceptanceSpecs");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a <a href=\"/docs/connect/accounts\">connected account</a> by setting the values of the parameters passed. Any parameters not provided are left unchanged.</p>  <p>For Custom accounts, you can update any information on the account. For other accounts, you can update all information until that account has started to go through Connect Onboarding. Once you create an <a href=\"/docs/api/account_links\">Account Link</a> for a Standard or Express account, some parameters can no longer be changed. These are marked as <strong>Custom Only</strong> or <strong>Custom and Express</strong> below.</p>  <p>To update your own account, use the <a href=\"https://dashboard.stripe.com/account\">Dashboard</a>. Refer to our <a href=\"/docs/connect/updating-accounts\">Connect</a> documentation to learn more about updating accounts.</p>
     * @param account 
     * @param accountToken An [account token](https://stripe.com/docs/api#create_account_token), used to securely provide details to the account.
     * @param businessProfile 
     * @param businessType The business type.
     * @param capabilities 
     * @param company 
     * @param defaultCurrency Three-letter ISO currency code representing the default currency for the account. This must be a currency that [Stripe supports in the account\\\&#39;s country](https://stripe.com/docs/payouts).
     * @param documents 
     * @param email The email address of the account holder. This is only to make the account easier to identify to you. Stripe only emails Custom accounts with your consent.
     * @param expand Specifies which fields in the response should be expanded.
     * @param externalAccount A card or bank account to attach to the account for receiving [payouts](https://stripe.com/docs/connect/bank-debit-card-payouts) (you won’t be able to use it for top-ups). You can provide either a token, like the ones returned by [Stripe.js](https://stripe.com/docs/js), or a dictionary, as documented in the &#x60;external_account&#x60; parameter for [bank account](https://stripe.com/docs/api#account_create_bank_account) creation. &lt;br&gt;&lt;br&gt;By default, providing an external account sets it as the new default external account for its currency, and deletes the old default if one exists. To add additional external accounts without replacing the existing default for the currency, use the [bank account](https://stripe.com/docs/api#account_create_bank_account) or [card creation](https://stripe.com/docs/api#account_create_card) APIs.
     * @param individual 
     * @param metadata 
     * @param settings 
     * @param tosAcceptance 
     */
    public async postAccountsAccount (account: string, accountToken?: string, businessProfile?: BusinessProfileSpecs, businessType?: string, capabilities?: CapabilitiesParam, company?: CompanySpecs, defaultCurrency?: string, documents?: DocumentsSpecs, email?: string, expand?: Array<string>, externalAccount?: string, individual?: IndividualSpecs, metadata?: IndividualSpecsMetadata, settings?: SettingsSpecsUpdate, tosAcceptance?: TosAcceptanceSpecs, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountToken !== undefined) {
            localVarFormParams['account_token'] = ObjectSerializer.serialize(accountToken, "string");
        }

        if (businessProfile !== undefined) {
            localVarFormParams['business_profile'] = ObjectSerializer.serialize(businessProfile, "BusinessProfileSpecs");
        }

        if (businessType !== undefined) {
            localVarFormParams['business_type'] = ObjectSerializer.serialize(businessType, "string");
        }

        if (capabilities !== undefined) {
            localVarFormParams['capabilities'] = ObjectSerializer.serialize(capabilities, "CapabilitiesParam");
        }

        if (company !== undefined) {
            localVarFormParams['company'] = ObjectSerializer.serialize(company, "CompanySpecs");
        }

        if (defaultCurrency !== undefined) {
            localVarFormParams['default_currency'] = ObjectSerializer.serialize(defaultCurrency, "string");
        }

        if (documents !== undefined) {
            localVarFormParams['documents'] = ObjectSerializer.serialize(documents, "DocumentsSpecs");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (externalAccount !== undefined) {
            localVarFormParams['external_account'] = ObjectSerializer.serialize(externalAccount, "string");
        }

        if (individual !== undefined) {
            localVarFormParams['individual'] = ObjectSerializer.serialize(individual, "IndividualSpecs");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (settings !== undefined) {
            localVarFormParams['settings'] = ObjectSerializer.serialize(settings, "SettingsSpecsUpdate");
        }

        if (tosAcceptance !== undefined) {
            localVarFormParams['tos_acceptance'] = ObjectSerializer.serialize(tosAcceptance, "TosAcceptanceSpecs");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing Account Capability.</p>
     * @param account 
     * @param capability 
     * @param expand Specifies which fields in the response should be expanded.
     * @param requested Passing true requests the capability for the account, if it is not already requested. A requested capability may not immediately become active. Any requirements to activate the capability are returned in the &#x60;requirements&#x60; arrays.
     */
    public async postAccountsAccountCapabilitiesCapability (account: string, capability: string, expand?: Array<string>, requested?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Capability;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/capabilities/{capability}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'capability' + '}', encodeURIComponent(String(capability)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccountCapabilitiesCapability.');
        }

        // verify required parameter 'capability' is not null or undefined
        if (capability === null || capability === undefined) {
            throw new Error('Required parameter capability was null or undefined when calling postAccountsAccountCapabilitiesCapability.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (requested !== undefined) {
            localVarFormParams['requested'] = ObjectSerializer.serialize(requested, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Capability;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Capability");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Create an external account for a given account.</p>
     * @param account 
     * @param externalAccount Please refer to full [documentation](https://stripe.com/docs/api) instead.
     * @param defaultForCurrency When set to true, or if this is the first external account added in this currency, this account becomes the default external account for its currency.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postAccountsAccountExternalAccounts (account: string, externalAccount: string, defaultForCurrency?: boolean, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ExternalAccount;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/external_accounts'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccountExternalAccounts.');
        }

        // verify required parameter 'externalAccount' is not null or undefined
        if (externalAccount === null || externalAccount === undefined) {
            throw new Error('Required parameter externalAccount was null or undefined when calling postAccountsAccountExternalAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (defaultForCurrency !== undefined) {
            localVarFormParams['default_for_currency'] = ObjectSerializer.serialize(defaultForCurrency, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (externalAccount !== undefined) {
            localVarFormParams['external_account'] = ObjectSerializer.serialize(externalAccount, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ExternalAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ExternalAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the metadata, account holder name, account holder type of a bank account belonging to a <a href=\"/docs/connect/custom-accounts\">Custom account</a>, and optionally sets it as the default for its currency. Other bank account details are not editable by design.</p>  <p>You can re-enable a disabled bank account by performing an update call without providing any arguments or changes.</p>
     * @param account 
     * @param id 
     * @param accountHolderName The name of the person or business that owns the bank account.
     * @param accountHolderType The type of entity that holds the account. This can be either &#x60;individual&#x60; or &#x60;company&#x60;.
     * @param accountType The bank account type. This can only be &#x60;checking&#x60; or &#x60;savings&#x60; in most countries. In Japan, this can only be &#x60;futsu&#x60; or &#x60;toza&#x60;.
     * @param addressCity City/District/Suburb/Town/Village.
     * @param addressCountry Billing address country, if provided when creating card.
     * @param addressLine1 Address line 1 (Street address/PO Box/Company name).
     * @param addressLine2 Address line 2 (Apartment/Suite/Unit/Building).
     * @param addressState State/County/Province/Region.
     * @param addressZip ZIP or postal code.
     * @param defaultForCurrency When set to true, this becomes the default external account for its currency.
     * @param expMonth Two digit number representing the card’s expiration month.
     * @param expYear Four digit number representing the card’s expiration year.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param name Cardholder name.
     */
    public async postAccountsAccountExternalAccountsId (account: string, id: string, accountHolderName?: string, accountHolderType?: string, accountType?: string, addressCity?: string, addressCountry?: string, addressLine1?: string, addressLine2?: string, addressState?: string, addressZip?: string, defaultForCurrency?: boolean, expMonth?: string, expYear?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, name?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ExternalAccount;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/external_accounts/{id}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccountExternalAccountsId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postAccountsAccountExternalAccountsId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountHolderName !== undefined) {
            localVarFormParams['account_holder_name'] = ObjectSerializer.serialize(accountHolderName, "string");
        }

        if (accountHolderType !== undefined) {
            localVarFormParams['account_holder_type'] = ObjectSerializer.serialize(accountHolderType, "string");
        }

        if (accountType !== undefined) {
            localVarFormParams['account_type'] = ObjectSerializer.serialize(accountType, "string");
        }

        if (addressCity !== undefined) {
            localVarFormParams['address_city'] = ObjectSerializer.serialize(addressCity, "string");
        }

        if (addressCountry !== undefined) {
            localVarFormParams['address_country'] = ObjectSerializer.serialize(addressCountry, "string");
        }

        if (addressLine1 !== undefined) {
            localVarFormParams['address_line1'] = ObjectSerializer.serialize(addressLine1, "string");
        }

        if (addressLine2 !== undefined) {
            localVarFormParams['address_line2'] = ObjectSerializer.serialize(addressLine2, "string");
        }

        if (addressState !== undefined) {
            localVarFormParams['address_state'] = ObjectSerializer.serialize(addressState, "string");
        }

        if (addressZip !== undefined) {
            localVarFormParams['address_zip'] = ObjectSerializer.serialize(addressZip, "string");
        }

        if (defaultForCurrency !== undefined) {
            localVarFormParams['default_for_currency'] = ObjectSerializer.serialize(defaultForCurrency, "boolean");
        }

        if (expMonth !== undefined) {
            localVarFormParams['exp_month'] = ObjectSerializer.serialize(expMonth, "string");
        }

        if (expYear !== undefined) {
            localVarFormParams['exp_year'] = ObjectSerializer.serialize(expYear, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ExternalAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ExternalAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a single-use login link for an Express account to access their Stripe dashboard.</p>  <p><strong>You may only create login links for <a href=\"/docs/connect/express-accounts\">Express accounts</a> connected to your platform</strong>.</p>
     * @param account 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postAccountsAccountLoginLinks (account: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: LoginLink;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/login_links'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccountLoginLinks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: LoginLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "LoginLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new person.</p>
     * @param account 
     * @param address 
     * @param addressKana 
     * @param addressKanji 
     * @param dob 
     * @param documents 
     * @param email The person\\\&#39;s email address.
     * @param expand Specifies which fields in the response should be expanded.
     * @param firstName The person\\\&#39;s first name.
     * @param firstNameKana The Kana variation of the person\\\&#39;s first name (Japan only).
     * @param firstNameKanji The Kanji variation of the person\\\&#39;s first name (Japan only).
     * @param fullNameAliases 
     * @param gender The person\\\&#39;s gender (International regulations require either \\\&quot;male\\\&quot; or \\\&quot;female\\\&quot;).
     * @param idNumber The person\\\&#39;s ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type&#x3D;pii).
     * @param idNumberSecondary The person\\\&#39;s secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type&#x3D;pii).
     * @param lastName The person\\\&#39;s last name.
     * @param lastNameKana The Kana variation of the person\\\&#39;s last name (Japan only).
     * @param lastNameKanji The Kanji variation of the person\\\&#39;s last name (Japan only).
     * @param maidenName The person\\\&#39;s maiden name.
     * @param metadata 
     * @param nationality The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\&quot;XX\\\&quot; if unavailable.
     * @param personToken A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
     * @param phone The person\\\&#39;s phone number.
     * @param politicalExposure Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
     * @param registeredAddress 
     * @param relationship 
     * @param ssnLast4 The last four digits of the person\\\&#39;s Social Security number (U.S. only).
     * @param verification 
     */
    public async postAccountsAccountPersons (account: string, address?: AddressSpecs4, addressKana?: JapanAddressKanaSpecs2, addressKanji?: JapanAddressKanjiSpecs2, dob?: PostAccountsAccountPersonsRequestDob, documents?: PersonDocumentsSpecs, email?: string, expand?: Array<string>, firstName?: string, firstNameKana?: string, firstNameKanji?: string, fullNameAliases?: PostAccountsAccountPersonsRequestFullNameAliases, gender?: string, idNumber?: string, idNumberSecondary?: string, lastName?: string, lastNameKana?: string, lastNameKanji?: string, maidenName?: string, metadata?: IndividualSpecsMetadata, nationality?: string, personToken?: string, phone?: string, politicalExposure?: string, registeredAddress?: AddressSpecs5, relationship?: RelationshipSpecs, ssnLast4?: string, verification?: PersonVerificationSpecs1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Person;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/persons'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccountPersons.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (address !== undefined) {
            localVarFormParams['address'] = ObjectSerializer.serialize(address, "AddressSpecs4");
        }

        if (addressKana !== undefined) {
            localVarFormParams['address_kana'] = ObjectSerializer.serialize(addressKana, "JapanAddressKanaSpecs2");
        }

        if (addressKanji !== undefined) {
            localVarFormParams['address_kanji'] = ObjectSerializer.serialize(addressKanji, "JapanAddressKanjiSpecs2");
        }

        if (dob !== undefined) {
            localVarFormParams['dob'] = ObjectSerializer.serialize(dob, "PostAccountsAccountPersonsRequestDob");
        }

        if (documents !== undefined) {
            localVarFormParams['documents'] = ObjectSerializer.serialize(documents, "PersonDocumentsSpecs");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (firstName !== undefined) {
            localVarFormParams['first_name'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (firstNameKana !== undefined) {
            localVarFormParams['first_name_kana'] = ObjectSerializer.serialize(firstNameKana, "string");
        }

        if (firstNameKanji !== undefined) {
            localVarFormParams['first_name_kanji'] = ObjectSerializer.serialize(firstNameKanji, "string");
        }

        if (fullNameAliases !== undefined) {
            localVarFormParams['full_name_aliases'] = ObjectSerializer.serialize(fullNameAliases, "PostAccountsAccountPersonsRequestFullNameAliases");
        }

        if (gender !== undefined) {
            localVarFormParams['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (idNumber !== undefined) {
            localVarFormParams['id_number'] = ObjectSerializer.serialize(idNumber, "string");
        }

        if (idNumberSecondary !== undefined) {
            localVarFormParams['id_number_secondary'] = ObjectSerializer.serialize(idNumberSecondary, "string");
        }

        if (lastName !== undefined) {
            localVarFormParams['last_name'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (lastNameKana !== undefined) {
            localVarFormParams['last_name_kana'] = ObjectSerializer.serialize(lastNameKana, "string");
        }

        if (lastNameKanji !== undefined) {
            localVarFormParams['last_name_kanji'] = ObjectSerializer.serialize(lastNameKanji, "string");
        }

        if (maidenName !== undefined) {
            localVarFormParams['maiden_name'] = ObjectSerializer.serialize(maidenName, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (nationality !== undefined) {
            localVarFormParams['nationality'] = ObjectSerializer.serialize(nationality, "string");
        }

        if (personToken !== undefined) {
            localVarFormParams['person_token'] = ObjectSerializer.serialize(personToken, "string");
        }

        if (phone !== undefined) {
            localVarFormParams['phone'] = ObjectSerializer.serialize(phone, "string");
        }

        if (politicalExposure !== undefined) {
            localVarFormParams['political_exposure'] = ObjectSerializer.serialize(politicalExposure, "string");
        }

        if (registeredAddress !== undefined) {
            localVarFormParams['registered_address'] = ObjectSerializer.serialize(registeredAddress, "AddressSpecs5");
        }

        if (relationship !== undefined) {
            localVarFormParams['relationship'] = ObjectSerializer.serialize(relationship, "RelationshipSpecs");
        }

        if (ssnLast4 !== undefined) {
            localVarFormParams['ssn_last_4'] = ObjectSerializer.serialize(ssnLast4, "string");
        }

        if (verification !== undefined) {
            localVarFormParams['verification'] = ObjectSerializer.serialize(verification, "PersonVerificationSpecs1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Person;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Person");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing person.</p>
     * @param account 
     * @param person 
     * @param address 
     * @param addressKana 
     * @param addressKanji 
     * @param dob 
     * @param documents 
     * @param email The person\\\&#39;s email address.
     * @param expand Specifies which fields in the response should be expanded.
     * @param firstName The person\\\&#39;s first name.
     * @param firstNameKana The Kana variation of the person\\\&#39;s first name (Japan only).
     * @param firstNameKanji The Kanji variation of the person\\\&#39;s first name (Japan only).
     * @param fullNameAliases 
     * @param gender The person\\\&#39;s gender (International regulations require either \\\&quot;male\\\&quot; or \\\&quot;female\\\&quot;).
     * @param idNumber The person\\\&#39;s ID number, as appropriate for their country. For example, a social security number in the U.S., social insurance number in Canada, etc. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type&#x3D;pii).
     * @param idNumberSecondary The person\\\&#39;s secondary ID number, as appropriate for their country, will be used for enhanced verification checks. In Thailand, this would be the laser code found on the back of an ID card. Instead of the number itself, you can also provide a [PII token provided by Stripe.js](https://stripe.com/docs/js/tokens_sources/create_token?type&#x3D;pii).
     * @param lastName The person\\\&#39;s last name.
     * @param lastNameKana The Kana variation of the person\\\&#39;s last name (Japan only).
     * @param lastNameKanji The Kanji variation of the person\\\&#39;s last name (Japan only).
     * @param maidenName The person\\\&#39;s maiden name.
     * @param metadata 
     * @param nationality The country where the person is a national. Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)), or \\\&quot;XX\\\&quot; if unavailable.
     * @param personToken A [person token](https://stripe.com/docs/connect/account-tokens), used to securely provide details to the person.
     * @param phone The person\\\&#39;s phone number.
     * @param politicalExposure Indicates if the person or any of their representatives, family members, or other closely related persons, declares that they hold or have held an important public job or function, in any jurisdiction.
     * @param registeredAddress 
     * @param relationship 
     * @param ssnLast4 The last four digits of the person\\\&#39;s Social Security number (U.S. only).
     * @param verification 
     */
    public async postAccountsAccountPersonsPerson (account: string, person: string, address?: AddressSpecs4, addressKana?: JapanAddressKanaSpecs2, addressKanji?: JapanAddressKanjiSpecs2, dob?: PostAccountsAccountPersonsRequestDob, documents?: PersonDocumentsSpecs, email?: string, expand?: Array<string>, firstName?: string, firstNameKana?: string, firstNameKanji?: string, fullNameAliases?: PostAccountsAccountPersonsRequestFullNameAliases, gender?: string, idNumber?: string, idNumberSecondary?: string, lastName?: string, lastNameKana?: string, lastNameKanji?: string, maidenName?: string, metadata?: IndividualSpecsMetadata, nationality?: string, personToken?: string, phone?: string, politicalExposure?: string, registeredAddress?: AddressSpecs5, relationship?: RelationshipSpecs, ssnLast4?: string, verification?: PersonVerificationSpecs1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Person;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/persons/{person}'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)))
            .replace('{' + 'person' + '}', encodeURIComponent(String(person)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccountPersonsPerson.');
        }

        // verify required parameter 'person' is not null or undefined
        if (person === null || person === undefined) {
            throw new Error('Required parameter person was null or undefined when calling postAccountsAccountPersonsPerson.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (address !== undefined) {
            localVarFormParams['address'] = ObjectSerializer.serialize(address, "AddressSpecs4");
        }

        if (addressKana !== undefined) {
            localVarFormParams['address_kana'] = ObjectSerializer.serialize(addressKana, "JapanAddressKanaSpecs2");
        }

        if (addressKanji !== undefined) {
            localVarFormParams['address_kanji'] = ObjectSerializer.serialize(addressKanji, "JapanAddressKanjiSpecs2");
        }

        if (dob !== undefined) {
            localVarFormParams['dob'] = ObjectSerializer.serialize(dob, "PostAccountsAccountPersonsRequestDob");
        }

        if (documents !== undefined) {
            localVarFormParams['documents'] = ObjectSerializer.serialize(documents, "PersonDocumentsSpecs");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (firstName !== undefined) {
            localVarFormParams['first_name'] = ObjectSerializer.serialize(firstName, "string");
        }

        if (firstNameKana !== undefined) {
            localVarFormParams['first_name_kana'] = ObjectSerializer.serialize(firstNameKana, "string");
        }

        if (firstNameKanji !== undefined) {
            localVarFormParams['first_name_kanji'] = ObjectSerializer.serialize(firstNameKanji, "string");
        }

        if (fullNameAliases !== undefined) {
            localVarFormParams['full_name_aliases'] = ObjectSerializer.serialize(fullNameAliases, "PostAccountsAccountPersonsRequestFullNameAliases");
        }

        if (gender !== undefined) {
            localVarFormParams['gender'] = ObjectSerializer.serialize(gender, "string");
        }

        if (idNumber !== undefined) {
            localVarFormParams['id_number'] = ObjectSerializer.serialize(idNumber, "string");
        }

        if (idNumberSecondary !== undefined) {
            localVarFormParams['id_number_secondary'] = ObjectSerializer.serialize(idNumberSecondary, "string");
        }

        if (lastName !== undefined) {
            localVarFormParams['last_name'] = ObjectSerializer.serialize(lastName, "string");
        }

        if (lastNameKana !== undefined) {
            localVarFormParams['last_name_kana'] = ObjectSerializer.serialize(lastNameKana, "string");
        }

        if (lastNameKanji !== undefined) {
            localVarFormParams['last_name_kanji'] = ObjectSerializer.serialize(lastNameKanji, "string");
        }

        if (maidenName !== undefined) {
            localVarFormParams['maiden_name'] = ObjectSerializer.serialize(maidenName, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (nationality !== undefined) {
            localVarFormParams['nationality'] = ObjectSerializer.serialize(nationality, "string");
        }

        if (personToken !== undefined) {
            localVarFormParams['person_token'] = ObjectSerializer.serialize(personToken, "string");
        }

        if (phone !== undefined) {
            localVarFormParams['phone'] = ObjectSerializer.serialize(phone, "string");
        }

        if (politicalExposure !== undefined) {
            localVarFormParams['political_exposure'] = ObjectSerializer.serialize(politicalExposure, "string");
        }

        if (registeredAddress !== undefined) {
            localVarFormParams['registered_address'] = ObjectSerializer.serialize(registeredAddress, "AddressSpecs5");
        }

        if (relationship !== undefined) {
            localVarFormParams['relationship'] = ObjectSerializer.serialize(relationship, "RelationshipSpecs");
        }

        if (ssnLast4 !== undefined) {
            localVarFormParams['ssn_last_4'] = ObjectSerializer.serialize(ssnLast4, "string");
        }

        if (verification !== undefined) {
            localVarFormParams['verification'] = ObjectSerializer.serialize(verification, "PersonVerificationSpecs1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Person;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Person");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>With <a href=\"/docs/connect\">Connect</a>, you may flag accounts as suspicious.</p>  <p>Test-mode Custom and Express accounts can be rejected at any time. Accounts created using live-mode keys may only be rejected once all balances are zero.</p>
     * @param account 
     * @param reason The reason for rejecting the account. Can be &#x60;fraud&#x60;, &#x60;terms_of_service&#x60;, or &#x60;other&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postAccountsAccountReject (account: string, reason: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Account;  }> {
        const localVarPath = this.basePath + '/v1/accounts/{account}/reject'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postAccountsAccountReject.');
        }

        // verify required parameter 'reason' is not null or undefined
        if (reason === null || reason === undefined) {
            throw new Error('Required parameter reason was null or undefined when calling postAccountsAccountReject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (reason !== undefined) {
            localVarFormParams['reason'] = ObjectSerializer.serialize(reason, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Account;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Account");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Create an apple pay domain.</p>
     * @param domainName 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postApplePayDomains (domainName: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ApplePayDomain;  }> {
        const localVarPath = this.basePath + '/v1/apple_pay/domains';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'domainName' is not null or undefined
        if (domainName === null || domainName === undefined) {
            throw new Error('Required parameter domainName was null or undefined when calling postApplePayDomains.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (domainName !== undefined) {
            localVarFormParams['domain_name'] = ObjectSerializer.serialize(domainName, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ApplePayDomain;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ApplePayDomain");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified application fee refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request only accepts metadata as an argument.</p>
     * @param fee 
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postApplicationFeesFeeRefundsId (fee: string, id: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FeeRefund;  }> {
        const localVarPath = this.basePath + '/v1/application_fees/{fee}/refunds/{id}'
            .replace('{' + 'fee' + '}', encodeURIComponent(String(fee)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'fee' is not null or undefined
        if (fee === null || fee === undefined) {
            throw new Error('Required parameter fee was null or undefined when calling postApplicationFeesFeeRefundsId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postApplicationFeesFeeRefundsId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FeeRefund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FeeRefund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Refunds an application fee that has previously been collected but not yet refunded. Funds will be refunded to the Stripe account from which the fee was originally collected.</p>  <p>You can optionally refund only part of an application fee. You can do so multiple times, until the entire fee has been refunded.</p>  <p>Once entirely refunded, an application fee can’t be refunded again. This method will raise an error when called on an already-refunded application fee, or when trying to refund more money than is left on an application fee.</p>
     * @param id 
     * @param amount A positive integer, in _cents (or local equivalent)_, representing how much of this fee to refund. Can refund only up to the remaining unrefunded amount of the fee.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postApplicationFeesIdRefunds (id: string, amount?: number, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FeeRefund;  }> {
        const localVarPath = this.basePath + '/v1/application_fees/{id}/refunds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postApplicationFeesIdRefunds.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FeeRefund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FeeRefund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Create or replace a secret in the secret store.</p>
     * @param name A name for the secret that\\\&#39;s unique within the scope.
     * @param payload The plaintext secret value to be stored.
     * @param scope 
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt The Unix timestamp for the expiry time of the secret, after which the secret deletes.
     */
    public async postAppsSecrets (name: string, payload: string, scope: ScopeParam1, expand?: Array<string>, expiresAt?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AppsSecret;  }> {
        const localVarPath = this.basePath + '/v1/apps/secrets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAppsSecrets.');
        }

        // verify required parameter 'payload' is not null or undefined
        if (payload === null || payload === undefined) {
            throw new Error('Required parameter payload was null or undefined when calling postAppsSecrets.');
        }

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling postAppsSecrets.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "number");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (payload !== undefined) {
            localVarFormParams['payload'] = ObjectSerializer.serialize(payload, "string");
        }

        if (scope !== undefined) {
            localVarFormParams['scope'] = ObjectSerializer.serialize(scope, "ScopeParam1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AppsSecret;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AppsSecret");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Deletes a secret from the secret store by name and scope.</p>
     * @param name A name for the secret that\\\&#39;s unique within the scope.
     * @param scope 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postAppsSecretsDelete (name: string, scope: ScopeParam1, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AppsSecret;  }> {
        const localVarPath = this.basePath + '/v1/apps/secrets/delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postAppsSecretsDelete.');
        }

        // verify required parameter 'scope' is not null or undefined
        if (scope === null || scope === undefined) {
            throw new Error('Required parameter scope was null or undefined when calling postAppsSecretsDelete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (scope !== undefined) {
            localVarFormParams['scope'] = ObjectSerializer.serialize(scope, "ScopeParam1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AppsSecret;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AppsSecret");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a configuration that describes the functionality and behavior of a PortalSession</p>
     * @param businessProfile 
     * @param features 
     * @param defaultReturnUrl 
     * @param expand Specifies which fields in the response should be expanded.
     * @param loginPage 
     */
    public async postBillingPortalConfigurations (businessProfile: BusinessProfileCreateParam, features: FeaturesCreationParam, defaultReturnUrl?: PostBillingPortalConfigurationsRequestDefaultReturnUrl, expand?: Array<string>, loginPage?: LoginPageCreateParam, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BillingPortalConfiguration;  }> {
        const localVarPath = this.basePath + '/v1/billing_portal/configurations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'businessProfile' is not null or undefined
        if (businessProfile === null || businessProfile === undefined) {
            throw new Error('Required parameter businessProfile was null or undefined when calling postBillingPortalConfigurations.');
        }

        // verify required parameter 'features' is not null or undefined
        if (features === null || features === undefined) {
            throw new Error('Required parameter features was null or undefined when calling postBillingPortalConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (businessProfile !== undefined) {
            localVarFormParams['business_profile'] = ObjectSerializer.serialize(businessProfile, "BusinessProfileCreateParam");
        }

        if (defaultReturnUrl !== undefined) {
            localVarFormParams['default_return_url'] = ObjectSerializer.serialize(defaultReturnUrl, "PostBillingPortalConfigurationsRequestDefaultReturnUrl");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (features !== undefined) {
            localVarFormParams['features'] = ObjectSerializer.serialize(features, "FeaturesCreationParam");
        }

        if (loginPage !== undefined) {
            localVarFormParams['login_page'] = ObjectSerializer.serialize(loginPage, "LoginPageCreateParam");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BillingPortalConfiguration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BillingPortalConfiguration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a configuration that describes the functionality of the customer portal.</p>
     * @param configuration 
     * @param active Whether the configuration is active and can be used to create portal sessions.
     * @param businessProfile 
     * @param defaultReturnUrl 
     * @param expand Specifies which fields in the response should be expanded.
     * @param features 
     * @param loginPage 
     * @param metadata 
     */
    public async postBillingPortalConfigurationsConfiguration (configuration: string, active?: boolean, businessProfile?: BusinessProfileUpdateParam, defaultReturnUrl?: PostBillingPortalConfigurationsRequestDefaultReturnUrl, expand?: Array<string>, features?: FeaturesUpdatingParam, loginPage?: LoginPageUpdateParam, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BillingPortalConfiguration;  }> {
        const localVarPath = this.basePath + '/v1/billing_portal/configurations/{configuration}'
            .replace('{' + 'configuration' + '}', encodeURIComponent(String(configuration)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'configuration' is not null or undefined
        if (configuration === null || configuration === undefined) {
            throw new Error('Required parameter configuration was null or undefined when calling postBillingPortalConfigurationsConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (businessProfile !== undefined) {
            localVarFormParams['business_profile'] = ObjectSerializer.serialize(businessProfile, "BusinessProfileUpdateParam");
        }

        if (defaultReturnUrl !== undefined) {
            localVarFormParams['default_return_url'] = ObjectSerializer.serialize(defaultReturnUrl, "PostBillingPortalConfigurationsRequestDefaultReturnUrl");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (features !== undefined) {
            localVarFormParams['features'] = ObjectSerializer.serialize(features, "FeaturesUpdatingParam");
        }

        if (loginPage !== undefined) {
            localVarFormParams['login_page'] = ObjectSerializer.serialize(loginPage, "LoginPageUpdateParam");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BillingPortalConfiguration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BillingPortalConfiguration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a session of the customer portal.</p>
     * @param customer The ID of an existing customer.
     * @param configuration The ID of an existing [configuration](https://stripe.com/docs/api/customer_portal/configuration) to use for this session, describing its functionality and features. If not specified, the session uses the default configuration.
     * @param expand Specifies which fields in the response should be expanded.
     * @param flowData 
     * @param locale The IETF language tag of the locale Customer Portal is displayed in. If blank or auto, the customer’s &#x60;preferred_locales&#x60; or browser’s locale is used.
     * @param onBehalfOf The &#x60;on_behalf_of&#x60; account to use for this session. When specified, only subscriptions and invoices with this &#x60;on_behalf_of&#x60; account appear in the portal. For more information, see the [docs](https://stripe.com/docs/connect/charges-transfers#on-behalf-of). Use the [Accounts API](https://stripe.com/docs/api/accounts/object#account_object-settings-branding) to modify the &#x60;on_behalf_of&#x60; account\\\&#39;s branding settings, which the portal displays.
     * @param returnUrl The default URL to redirect customers to when they click on the portal\\\&#39;s link to return to your website.
     */
    public async postBillingPortalSessions (customer: string, configuration?: string, expand?: Array<string>, flowData?: FlowDataParam, locale?: string, onBehalfOf?: string, returnUrl?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BillingPortalSession;  }> {
        const localVarPath = this.basePath + '/v1/billing_portal/sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postBillingPortalSessions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (configuration !== undefined) {
            localVarFormParams['configuration'] = ObjectSerializer.serialize(configuration, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (flowData !== undefined) {
            localVarFormParams['flow_data'] = ObjectSerializer.serialize(flowData, "FlowDataParam");
        }

        if (locale !== undefined) {
            localVarFormParams['locale'] = ObjectSerializer.serialize(locale, "string");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BillingPortalSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BillingPortalSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>To charge a credit card or other payment source, you create a <code>Charge</code> object. If your API key is in test mode, the supplied payment source (e.g., card) won’t actually be charged, although everything else will occur as if in live mode. (Stripe assumes that the charge would have completed successfully).</p>
     * @param amount Amount intended to be collected by this payment. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
     * @param applicationFee 
     * @param applicationFeeAmount A fee in cents (or local equivalent) that will be applied to the charge and transferred to the application owner\\\&#39;s Stripe account. The request must be made with an OAuth key or the &#x60;Stripe-Account&#x60; header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/connect/direct-charges#collecting-fees).
     * @param capture Whether to immediately capture the charge. Defaults to &#x60;true&#x60;. When &#x60;false&#x60;, the charge issues an authorization (or pre-authorization), and will need to be [captured](https://stripe.com/docs/api#capture_charge) later. Uncaptured charges expire after a set number of days (7 by default). For more information, see the [authorizing charges and settling later](https://stripe.com/docs/charges/placing-a-hold) documentation.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param customer The ID of an existing customer that will be charged in this request.
     * @param description An arbitrary string which you can attach to a &#x60;Charge&#x60; object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the &#x60;description&#x60; of the charge(s) that they are describing.
     * @param destination 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param onBehalfOf The Stripe account ID for which these funds are intended. Automatically set if you use the &#x60;destination&#x60; parameter. For details, see [Creating Separate Charges and Transfers](https://stripe.com/docs/connect/charges-transfers#on-behalf-of).
     * @param radarOptions 
     * @param receiptEmail The email address to which this charge\\\&#39;s [receipt](https://stripe.com/docs/dashboard/receipts) will be sent. The receipt will not be sent until the charge is paid, and no receipts will be sent for test mode charges. If this charge is for a [Customer](https://stripe.com/docs/api/customers/object), the email address specified here will override the customer\\\&#39;s email address. If &#x60;receipt_email&#x60; is specified for a charge in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
     * @param shipping 
     * @param source A payment source to be charged. This can be the ID of a [card](https://stripe.com/docs/api#cards) (i.e., credit or debit card), a [bank account](https://stripe.com/docs/api#bank_accounts), a [source](https://stripe.com/docs/api#sources), a [token](https://stripe.com/docs/api#tokens), or a [connected account](https://stripe.com/docs/connect/account-debits#charging-a-connected-account). For certain sources---namely, [cards](https://stripe.com/docs/api#cards), [bank accounts](https://stripe.com/docs/api#bank_accounts), and attached [sources](https://stripe.com/docs/api#sources)---you must also pass the ID of the associated customer.
     * @param statementDescriptor For card charges, use &#x60;statement_descriptor_suffix&#x60; instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
     * @param statementDescriptorSuffix Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
     * @param transferData 
     * @param transferGroup A string that identifies this transaction as part of a group. For details, see [Grouping transactions](https://stripe.com/docs/connect/charges-transfers#transfer-options).
     */
    public async postCharges (amount?: number, applicationFee?: number, applicationFeeAmount?: number, capture?: boolean, currency?: string, customer?: string, description?: string, destination?: DestinationSpecs, expand?: Array<string>, metadata?: IndividualSpecsMetadata, onBehalfOf?: string, radarOptions?: RadarOptions, receiptEmail?: string, shipping?: OptionalFieldsShipping, source?: string, statementDescriptor?: string, statementDescriptorSuffix?: string, transferData?: TransferDataSpecs, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Charge;  }> {
        const localVarPath = this.basePath + '/v1/charges';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (applicationFee !== undefined) {
            localVarFormParams['application_fee'] = ObjectSerializer.serialize(applicationFee, "number");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (capture !== undefined) {
            localVarFormParams['capture'] = ObjectSerializer.serialize(capture, "boolean");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (destination !== undefined) {
            localVarFormParams['destination'] = ObjectSerializer.serialize(destination, "DestinationSpecs");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        if (radarOptions !== undefined) {
            localVarFormParams['radar_options'] = ObjectSerializer.serialize(radarOptions, "RadarOptions");
        }

        if (receiptEmail !== undefined) {
            localVarFormParams['receipt_email'] = ObjectSerializer.serialize(receiptEmail, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "OptionalFieldsShipping");
        }

        if (source !== undefined) {
            localVarFormParams['source'] = ObjectSerializer.serialize(source, "string");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (statementDescriptorSuffix !== undefined) {
            localVarFormParams['statement_descriptor_suffix'] = ObjectSerializer.serialize(statementDescriptorSuffix, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataSpecs");
        }

        if (transferGroup !== undefined) {
            localVarFormParams['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Charge;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Charge");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified charge by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param charge 
     * @param customer The ID of an existing customer that will be associated with this request. This field may only be updated if there is no existing associated customer with this charge.
     * @param description An arbitrary string which you can attach to a charge object. It is displayed when in the web interface alongside the charge. Note that if you use Stripe to send automatic email receipts to your customers, your receipt emails will include the &#x60;description&#x60; of the charge(s) that they are describing.
     * @param expand Specifies which fields in the response should be expanded.
     * @param fraudDetails 
     * @param metadata 
     * @param receiptEmail This is the email address that the receipt for this charge will be sent to. If this field is updated, then a new email receipt will be sent to the updated address.
     * @param shipping 
     * @param transferGroup A string that identifies this transaction as part of a group. &#x60;transfer_group&#x60; may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
     */
    public async postChargesCharge (charge: string, customer?: string, description?: string, expand?: Array<string>, fraudDetails?: FraudDetails, metadata?: IndividualSpecsMetadata, receiptEmail?: string, shipping?: OptionalFieldsShipping, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Charge;  }> {
        const localVarPath = this.basePath + '/v1/charges/{charge}'
            .replace('{' + 'charge' + '}', encodeURIComponent(String(charge)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'charge' is not null or undefined
        if (charge === null || charge === undefined) {
            throw new Error('Required parameter charge was null or undefined when calling postChargesCharge.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (fraudDetails !== undefined) {
            localVarFormParams['fraud_details'] = ObjectSerializer.serialize(fraudDetails, "FraudDetails");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (receiptEmail !== undefined) {
            localVarFormParams['receipt_email'] = ObjectSerializer.serialize(receiptEmail, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "OptionalFieldsShipping");
        }

        if (transferGroup !== undefined) {
            localVarFormParams['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Charge;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Charge");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Capture the payment of an existing, uncaptured, charge. This is the second half of the two-step payment flow, where first you <a href=\"#create_charge\">created a charge</a> with the capture option set to false.</p>  <p>Uncaptured payments expire a set number of days after they are created (<a href=\"/docs/charges/placing-a-hold\">7 by default</a>). If they are not captured by that point in time, they will be marked as refunded and will no longer be capturable.</p>
     * @param charge 
     * @param amount The amount to capture, which must be less than or equal to the original amount. Any additional amount will be automatically refunded.
     * @param applicationFee An application fee to add on to this charge.
     * @param applicationFeeAmount An application fee amount to add on to this charge, which must be less than or equal to the original amount.
     * @param expand Specifies which fields in the response should be expanded.
     * @param receiptEmail The email address to send this charge\\\&#39;s receipt to. This will override the previously-specified email address for this charge, if one was set. Receipts will not be sent in test mode.
     * @param statementDescriptor For card charges, use &#x60;statement_descriptor_suffix&#x60; instead. Otherwise, you can use this value as the complete description of a charge on your customers’ statements. Must contain at least one letter, maximum 22 characters.
     * @param statementDescriptorSuffix Provides information about the charge that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
     * @param transferData 
     * @param transferGroup A string that identifies this transaction as part of a group. &#x60;transfer_group&#x60; may only be provided if it has not been set. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
     */
    public async postChargesChargeCapture (charge: string, amount?: number, applicationFee?: number, applicationFeeAmount?: number, expand?: Array<string>, receiptEmail?: string, statementDescriptor?: string, statementDescriptorSuffix?: string, transferData?: TransferDataSpecs1, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Charge;  }> {
        const localVarPath = this.basePath + '/v1/charges/{charge}/capture'
            .replace('{' + 'charge' + '}', encodeURIComponent(String(charge)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'charge' is not null or undefined
        if (charge === null || charge === undefined) {
            throw new Error('Required parameter charge was null or undefined when calling postChargesChargeCapture.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (applicationFee !== undefined) {
            localVarFormParams['application_fee'] = ObjectSerializer.serialize(applicationFee, "number");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (receiptEmail !== undefined) {
            localVarFormParams['receipt_email'] = ObjectSerializer.serialize(receiptEmail, "string");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (statementDescriptorSuffix !== undefined) {
            localVarFormParams['statement_descriptor_suffix'] = ObjectSerializer.serialize(statementDescriptorSuffix, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataSpecs1");
        }

        if (transferGroup !== undefined) {
            localVarFormParams['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Charge;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Charge");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a Session object.</p>
     * @param successUrl The URL to which Stripe should send customers when payment or setup is complete. If you’d like to use information from the successful Checkout Session on your page, read the guide on [customizing your success page](https://stripe.com/docs/payments/checkout/custom-success-page).
     * @param afterExpiration 
     * @param allowPromotionCodes Enables user redeemable promotion codes.
     * @param automaticTax 
     * @param billingAddressCollection Specify whether Checkout should collect the customer\\\&#39;s billing address.
     * @param cancelUrl If set, Checkout displays a back button and customers will be directed to this URL if they decide to cancel payment and return to your website.
     * @param clientReferenceId A unique string to reference the Checkout Session. This can be a customer ID, a cart ID, or similar, and can be used to reconcile the session with your internal systems.
     * @param consentCollection 
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param customFields Collect additional information from your customer using custom fields. Up to 2 fields are supported.
     * @param customText 
     * @param customer ID of an existing Customer, if one exists. In &#x60;payment&#x60; mode, the customer’s most recent card payment method will be used to prefill the email, name, card details, and billing address on the Checkout page. In &#x60;subscription&#x60; mode, the customer’s [default payment method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) will be used if it’s a card, and otherwise the most recent card will be used. A valid billing address, billing name and billing email are required on the payment method for Checkout to prefill the customer\\\&#39;s card details.  If the Customer already has a valid [email](https://stripe.com/docs/api/customers/object#customer_object-email) set, the email will be prefilled and not editable in Checkout. If the Customer does not have a valid &#x60;email&#x60;, Checkout will set the email entered during the session on the Customer.  If blank for Checkout Sessions in &#x60;payment&#x60; or &#x60;subscription&#x60; mode, Checkout will create a new Customer object based on information provided during the payment flow.  You can set [&#x60;payment_intent_data.setup_future_usage&#x60;](https://stripe.com/docs/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage) to have Checkout automatically attach the payment method to the Customer you pass in for future reuse.
     * @param customerCreation Configure whether a Checkout Session creates a [Customer](https://stripe.com/docs/api/customers) during Session confirmation.  When a Customer is not created, you can still retrieve email, address, and other customer data entered in Checkout with [customer_details](https://stripe.com/docs/api/checkout/sessions/object#checkout_session_object-customer_details).  Sessions that don\\\&#39;t create Customers instead are grouped by [guest customers](https://stripe.com/docs/payments/checkout/guest-customers) in the Dashboard. Promotion codes limited to first time customers will return invalid for these Sessions.  Can only be set in &#x60;payment&#x60; and &#x60;setup&#x60; mode.
     * @param customerEmail If provided, this value will be used when the Customer object is created. If not provided, customers will be asked to enter their email address. Use this parameter to prefill customer data if you already have an email on file. To access information about the customer once a session is complete, use the &#x60;customer&#x60; field.
     * @param customerUpdate 
     * @param discounts The coupon or promotion code to apply to this Session. Currently, only up to one may be specified.
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt The Epoch time in seconds at which the Checkout Session will expire. It can be anywhere from 30 minutes to 24 hours after Checkout Session creation. By default, this value is 24 hours from creation.
     * @param invoiceCreation 
     * @param lineItems A list of items the customer is purchasing. Use this parameter to pass one-time or recurring [Prices](https://stripe.com/docs/api/prices).  For &#x60;payment&#x60; mode, there is a maximum of 100 line items, however it is recommended to consolidate line items if there are more than a few dozen.  For &#x60;subscription&#x60; mode, there is a maximum of 20 line items with recurring Prices and 20 line items with one-time Prices. Line items with one-time Prices will be on the initial invoice only.
     * @param locale The IETF language tag of the locale Checkout is displayed in. If blank or &#x60;auto&#x60;, the browser\\\&#39;s locale is used.
     * @param mode The mode of the Checkout Session. Pass &#x60;subscription&#x60; if the Checkout Session includes at least one recurring item.
     * @param paymentIntentData 
     * @param paymentMethodCollection Specify whether Checkout should collect a payment method. When set to &#x60;if_required&#x60;, Checkout will not collect a payment method when the total due for the session is 0. This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in &#x60;subscription&#x60; mode.  If you\\\&#39;d like information on how to collect a payment method outside of Checkout, read the guide on configuring [subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
     * @param paymentMethodOptions 
     * @param paymentMethodTypes A list of the types of payment methods (e.g., &#x60;card&#x60;) this Checkout Session can accept.  In &#x60;payment&#x60; and &#x60;subscription&#x60; mode, you can omit this attribute to manage your payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods). It is required in &#x60;setup&#x60; mode.  Read more about the supported payment methods and their requirements in our [payment method details guide](/docs/payments/checkout/payment-methods).  If multiple payment methods are passed, Checkout will dynamically reorder them to prioritize the most relevant payment methods based on the customer\\\&#39;s location and other characteristics.
     * @param phoneNumberCollection 
     * @param setupIntentData 
     * @param shippingAddressCollection 
     * @param shippingOptions The shipping rate options to apply to this Session.
     * @param shippingRates [Deprecated] The shipping rate to apply to this Session. Only up to one may be specified.
     * @param submitType Describes the type of transaction being performed by Checkout in order to customize relevant text on the page, such as the submit button. &#x60;submit_type&#x60; can only be specified on Checkout Sessions in &#x60;payment&#x60; mode, but not Checkout Sessions in &#x60;subscription&#x60; or &#x60;setup&#x60; mode.
     * @param subscriptionData 
     * @param taxIdCollection 
     */
    public async postCheckoutSessions (successUrl: string, afterExpiration?: AfterExpirationParams, allowPromotionCodes?: boolean, automaticTax?: AutomaticTaxParams, billingAddressCollection?: string, cancelUrl?: string, clientReferenceId?: string, consentCollection?: ConsentCollectionParams, currency?: string, customFields?: Array<CustomFieldParam>, customText?: CustomTextParam, customer?: string, customerCreation?: string, customerEmail?: string, customerUpdate?: CustomerUpdateParams, discounts?: Array<DiscountParams>, expand?: Array<string>, expiresAt?: number, invoiceCreation?: InvoiceCreationParams, lineItems?: Array<LineItemParams>, locale?: string, mode?: string, paymentIntentData?: PaymentIntentDataParams, paymentMethodCollection?: string, paymentMethodOptions?: PaymentMethodOptionsParam, paymentMethodTypes?: Array<string>, phoneNumberCollection?: PhoneNumberCollectionParams, setupIntentData?: SetupIntentDataParam, shippingAddressCollection?: ShippingAddressCollectionParams, shippingOptions?: Array<ShippingOptionParams>, shippingRates?: Array<string>, submitType?: string, subscriptionData?: SubscriptionDataParams, taxIdCollection?: TaxIdCollectionParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CheckoutSession;  }> {
        const localVarPath = this.basePath + '/v1/checkout/sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'successUrl' is not null or undefined
        if (successUrl === null || successUrl === undefined) {
            throw new Error('Required parameter successUrl was null or undefined when calling postCheckoutSessions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (afterExpiration !== undefined) {
            localVarFormParams['after_expiration'] = ObjectSerializer.serialize(afterExpiration, "AfterExpirationParams");
        }

        if (allowPromotionCodes !== undefined) {
            localVarFormParams['allow_promotion_codes'] = ObjectSerializer.serialize(allowPromotionCodes, "boolean");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParams");
        }

        if (billingAddressCollection !== undefined) {
            localVarFormParams['billing_address_collection'] = ObjectSerializer.serialize(billingAddressCollection, "string");
        }

        if (cancelUrl !== undefined) {
            localVarFormParams['cancel_url'] = ObjectSerializer.serialize(cancelUrl, "string");
        }

        if (clientReferenceId !== undefined) {
            localVarFormParams['client_reference_id'] = ObjectSerializer.serialize(clientReferenceId, "string");
        }

        if (consentCollection !== undefined) {
            localVarFormParams['consent_collection'] = ObjectSerializer.serialize(consentCollection, "ConsentCollectionParams");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customFields !== undefined) {
            localVarFormParams['custom_fields'] = ObjectSerializer.serialize(customFields, "Array<CustomFieldParam>");
        }

        if (customText !== undefined) {
            localVarFormParams['custom_text'] = ObjectSerializer.serialize(customText, "CustomTextParam");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (customerCreation !== undefined) {
            localVarFormParams['customer_creation'] = ObjectSerializer.serialize(customerCreation, "string");
        }

        if (customerEmail !== undefined) {
            localVarFormParams['customer_email'] = ObjectSerializer.serialize(customerEmail, "string");
        }

        if (customerUpdate !== undefined) {
            localVarFormParams['customer_update'] = ObjectSerializer.serialize(customerUpdate, "CustomerUpdateParams");
        }

        if (discounts !== undefined) {
            localVarFormParams['discounts'] = ObjectSerializer.serialize(discounts, "Array<DiscountParams>");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "number");
        }

        if (invoiceCreation !== undefined) {
            localVarFormParams['invoice_creation'] = ObjectSerializer.serialize(invoiceCreation, "InvoiceCreationParams");
        }

        if (lineItems !== undefined) {
            localVarFormParams['line_items'] = ObjectSerializer.serialize(lineItems, "Array<LineItemParams>");
        }

        if (locale !== undefined) {
            localVarFormParams['locale'] = ObjectSerializer.serialize(locale, "string");
        }

        if (mode !== undefined) {
            localVarFormParams['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        if (paymentIntentData !== undefined) {
            localVarFormParams['payment_intent_data'] = ObjectSerializer.serialize(paymentIntentData, "PaymentIntentDataParams");
        }

        if (paymentMethodCollection !== undefined) {
            localVarFormParams['payment_method_collection'] = ObjectSerializer.serialize(paymentMethodCollection, "string");
        }

        if (paymentMethodOptions !== undefined) {
            localVarFormParams['payment_method_options'] = ObjectSerializer.serialize(paymentMethodOptions, "PaymentMethodOptionsParam");
        }

        if (paymentMethodTypes !== undefined) {
            localVarFormParams['payment_method_types'] = ObjectSerializer.serialize(paymentMethodTypes, "Array<string>");
        }

        if (phoneNumberCollection !== undefined) {
            localVarFormParams['phone_number_collection'] = ObjectSerializer.serialize(phoneNumberCollection, "PhoneNumberCollectionParams");
        }

        if (setupIntentData !== undefined) {
            localVarFormParams['setup_intent_data'] = ObjectSerializer.serialize(setupIntentData, "SetupIntentDataParam");
        }

        if (shippingAddressCollection !== undefined) {
            localVarFormParams['shipping_address_collection'] = ObjectSerializer.serialize(shippingAddressCollection, "ShippingAddressCollectionParams");
        }

        if (shippingOptions !== undefined) {
            localVarFormParams['shipping_options'] = ObjectSerializer.serialize(shippingOptions, "Array<ShippingOptionParams>");
        }

        if (shippingRates !== undefined) {
            localVarFormParams['shipping_rates'] = ObjectSerializer.serialize(shippingRates, "Array<string>");
        }

        if (submitType !== undefined) {
            localVarFormParams['submit_type'] = ObjectSerializer.serialize(submitType, "string");
        }

        if (subscriptionData !== undefined) {
            localVarFormParams['subscription_data'] = ObjectSerializer.serialize(subscriptionData, "SubscriptionDataParams");
        }

        if (successUrl !== undefined) {
            localVarFormParams['success_url'] = ObjectSerializer.serialize(successUrl, "string");
        }

        if (taxIdCollection !== undefined) {
            localVarFormParams['tax_id_collection'] = ObjectSerializer.serialize(taxIdCollection, "TaxIdCollectionParams");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CheckoutSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CheckoutSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A Session can be expired when it is in one of these statuses: <code>open</code> </p>  <p>After it expires, a customer can’t complete a Session and customers loading the Session see a message saying the Session is expired.</p>
     * @param session 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postCheckoutSessionsSessionExpire (session: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CheckoutSession;  }> {
        const localVarPath = this.basePath + '/v1/checkout/sessions/{session}/expire'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling postCheckoutSessionsSessionExpire.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CheckoutSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CheckoutSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can create coupons easily via the <a href=\"https://dashboard.stripe.com/coupons\">coupon management</a> page of the Stripe dashboard. Coupon creation is also accessible via the API if you need to create coupons on the fly.</p>  <p>A coupon has either a <code>percent_off</code> or an <code>amount_off</code> and <code>currency</code>. If you set an <code>amount_off</code>, that amount will be subtracted from any invoice’s subtotal. For example, an invoice with a subtotal of <currency>100</currency> will have a final total of <currency>0</currency> if a coupon with an <code>amount_off</code> of <amount>200</amount> is applied to it and an invoice with a subtotal of <currency>300</currency> will have a final total of <currency>100</currency> if a coupon with an <code>amount_off</code> of <amount>200</amount> is applied to it.</p>
     * @param amountOff A positive integer representing the amount to subtract from an invoice total (required if &#x60;percent_off&#x60; is not passed).
     * @param appliesTo 
     * @param currency Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) of the &#x60;amount_off&#x60; parameter (required if &#x60;amount_off&#x60; is passed).
     * @param duration Specifies how long the discount will be in effect if used on a subscription. Defaults to &#x60;once&#x60;.
     * @param durationInMonths Required only if &#x60;duration&#x60; is &#x60;repeating&#x60;, in which case it must be a positive integer that specifies the number of months the discount will be in effect.
     * @param expand Specifies which fields in the response should be expanded.
     * @param id Unique string of your choice that will be used to identify this coupon when applying it to a customer. If you don\\\&#39;t want to specify a particular code, you can leave the ID blank and we\\\&#39;ll generate a random code for you.
     * @param maxRedemptions A positive integer specifying the number of times the coupon can be redeemed before it\\\&#39;s no longer valid. For example, you might have a 50% off coupon that the first 20 readers of your blog can use.
     * @param metadata 
     * @param name Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the &#x60;id&#x60; is shown if &#x60;name&#x60; is not set.
     * @param percentOff A positive float larger than 0, and smaller or equal to 100, that represents the discount the coupon will apply (required if &#x60;amount_off&#x60; is not passed).
     * @param redeemBy Unix timestamp specifying the last time at which the coupon can be redeemed. After the redeem_by date, the coupon can no longer be applied to new customers.
     */
    public async postCoupons (amountOff?: number, appliesTo?: AppliesToParams, currency?: string, duration?: string, durationInMonths?: number, expand?: Array<string>, id?: string, maxRedemptions?: number, metadata?: IndividualSpecsMetadata, name?: string, percentOff?: number, redeemBy?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Coupon;  }> {
        const localVarPath = this.basePath + '/v1/coupons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amountOff !== undefined) {
            localVarFormParams['amount_off'] = ObjectSerializer.serialize(amountOff, "number");
        }

        if (appliesTo !== undefined) {
            localVarFormParams['applies_to'] = ObjectSerializer.serialize(appliesTo, "AppliesToParams");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (duration !== undefined) {
            localVarFormParams['duration'] = ObjectSerializer.serialize(duration, "string");
        }

        if (durationInMonths !== undefined) {
            localVarFormParams['duration_in_months'] = ObjectSerializer.serialize(durationInMonths, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (id !== undefined) {
            localVarFormParams['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (maxRedemptions !== undefined) {
            localVarFormParams['max_redemptions'] = ObjectSerializer.serialize(maxRedemptions, "number");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (percentOff !== undefined) {
            localVarFormParams['percent_off'] = ObjectSerializer.serialize(percentOff, "number");
        }

        if (redeemBy !== undefined) {
            localVarFormParams['redeem_by'] = ObjectSerializer.serialize(redeemBy, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Coupon;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Coupon");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the metadata of a coupon. Other coupon details (currency, duration, amount_off) are, by design, not editable.</p>
     * @param coupon 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param name Name of the coupon displayed to customers on, for instance invoices, or receipts. By default the &#x60;id&#x60; is shown if &#x60;name&#x60; is not set.
     */
    public async postCouponsCoupon (coupon: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, name?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Coupon;  }> {
        const localVarPath = this.basePath + '/v1/coupons/{coupon}'
            .replace('{' + 'coupon' + '}', encodeURIComponent(String(coupon)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling postCouponsCoupon.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Coupon;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Coupon");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Issue a credit note to adjust the amount of a finalized invoice. For a <code>status=open</code> invoice, a credit note reduces its <code>amount_due</code>. For a <code>status=paid</code> invoice, a credit note does not affect its <code>amount_due</code>. Instead, it can result in any combination of the following:</p>  <ul> <li>Refund: create a new refund (using <code>refund_amount</code>) or link an existing refund (using <code>refund</code>).</li> <li>Customer balance credit: credit the customer’s balance (using <code>credit_amount</code>) which will be automatically applied to their next invoice when it’s finalized.</li> <li>Outside of Stripe credit: record the amount that is or will be credited outside of Stripe (using <code>out_of_band_amount</code>).</li> </ul>  <p>For post-payment credit notes the sum of the refund, credit and outside of Stripe amounts must equal the credit note total.</p>  <p>You may issue multiple credit notes for an invoice. Each credit note will increment the invoice’s <code>pre_payment_credit_notes_amount</code> or <code>post_payment_credit_notes_amount</code> depending on its <code>status</code> at the time of credit note creation.</p>
     * @param invoice ID of the invoice.
     * @param amount The integer amount in cents (or local equivalent) representing the total amount of the credit note.
     * @param creditAmount The integer amount in cents (or local equivalent) representing the amount to credit the customer\\\&#39;s balance, which will be automatically applied to their next invoice.
     * @param expand Specifies which fields in the response should be expanded.
     * @param lines Line items that make up the credit note.
     * @param memo The credit note\\\&#39;s memo appears on the credit note PDF.
     * @param outOfBandAmount The integer amount in cents (or local equivalent) representing the amount that is credited outside of Stripe.
     * @param reason Reason for issuing this credit note, one of &#x60;duplicate&#x60;, &#x60;fraudulent&#x60;, &#x60;order_change&#x60;, or &#x60;product_unsatisfactory&#x60;
     * @param refund ID of an existing refund to link this credit note to.
     * @param refundAmount The integer amount in cents (or local equivalent) representing the amount to refund. If set, a refund will be created for the charge associated with the invoice.
     * @param shippingCost 
     */
    public async postCreditNotes (invoice: string, amount?: number, creditAmount?: number, expand?: Array<string>, lines?: Array<CreditNoteLineItemParams>, memo?: string, outOfBandAmount?: number, reason?: string, refund?: string, refundAmount?: number, shippingCost?: CreditNoteShippingCost, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNote;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling postCreditNotes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (creditAmount !== undefined) {
            localVarFormParams['credit_amount'] = ObjectSerializer.serialize(creditAmount, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoice !== undefined) {
            localVarFormParams['invoice'] = ObjectSerializer.serialize(invoice, "string");
        }

        if (lines !== undefined) {
            localVarFormParams['lines'] = ObjectSerializer.serialize(lines, "Array<CreditNoteLineItemParams>");
        }

        if (memo !== undefined) {
            localVarFormParams['memo'] = ObjectSerializer.serialize(memo, "string");
        }

        if (outOfBandAmount !== undefined) {
            localVarFormParams['out_of_band_amount'] = ObjectSerializer.serialize(outOfBandAmount, "number");
        }

        if (reason !== undefined) {
            localVarFormParams['reason'] = ObjectSerializer.serialize(reason, "string");
        }

        if (refund !== undefined) {
            localVarFormParams['refund'] = ObjectSerializer.serialize(refund, "string");
        }

        if (refundAmount !== undefined) {
            localVarFormParams['refund_amount'] = ObjectSerializer.serialize(refundAmount, "number");
        }

        if (shippingCost !== undefined) {
            localVarFormParams['shipping_cost'] = ObjectSerializer.serialize(shippingCost, "CreditNoteShippingCost");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing credit note.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     * @param memo Credit note memo.
     */
    public async postCreditNotesId (id: string, expand?: Array<string>, memo?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNote;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postCreditNotesId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (memo !== undefined) {
            localVarFormParams['memo'] = ObjectSerializer.serialize(memo, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Marks a credit note as void. Learn more about <a href=\"/docs/billing/invoices/credit-notes#voiding\">voiding credit notes</a>.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postCreditNotesIdVoid (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CreditNote;  }> {
        const localVarPath = this.basePath + '/v1/credit_notes/{id}/void'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postCreditNotesIdVoid.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CreditNote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CreditNote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new customer object.</p>
     * @param address 
     * @param balance An integer amount in cents (or local equivalent) that represents the customer\\\&#39;s current balance, which affect the customer\\\&#39;s future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
     * @param cashBalance 
     * @param coupon 
     * @param description An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
     * @param email Customer\\\&#39;s email address. It\\\&#39;s displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoicePrefix The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
     * @param invoiceSettings 
     * @param metadata 
     * @param name The customer\\\&#39;s full name or business name.
     * @param nextInvoiceSequence The sequence to be used on the customer\\\&#39;s next invoice. Defaults to 1.
     * @param paymentMethod 
     * @param phone The customer\\\&#39;s phone number.
     * @param preferredLocales Customer\\\&#39;s preferred languages, ordered by preference.
     * @param promotionCode The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
     * @param shipping 
     * @param source 
     * @param tax 
     * @param taxExempt The customer\\\&#39;s tax exemption. One of &#x60;none&#x60;, &#x60;exempt&#x60;, or &#x60;reverse&#x60;.
     * @param taxIdData The customer\\\&#39;s tax IDs.
     * @param testClock ID of the test clock to attach to the customer.
     * @param validate 
     */
    public async postCustomers (address?: PostCustomersRequestAddress, balance?: number, cashBalance?: CashBalanceParam, coupon?: string, description?: string, email?: string, expand?: Array<string>, invoicePrefix?: string, invoiceSettings?: CustomerParam, metadata?: IndividualSpecsMetadata, name?: string, nextInvoiceSequence?: number, paymentMethod?: string, phone?: string, preferredLocales?: Array<string>, promotionCode?: string, shipping?: PostCustomersRequestShipping, source?: string, tax?: TaxParam, taxExempt?: string, taxIdData?: Array<DataParams>, testClock?: string, validate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Customer;  }> {
        const localVarPath = this.basePath + '/v1/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (address !== undefined) {
            localVarFormParams['address'] = ObjectSerializer.serialize(address, "PostCustomersRequestAddress");
        }

        if (balance !== undefined) {
            localVarFormParams['balance'] = ObjectSerializer.serialize(balance, "number");
        }

        if (cashBalance !== undefined) {
            localVarFormParams['cash_balance'] = ObjectSerializer.serialize(cashBalance, "CashBalanceParam");
        }

        if (coupon !== undefined) {
            localVarFormParams['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoicePrefix !== undefined) {
            localVarFormParams['invoice_prefix'] = ObjectSerializer.serialize(invoicePrefix, "string");
        }

        if (invoiceSettings !== undefined) {
            localVarFormParams['invoice_settings'] = ObjectSerializer.serialize(invoiceSettings, "CustomerParam");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (nextInvoiceSequence !== undefined) {
            localVarFormParams['next_invoice_sequence'] = ObjectSerializer.serialize(nextInvoiceSequence, "number");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (phone !== undefined) {
            localVarFormParams['phone'] = ObjectSerializer.serialize(phone, "string");
        }

        if (preferredLocales !== undefined) {
            localVarFormParams['preferred_locales'] = ObjectSerializer.serialize(preferredLocales, "Array<string>");
        }

        if (promotionCode !== undefined) {
            localVarFormParams['promotion_code'] = ObjectSerializer.serialize(promotionCode, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "PostCustomersRequestShipping");
        }

        if (source !== undefined) {
            localVarFormParams['source'] = ObjectSerializer.serialize(source, "string");
        }

        if (tax !== undefined) {
            localVarFormParams['tax'] = ObjectSerializer.serialize(tax, "TaxParam");
        }

        if (taxExempt !== undefined) {
            localVarFormParams['tax_exempt'] = ObjectSerializer.serialize(taxExempt, "string");
        }

        if (taxIdData !== undefined) {
            localVarFormParams['tax_id_data'] = ObjectSerializer.serialize(taxIdData, "Array<DataParams>");
        }

        if (testClock !== undefined) {
            localVarFormParams['test_clock'] = ObjectSerializer.serialize(testClock, "string");
        }

        if (validate !== undefined) {
            localVarFormParams['validate'] = ObjectSerializer.serialize(validate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Customer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Customer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified customer by setting the values of the parameters passed. Any parameters not provided will be left unchanged. For example, if you pass the <strong>source</strong> parameter, that becomes the customer’s active source (e.g., a card) to be used for all charges in the future. When you update a customer to a new valid card source by passing the <strong>source</strong> parameter: for each of the customer’s current subscriptions, if the subscription bills automatically and is in the <code>past_due</code> state, then the latest open invoice for the subscription with automatic collection enabled will be retried. This retry will not count as an automatic retry, and will not affect the next regularly scheduled payment for the invoice. Changing the <strong>default_source</strong> for a customer will not trigger this behavior.</p>  <p>This request accepts mostly the same arguments as the customer creation call.</p>
     * @param customer 
     * @param address 
     * @param balance An integer amount in cents (or local equivalent) that represents the customer\\\&#39;s current balance, which affect the customer\\\&#39;s future invoices. A negative amount represents a credit that decreases the amount due on an invoice; a positive amount increases the amount due on an invoice.
     * @param cashBalance 
     * @param coupon 
     * @param defaultSource If you are using payment methods created via the PaymentMethods API, see the [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/update#update_customer-invoice_settings-default_payment_method) parameter.  Provide the ID of a payment source already attached to this customer to make it this customer\\\&#39;s default payment source.  If you want to add a new payment source and make it the default, see the [source](https://stripe.com/docs/api/customers/update#update_customer-source) property.
     * @param description An arbitrary string that you can attach to a customer object. It is displayed alongside the customer in the dashboard.
     * @param email Customer\\\&#39;s email address. It\\\&#39;s displayed alongside the customer in your dashboard and can be useful for searching and tracking. This may be up to *512 characters*.
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoicePrefix The prefix for the customer used to generate unique invoice numbers. Must be 3–12 uppercase letters or numbers.
     * @param invoiceSettings 
     * @param metadata 
     * @param name The customer\\\&#39;s full name or business name.
     * @param nextInvoiceSequence The sequence to be used on the customer\\\&#39;s next invoice. Defaults to 1.
     * @param phone The customer\\\&#39;s phone number.
     * @param preferredLocales Customer\\\&#39;s preferred languages, ordered by preference.
     * @param promotionCode The API ID of a promotion code to apply to the customer. The customer will have a discount applied on all recurring payments. Charges you create through the API will not have the discount.
     * @param shipping 
     * @param source 
     * @param tax 
     * @param taxExempt The customer\\\&#39;s tax exemption. One of &#x60;none&#x60;, &#x60;exempt&#x60;, or &#x60;reverse&#x60;.
     * @param validate 
     */
    public async postCustomersCustomer (customer: string, address?: PostCustomersRequestAddress, balance?: number, cashBalance?: CashBalanceParam, coupon?: string, defaultSource?: string, description?: string, email?: string, expand?: Array<string>, invoicePrefix?: string, invoiceSettings?: CustomerParam, metadata?: IndividualSpecsMetadata, name?: string, nextInvoiceSequence?: number, phone?: string, preferredLocales?: Array<string>, promotionCode?: string, shipping?: PostCustomersRequestShipping, source?: string, tax?: TaxParam, taxExempt?: string, validate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Customer;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (address !== undefined) {
            localVarFormParams['address'] = ObjectSerializer.serialize(address, "PostCustomersRequestAddress");
        }

        if (balance !== undefined) {
            localVarFormParams['balance'] = ObjectSerializer.serialize(balance, "number");
        }

        if (cashBalance !== undefined) {
            localVarFormParams['cash_balance'] = ObjectSerializer.serialize(cashBalance, "CashBalanceParam");
        }

        if (coupon !== undefined) {
            localVarFormParams['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (defaultSource !== undefined) {
            localVarFormParams['default_source'] = ObjectSerializer.serialize(defaultSource, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoicePrefix !== undefined) {
            localVarFormParams['invoice_prefix'] = ObjectSerializer.serialize(invoicePrefix, "string");
        }

        if (invoiceSettings !== undefined) {
            localVarFormParams['invoice_settings'] = ObjectSerializer.serialize(invoiceSettings, "CustomerParam");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (nextInvoiceSequence !== undefined) {
            localVarFormParams['next_invoice_sequence'] = ObjectSerializer.serialize(nextInvoiceSequence, "number");
        }

        if (phone !== undefined) {
            localVarFormParams['phone'] = ObjectSerializer.serialize(phone, "string");
        }

        if (preferredLocales !== undefined) {
            localVarFormParams['preferred_locales'] = ObjectSerializer.serialize(preferredLocales, "Array<string>");
        }

        if (promotionCode !== undefined) {
            localVarFormParams['promotion_code'] = ObjectSerializer.serialize(promotionCode, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "PostCustomersRequestShipping");
        }

        if (source !== undefined) {
            localVarFormParams['source'] = ObjectSerializer.serialize(source, "string");
        }

        if (tax !== undefined) {
            localVarFormParams['tax'] = ObjectSerializer.serialize(tax, "TaxParam");
        }

        if (taxExempt !== undefined) {
            localVarFormParams['tax_exempt'] = ObjectSerializer.serialize(taxExempt, "string");
        }

        if (validate !== undefined) {
            localVarFormParams['validate'] = ObjectSerializer.serialize(validate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Customer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Customer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an immutable transaction that updates the customer’s credit <a href=\"/docs/billing/customer/balance\">balance</a>.</p>
     * @param customer 
     * @param amount The integer amount in **cents (or local equivalent)** to apply to the customer\\\&#39;s credit balance.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies). Specifies the [&#x60;invoice_credit_balance&#x60;](https://stripe.com/docs/api/customers/object#customer_object-invoice_credit_balance) that this transaction will apply to. If the customer\\\&#39;s &#x60;currency&#x60; is not set, it will be updated to this value.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postCustomersCustomerBalanceTransactions (customer: string, amount: number, currency: string, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransaction;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/balance_transactions'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerBalanceTransactions.');
        }

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postCustomersCustomerBalanceTransactions.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postCustomersCustomerBalanceTransactions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerBalanceTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Most credit balance transaction fields are immutable, but you may update its <code>description</code> and <code>metadata</code>.</p>
     * @param customer 
     * @param transaction 
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postCustomersCustomerBalanceTransactionsTransaction (customer: string, transaction: string, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransaction;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/balance_transactions/{transaction}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerBalanceTransactionsTransaction.');
        }

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling postCustomersCustomerBalanceTransactionsTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerBalanceTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerBalanceTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Changes the settings on a customer’s cash balance.</p>
     * @param customer 
     * @param expand Specifies which fields in the response should be expanded.
     * @param settings 
     */
    public async postCustomersCustomerCashBalance (customer: string, expand?: Array<string>, settings?: BalanceSettingsParam1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CashBalance;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/cash_balance'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerCashBalance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (settings !== undefined) {
            localVarFormParams['settings'] = ObjectSerializer.serialize(settings, "BalanceSettingsParam1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CashBalance;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CashBalance");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Retrieve funding instructions for a customer cash balance. If funding instructions do not yet exist for the customer, new funding instructions will be created. If funding instructions have already been created for a given customer, the same funding instructions will be retrieved. In other words, we will return the same funding instructions each time.</p>
     * @param customer 
     * @param bankTransfer 
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param fundingType The &#x60;funding_type&#x60; to get the instructions for.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postCustomersCustomerFundingInstructions (customer: string, bankTransfer: BankTransferParams, currency: string, fundingType: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FundingInstructions;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/funding_instructions'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerFundingInstructions.');
        }

        // verify required parameter 'bankTransfer' is not null or undefined
        if (bankTransfer === null || bankTransfer === undefined) {
            throw new Error('Required parameter bankTransfer was null or undefined when calling postCustomersCustomerFundingInstructions.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postCustomersCustomerFundingInstructions.');
        }

        // verify required parameter 'fundingType' is not null or undefined
        if (fundingType === null || fundingType === undefined) {
            throw new Error('Required parameter fundingType was null or undefined when calling postCustomersCustomerFundingInstructions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (bankTransfer !== undefined) {
            localVarFormParams['bank_transfer'] = ObjectSerializer.serialize(bankTransfer, "BankTransferParams");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (fundingType !== undefined) {
            localVarFormParams['funding_type'] = ObjectSerializer.serialize(fundingType, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FundingInstructions;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FundingInstructions");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When you create a new credit card, you must specify a customer or recipient on which to create it.</p>  <p>If the card’s owner has no default card, then the new card will become the default. However, if the owner already has a default, then it will not change. To change the default, you should <a href=\"/docs/api#update_customer\">update the customer</a> to have a new <code>default_source</code>.</p>
     * @param customer 
     * @param source Please refer to full [documentation](https://stripe.com/docs/api) instead.
     * @param expand Specifies which fields in the response should be expanded.
     * @param validate 
     */
    public async postCustomersCustomerSources (customer: string, source: string, expand?: Array<string>, validate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentSource;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/sources'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerSources.');
        }

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling postCustomersCustomerSources.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (source !== undefined) {
            localVarFormParams['source'] = ObjectSerializer.serialize(source, "string");
        }

        if (validate !== undefined) {
            localVarFormParams['validate'] = ObjectSerializer.serialize(validate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentSource;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentSource");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Update a specified source for a given customer.</p>
     * @param customer 
     * @param id 
     * @param accountHolderName The name of the person or business that owns the bank account.
     * @param accountHolderType The type of entity that holds the account. This can be either &#x60;individual&#x60; or &#x60;company&#x60;.
     * @param addressCity City/District/Suburb/Town/Village.
     * @param addressCountry Billing address country, if provided when creating card.
     * @param addressLine1 Address line 1 (Street address/PO Box/Company name).
     * @param addressLine2 Address line 2 (Apartment/Suite/Unit/Building).
     * @param addressState State/County/Province/Region.
     * @param addressZip ZIP or postal code.
     * @param expMonth Two digit number representing the card’s expiration month.
     * @param expYear Four digit number representing the card’s expiration year.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param name Cardholder name.
     * @param owner 
     */
    public async postCustomersCustomerSourcesId (customer: string, id: string, accountHolderName?: string, accountHolderType?: string, addressCity?: string, addressCountry?: string, addressLine1?: string, addressLine2?: string, addressState?: string, addressZip?: string, expMonth?: string, expYear?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, name?: string, owner?: Owner, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PostCustomersCustomerSourcesId200Response;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/sources/{id}'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerSourcesId.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postCustomersCustomerSourcesId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountHolderName !== undefined) {
            localVarFormParams['account_holder_name'] = ObjectSerializer.serialize(accountHolderName, "string");
        }

        if (accountHolderType !== undefined) {
            localVarFormParams['account_holder_type'] = ObjectSerializer.serialize(accountHolderType, "string");
        }

        if (addressCity !== undefined) {
            localVarFormParams['address_city'] = ObjectSerializer.serialize(addressCity, "string");
        }

        if (addressCountry !== undefined) {
            localVarFormParams['address_country'] = ObjectSerializer.serialize(addressCountry, "string");
        }

        if (addressLine1 !== undefined) {
            localVarFormParams['address_line1'] = ObjectSerializer.serialize(addressLine1, "string");
        }

        if (addressLine2 !== undefined) {
            localVarFormParams['address_line2'] = ObjectSerializer.serialize(addressLine2, "string");
        }

        if (addressState !== undefined) {
            localVarFormParams['address_state'] = ObjectSerializer.serialize(addressState, "string");
        }

        if (addressZip !== undefined) {
            localVarFormParams['address_zip'] = ObjectSerializer.serialize(addressZip, "string");
        }

        if (expMonth !== undefined) {
            localVarFormParams['exp_month'] = ObjectSerializer.serialize(expMonth, "string");
        }

        if (expYear !== undefined) {
            localVarFormParams['exp_year'] = ObjectSerializer.serialize(expYear, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (owner !== undefined) {
            localVarFormParams['owner'] = ObjectSerializer.serialize(owner, "Owner");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PostCustomersCustomerSourcesId200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PostCustomersCustomerSourcesId200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Verify a specified bank account for a given customer.</p>
     * @param customer 
     * @param id 
     * @param amounts Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postCustomersCustomerSourcesIdVerify (customer: string, id: string, amounts?: Array<number>, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: BankAccount;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/sources/{id}/verify'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerSourcesIdVerify.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postCustomersCustomerSourcesIdVerify.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amounts !== undefined) {
            localVarFormParams['amounts'] = ObjectSerializer.serialize(amounts, "Array<number>");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: BankAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "BankAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new <code>TaxID</code> object for a customer.</p>
     * @param customer 
     * @param type Type of the tax ID, one of &#x60;ae_trn&#x60;, &#x60;au_abn&#x60;, &#x60;au_arn&#x60;, &#x60;bg_uic&#x60;, &#x60;br_cnpj&#x60;, &#x60;br_cpf&#x60;, &#x60;ca_bn&#x60;, &#x60;ca_gst_hst&#x60;, &#x60;ca_pst_bc&#x60;, &#x60;ca_pst_mb&#x60;, &#x60;ca_pst_sk&#x60;, &#x60;ca_qst&#x60;, &#x60;ch_vat&#x60;, &#x60;cl_tin&#x60;, &#x60;eg_tin&#x60;, &#x60;es_cif&#x60;, &#x60;eu_oss_vat&#x60;, &#x60;eu_vat&#x60;, &#x60;gb_vat&#x60;, &#x60;ge_vat&#x60;, &#x60;hk_br&#x60;, &#x60;hu_tin&#x60;, &#x60;id_npwp&#x60;, &#x60;il_vat&#x60;, &#x60;in_gst&#x60;, &#x60;is_vat&#x60;, &#x60;jp_cn&#x60;, &#x60;jp_rn&#x60;, &#x60;jp_trn&#x60;, &#x60;ke_pin&#x60;, &#x60;kr_brn&#x60;, &#x60;li_uid&#x60;, &#x60;mx_rfc&#x60;, &#x60;my_frp&#x60;, &#x60;my_itn&#x60;, &#x60;my_sst&#x60;, &#x60;no_vat&#x60;, &#x60;nz_gst&#x60;, &#x60;ph_tin&#x60;, &#x60;ru_inn&#x60;, &#x60;ru_kpp&#x60;, &#x60;sa_vat&#x60;, &#x60;sg_gst&#x60;, &#x60;sg_uen&#x60;, &#x60;si_tin&#x60;, &#x60;th_vat&#x60;, &#x60;tr_tin&#x60;, &#x60;tw_vat&#x60;, &#x60;ua_vat&#x60;, &#x60;us_ein&#x60;, or &#x60;za_vat&#x60;
     * @param value Value of the tax ID.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postCustomersCustomerTaxIds (customer: string, type: string, value: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxId;  }> {
        const localVarPath = this.basePath + '/v1/customers/{customer}/tax_ids'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postCustomersCustomerTaxIds.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling postCustomersCustomerTaxIds.');
        }

        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling postCustomersCustomerTaxIds.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (value !== undefined) {
            localVarFormParams['value'] = ObjectSerializer.serialize(value, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxId;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxId");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When you get a dispute, contacting your customer is always the best first step. If that doesn’t work, you can submit evidence to help us resolve the dispute in your favor. You can do this in your <a href=\"https://dashboard.stripe.com/disputes\">dashboard</a>, but if you prefer, you can use the API to submit evidence programmatically.</p>  <p>Depending on your dispute type, different evidence fields will give you a better chance of winning your dispute. To figure out which evidence fields to provide, see our <a href=\"/docs/disputes/categories\">guide to dispute types</a>.</p>
     * @param dispute 
     * @param evidence 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param submit Whether to immediately submit evidence to the bank. If &#x60;false&#x60;, evidence is staged on the dispute. Staged evidence is visible in the API and Dashboard, and can be submitted to the bank by making another request with this attribute set to &#x60;true&#x60; (the default).
     */
    public async postDisputesDispute (dispute: string, evidence?: DisputeEvidenceParams, expand?: Array<string>, metadata?: IndividualSpecsMetadata, submit?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Dispute;  }> {
        const localVarPath = this.basePath + '/v1/disputes/{dispute}'
            .replace('{' + 'dispute' + '}', encodeURIComponent(String(dispute)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'dispute' is not null or undefined
        if (dispute === null || dispute === undefined) {
            throw new Error('Required parameter dispute was null or undefined when calling postDisputesDispute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (evidence !== undefined) {
            localVarFormParams['evidence'] = ObjectSerializer.serialize(evidence, "DisputeEvidenceParams");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (submit !== undefined) {
            localVarFormParams['submit'] = ObjectSerializer.serialize(submit, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Dispute;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Dispute");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Closing the dispute for a charge indicates that you do not have any evidence to submit and are essentially dismissing the dispute, acknowledging it as lost.</p>  <p>The status of the dispute will change from <code>needs_response</code> to <code>lost</code>. <em>Closing a dispute is irreversible</em>.</p>
     * @param dispute 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postDisputesDisputeClose (dispute: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Dispute;  }> {
        const localVarPath = this.basePath + '/v1/disputes/{dispute}/close'
            .replace('{' + 'dispute' + '}', encodeURIComponent(String(dispute)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'dispute' is not null or undefined
        if (dispute === null || dispute === undefined) {
            throw new Error('Required parameter dispute was null or undefined when calling postDisputesDisputeClose.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Dispute;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Dispute");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a short-lived API key for a given resource.</p>
     * @param customer The ID of the Customer you\\\&#39;d like to modify using the resulting ephemeral key.
     * @param expand Specifies which fields in the response should be expanded.
     * @param issuingCard The ID of the Issuing Card you\\\&#39;d like to access using the resulting ephemeral key.
     * @param verificationSession The ID of the Identity VerificationSession you\\\&#39;d like to access using the resulting ephemeral key
     */
    public async postEphemeralKeys (customer?: string, expand?: Array<string>, issuingCard?: string, verificationSession?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: EphemeralKey;  }> {
        const localVarPath = this.basePath + '/v1/ephemeral_keys';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (issuingCard !== undefined) {
            localVarFormParams['issuing_card'] = ObjectSerializer.serialize(issuingCard, "string");
        }

        if (verificationSession !== undefined) {
            localVarFormParams['verification_session'] = ObjectSerializer.serialize(verificationSession, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: EphemeralKey;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "EphemeralKey");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new file link object.</p>
     * @param file The ID of the file. The file\\\&#39;s &#x60;purpose&#x60; must be one of the following: &#x60;business_icon&#x60;, &#x60;business_logo&#x60;, &#x60;customer_signature&#x60;, &#x60;dispute_evidence&#x60;, &#x60;finance_report_run&#x60;, &#x60;identity_document_downloadable&#x60;, &#x60;pci_document&#x60;, &#x60;selfie&#x60;, &#x60;sigma_scheduled_query&#x60;, &#x60;tax_document_user_upload&#x60;, or &#x60;terminal_reader_splashscreen&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt A future timestamp after which the link will no longer be usable.
     * @param metadata 
     */
    public async postFileLinks (file: string, expand?: Array<string>, expiresAt?: number, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileLink;  }> {
        const localVarPath = this.basePath + '/v1/file_links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling postFileLinks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "number");
        }

        if (file !== undefined) {
            localVarFormParams['file'] = ObjectSerializer.serialize(file, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing file link object. Expired links can no longer be updated.</p>
     * @param link 
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt 
     * @param metadata 
     */
    public async postFileLinksLink (link: string, expand?: Array<string>, expiresAt?: PostFileLinksLinkRequestExpiresAt, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FileLink;  }> {
        const localVarPath = this.basePath + '/v1/file_links/{link}'
            .replace('{' + 'link' + '}', encodeURIComponent(String(link)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'link' is not null or undefined
        if (link === null || link === undefined) {
            throw new Error('Required parameter link was null or undefined when calling postFileLinksLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "PostFileLinksLinkRequestExpiresAt");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FileLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FileLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>To upload a file to Stripe, you’ll need to send a request of type <code>multipart/form-data</code>. The request should contain the file you would like to upload, as well as the parameters for creating a file.</p>  <p>All of Stripe’s officially supported Client libraries should have support for sending <code>multipart/form-data</code>.</p>
     * @param file A file to upload. The file should follow the specifications of RFC 2388 (which defines file transfers for the &#x60;multipart/form-data&#x60; protocol).
     * @param purpose The [purpose](https://stripe.com/docs/file-upload#uploading-a-file) of the uploaded file.
     * @param expand Specifies which fields in the response should be expanded.
     * @param fileLinkData 
     */
    public async postFiles (file: string, purpose: string, expand?: Array<string>, fileLinkData?: FileLinkCreationParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RequestFile;  }> {
        const localVarPath = this.basePath + '/v1/files';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'file' is not null or undefined
        if (file === null || file === undefined) {
            throw new Error('Required parameter file was null or undefined when calling postFiles.');
        }

        // verify required parameter 'purpose' is not null or undefined
        if (purpose === null || purpose === undefined) {
            throw new Error('Required parameter purpose was null or undefined when calling postFiles.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (file !== undefined) {
            localVarFormParams['file'] = ObjectSerializer.serialize(file, "string");
        }

        if (fileLinkData !== undefined) {
            localVarFormParams['file_link_data'] = ObjectSerializer.serialize(fileLinkData, "FileLinkCreationParams");
        }

        if (purpose !== undefined) {
            localVarFormParams['purpose'] = ObjectSerializer.serialize(purpose, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RequestFile;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RequestFile");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Disables your access to a Financial Connections <code>Account</code>. You will no longer be able to access data associated with the account (e.g. balances, transactions).</p>
     * @param account 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postFinancialConnectionsAccountsAccountDisconnect (account: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FinancialConnectionsAccount;  }> {
        const localVarPath = this.basePath + '/v1/financial_connections/accounts/{account}/disconnect'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postFinancialConnectionsAccountsAccountDisconnect.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FinancialConnectionsAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FinancialConnectionsAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Refreshes the data associated with a Financial Connections <code>Account</code>.</p>
     * @param account 
     * @param features The list of account features that you would like to refresh.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postFinancialConnectionsAccountsAccountRefresh (account: string, features: Array<string>, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FinancialConnectionsAccount;  }> {
        const localVarPath = this.basePath + '/v1/financial_connections/accounts/{account}/refresh'
            .replace('{' + 'account' + '}', encodeURIComponent(String(account)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling postFinancialConnectionsAccountsAccountRefresh.');
        }

        // verify required parameter 'features' is not null or undefined
        if (features === null || features === undefined) {
            throw new Error('Required parameter features was null or undefined when calling postFinancialConnectionsAccountsAccountRefresh.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (features !== undefined) {
            localVarFormParams['features'] = ObjectSerializer.serialize(features, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FinancialConnectionsAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FinancialConnectionsAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>To launch the Financial Connections authorization flow, create a <code>Session</code>. The session’s <code>client_secret</code> can be used to launch the flow using Stripe.js.</p>
     * @param accountHolder 
     * @param permissions List of data features that you would like to request access to.  Possible values are &#x60;balances&#x60;, &#x60;transactions&#x60;, &#x60;ownership&#x60;, and &#x60;payment_method&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     * @param filters 
     * @param returnUrl For webview integrations only. Upon completing OAuth login in the native browser, the user will be redirected to this URL to return to your app.
     */
    public async postFinancialConnectionsSessions (accountHolder: AccountholderParams1, permissions: Array<string>, expand?: Array<string>, filters?: FiltersParams, returnUrl?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: FinancialConnectionsSession;  }> {
        const localVarPath = this.basePath + '/v1/financial_connections/sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'accountHolder' is not null or undefined
        if (accountHolder === null || accountHolder === undefined) {
            throw new Error('Required parameter accountHolder was null or undefined when calling postFinancialConnectionsSessions.');
        }

        // verify required parameter 'permissions' is not null or undefined
        if (permissions === null || permissions === undefined) {
            throw new Error('Required parameter permissions was null or undefined when calling postFinancialConnectionsSessions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountHolder !== undefined) {
            localVarFormParams['account_holder'] = ObjectSerializer.serialize(accountHolder, "AccountholderParams1");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (filters !== undefined) {
            localVarFormParams['filters'] = ObjectSerializer.serialize(filters, "FiltersParams");
        }

        if (permissions !== undefined) {
            localVarFormParams['permissions'] = ObjectSerializer.serialize(permissions, "Array<string>");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: FinancialConnectionsSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "FinancialConnectionsSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a VerificationSession object.</p>  <p>After the VerificationSession is created, display a verification modal using the session <code>client_secret</code> or send your users to the session’s <code>url</code>.</p>  <p>If your API key is in test mode, verification checks won’t actually process, though everything else will occur as if in live mode.</p>  <p>Related guide: <a href=\"/docs/identity/verify-identity-documents\">Verify your users’ identity documents</a>.</p>
     * @param type The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
     * @param expand Specifies which fields in the response should be expanded.
     * @param options 
     * @param returnUrl The URL that the user will be redirected to upon completing the verification flow.
     */
    public async postIdentityVerificationSessions (type: string, expand?: Array<string>, options?: SessionOptionsParam, returnUrl?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling postIdentityVerificationSessions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (options !== undefined) {
            localVarFormParams['options'] = ObjectSerializer.serialize(options, "SessionOptionsParam");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IdentityVerificationSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a VerificationSession object.</p>  <p>When the session status is <code>requires_input</code>, you can use this method to update the verification check and options.</p>
     * @param session 
     * @param expand Specifies which fields in the response should be expanded.
     * @param options 
     * @param type The type of [verification check](https://stripe.com/docs/identity/verification-checks) to be performed.
     */
    public async postIdentityVerificationSessionsSession (session: string, expand?: Array<string>, options?: SessionOptionsParam, type?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_sessions/{session}'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling postIdentityVerificationSessionsSession.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (options !== undefined) {
            localVarFormParams['options'] = ObjectSerializer.serialize(options, "SessionOptionsParam");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IdentityVerificationSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A VerificationSession object can be canceled when it is in <code>requires_input</code> <a href=\"/docs/identity/how-sessions-work\">status</a>.</p>  <p>Once canceled, future submission attempts are disabled. This cannot be undone. <a href=\"/docs/identity/verification-sessions#cancel\">Learn more</a>.</p>
     * @param session 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postIdentityVerificationSessionsSessionCancel (session: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_sessions/{session}/cancel'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling postIdentityVerificationSessionsSessionCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IdentityVerificationSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Redact a VerificationSession to remove all collected information from Stripe. This will redact the VerificationSession and all objects related to it, including VerificationReports, Events, request logs, etc.</p>  <p>A VerificationSession object can be redacted when it is in <code>requires_input</code> or <code>verified</code> <a href=\"/docs/identity/how-sessions-work\">status</a>. Redacting a VerificationSession in <code>requires_action</code> state will automatically cancel it.</p>  <p>The redaction process may take up to four days. When the redaction process is in progress, the VerificationSession’s <code>redaction.status</code> field will be set to <code>processing</code>; when the process is finished, it will change to <code>redacted</code> and an <code>identity.verification_session.redacted</code> event will be emitted.</p>  <p>Redaction is irreversible. Redacted objects are still accessible in the Stripe API, but all the fields that contain personal data will be replaced by the string <code>[redacted]</code> or a similar placeholder. The <code>metadata</code> field will also be erased. Redacted objects cannot be updated or used for any purpose.</p>  <p><a href=\"/docs/identity/verification-sessions#redact\">Learn more</a>.</p>
     * @param session 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postIdentityVerificationSessionsSessionRedact (session: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }> {
        const localVarPath = this.basePath + '/v1/identity/verification_sessions/{session}/redact'
            .replace('{' + 'session' + '}', encodeURIComponent(String(session)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'session' is not null or undefined
        if (session === null || session === undefined) {
            throw new Error('Required parameter session was null or undefined when calling postIdentityVerificationSessionsSessionRedact.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IdentityVerificationSession;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IdentityVerificationSession");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an item to be added to a draft invoice (up to 250 items per invoice). If no invoice is specified, the item will be on the next invoice created for the customer specified.</p>
     * @param customer The ID of the customer who will be billed when this invoice item is billed.
     * @param amount The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. Passing in a negative &#x60;amount&#x60; will reduce the &#x60;amount_due&#x60; on the invoice.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param description An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
     * @param discountable Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items.
     * @param discounts 
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoice The ID of an existing invoice to add this invoice item to. When left blank, the invoice item will be added to the next upcoming scheduled invoice. This is useful when adding invoice items in response to an invoice.created webhook. You can only add invoice items to draft invoices and there is a maximum of 250 items per invoice.
     * @param metadata 
     * @param period 
     * @param price The ID of the price object.
     * @param priceData 
     * @param quantity Non-negative integer. The quantity of units for the invoice item.
     * @param subscription The ID of a subscription to add this invoice item to. When left blank, the invoice item will be be added to the next upcoming scheduled invoice. When set, scheduled invoices for subscriptions other than the specified subscription will ignore the invoice item. Use this when you want to express that an invoice item has been accrued within the context of a particular subscription.
     * @param taxBehavior Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of &#x60;inclusive&#x60;, &#x60;exclusive&#x60;, or &#x60;unspecified&#x60;. Once specified as either &#x60;inclusive&#x60; or &#x60;exclusive&#x60;, it cannot be changed.
     * @param taxCode 
     * @param taxRates The tax rates which apply to the invoice item. When set, the &#x60;default_tax_rates&#x60; on the invoice do not apply to this invoice item.
     * @param unitAmount The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This &#x60;unit_amount&#x60; will be multiplied by the quantity to get the full amount. Passing in a negative &#x60;unit_amount&#x60; will reduce the &#x60;amount_due&#x60; on the invoice.
     * @param unitAmountDecimal Same as &#x60;unit_amount&#x60;, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of &#x60;unit_amount&#x60; and &#x60;unit_amount_decimal&#x60; can be set.
     */
    public async postInvoiceitems (customer: string, amount?: number, currency?: string, description?: string, discountable?: boolean, discounts?: PostInvoiceitemsRequestDiscounts, expand?: Array<string>, invoice?: string, metadata?: IndividualSpecsMetadata, period?: Period1, price?: string, priceData?: OneTimePriceData, quantity?: number, subscription?: string, taxBehavior?: string, taxCode?: PostInvoiceitemsRequestTaxCode, taxRates?: Array<string>, unitAmount?: number, unitAmountDecimal?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoiceitem;  }> {
        const localVarPath = this.basePath + '/v1/invoiceitems';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postInvoiceitems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (discountable !== undefined) {
            localVarFormParams['discountable'] = ObjectSerializer.serialize(discountable, "boolean");
        }

        if (discounts !== undefined) {
            localVarFormParams['discounts'] = ObjectSerializer.serialize(discounts, "PostInvoiceitemsRequestDiscounts");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoice !== undefined) {
            localVarFormParams['invoice'] = ObjectSerializer.serialize(invoice, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (period !== undefined) {
            localVarFormParams['period'] = ObjectSerializer.serialize(period, "Period1");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "string");
        }

        if (priceData !== undefined) {
            localVarFormParams['price_data'] = ObjectSerializer.serialize(priceData, "OneTimePriceData");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (subscription !== undefined) {
            localVarFormParams['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        if (taxBehavior !== undefined) {
            localVarFormParams['tax_behavior'] = ObjectSerializer.serialize(taxBehavior, "string");
        }

        if (taxCode !== undefined) {
            localVarFormParams['tax_code'] = ObjectSerializer.serialize(taxCode, "PostInvoiceitemsRequestTaxCode");
        }

        if (taxRates !== undefined) {
            localVarFormParams['tax_rates'] = ObjectSerializer.serialize(taxRates, "Array<string>");
        }

        if (unitAmount !== undefined) {
            localVarFormParams['unit_amount'] = ObjectSerializer.serialize(unitAmount, "number");
        }

        if (unitAmountDecimal !== undefined) {
            localVarFormParams['unit_amount_decimal'] = ObjectSerializer.serialize(unitAmountDecimal, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoiceitem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoiceitem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the amount or description of an invoice item on an upcoming invoice. Updating an invoice item is only possible before the invoice it’s attached to is closed.</p>
     * @param invoiceitem 
     * @param amount The integer amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. If you want to apply a credit to the customer\\\&#39;s account, pass a negative amount.
     * @param description An arbitrary string which you can attach to the invoice item. The description is displayed in the invoice for easy tracking.
     * @param discountable Controls whether discounts apply to this invoice item. Defaults to false for prorations or negative invoice items, and true for all other invoice items. Cannot be set to true for prorations.
     * @param discounts 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param period 
     * @param price The ID of the price object.
     * @param priceData 
     * @param quantity Non-negative integer. The quantity of units for the invoice item.
     * @param taxBehavior Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of &#x60;inclusive&#x60;, &#x60;exclusive&#x60;, or &#x60;unspecified&#x60;. Once specified as either &#x60;inclusive&#x60; or &#x60;exclusive&#x60;, it cannot be changed.
     * @param taxCode 
     * @param taxRates 
     * @param unitAmount The integer unit amount in cents (or local equivalent) of the charge to be applied to the upcoming invoice. This unit_amount will be multiplied by the quantity to get the full amount. If you want to apply a credit to the customer\\\&#39;s account, pass a negative unit_amount.
     * @param unitAmountDecimal Same as &#x60;unit_amount&#x60;, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of &#x60;unit_amount&#x60; and &#x60;unit_amount_decimal&#x60; can be set.
     */
    public async postInvoiceitemsInvoiceitem (invoiceitem: string, amount?: number, description?: string, discountable?: boolean, discounts?: PostInvoiceitemsInvoiceitemRequestDiscounts, expand?: Array<string>, metadata?: IndividualSpecsMetadata, period?: Period1, price?: string, priceData?: OneTimePriceData, quantity?: number, taxBehavior?: string, taxCode?: PostInvoiceitemsRequestTaxCode, taxRates?: PostInvoiceitemsInvoiceitemRequestTaxRates, unitAmount?: number, unitAmountDecimal?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoiceitem;  }> {
        const localVarPath = this.basePath + '/v1/invoiceitems/{invoiceitem}'
            .replace('{' + 'invoiceitem' + '}', encodeURIComponent(String(invoiceitem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceitem' is not null or undefined
        if (invoiceitem === null || invoiceitem === undefined) {
            throw new Error('Required parameter invoiceitem was null or undefined when calling postInvoiceitemsInvoiceitem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (discountable !== undefined) {
            localVarFormParams['discountable'] = ObjectSerializer.serialize(discountable, "boolean");
        }

        if (discounts !== undefined) {
            localVarFormParams['discounts'] = ObjectSerializer.serialize(discounts, "PostInvoiceitemsInvoiceitemRequestDiscounts");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (period !== undefined) {
            localVarFormParams['period'] = ObjectSerializer.serialize(period, "Period1");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "string");
        }

        if (priceData !== undefined) {
            localVarFormParams['price_data'] = ObjectSerializer.serialize(priceData, "OneTimePriceData");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (taxBehavior !== undefined) {
            localVarFormParams['tax_behavior'] = ObjectSerializer.serialize(taxBehavior, "string");
        }

        if (taxCode !== undefined) {
            localVarFormParams['tax_code'] = ObjectSerializer.serialize(taxCode, "PostInvoiceitemsRequestTaxCode");
        }

        if (taxRates !== undefined) {
            localVarFormParams['tax_rates'] = ObjectSerializer.serialize(taxRates, "PostInvoiceitemsInvoiceitemRequestTaxRates");
        }

        if (unitAmount !== undefined) {
            localVarFormParams['unit_amount'] = ObjectSerializer.serialize(unitAmount, "number");
        }

        if (unitAmountDecimal !== undefined) {
            localVarFormParams['unit_amount_decimal'] = ObjectSerializer.serialize(unitAmountDecimal, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoiceitem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoiceitem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>This endpoint creates a draft invoice for a given customer. The invoice remains a draft until you <a href=\"#finalize_invoice\">finalize</a> the invoice, which allows you to <a href=\"#pay_invoice\">pay</a> or <a href=\"#send_invoice\">send</a> the invoice to your customers.</p>
     * @param accountTaxIds 
     * @param applicationFeeAmount A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner\\\&#39;s Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
     * @param autoAdvance Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice. When &#x60;false&#x60;, the invoice\\\&#39;s state will not automatically advance without an explicit action.
     * @param automaticTax 
     * @param collectionMethod Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay this invoice using the default source attached to the customer. When sending an invoice, Stripe will email this invoice to the customer with payment instructions. Defaults to &#x60;charge_automatically&#x60;.
     * @param currency The currency to create this invoice in. Defaults to that of &#x60;customer&#x60; if not specified.
     * @param customFields 
     * @param customer The ID of the customer who will be billed.
     * @param daysUntilDue The number of days from when the invoice is created until it is due. Valid only for invoices where &#x60;collection_method&#x3D;send_invoice&#x60;.
     * @param defaultPaymentMethod ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription\\\&#39;s default payment method, if any, or to the default payment method in the customer\\\&#39;s invoice settings.
     * @param defaultSource ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription\\\&#39;s default source, if any, or to the customer\\\&#39;s default source.
     * @param defaultTaxRates The tax rates that will apply to any line item that does not have &#x60;tax_rates&#x60; set.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users. Referenced as \\\&#39;memo\\\&#39; in the Dashboard.
     * @param discounts 
     * @param dueDate The date on which payment for this invoice is due. Valid only for invoices where &#x60;collection_method&#x3D;send_invoice&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     * @param footer Footer to be displayed on the invoice.
     * @param fromInvoice 
     * @param metadata 
     * @param onBehalfOf The account (if any) for which the funds of the invoice payment are intended. If set, the invoice will be presented with the branding and support information of the specified account. See the [Invoices with Connect](https://stripe.com/docs/billing/invoices/connect) documentation for details.
     * @param paymentSettings 
     * @param pendingInvoiceItemsBehavior How to handle pending invoice items on invoice creation. One of &#x60;include&#x60; or &#x60;exclude&#x60;. &#x60;include&#x60; will include any pending invoice items, and will create an empty draft invoice if no pending invoice items exist. &#x60;exclude&#x60; will always create an empty invoice draft regardless if there are pending invoice items or not. Defaults to &#x60;exclude&#x60; if the parameter is omitted.
     * @param renderingOptions 
     * @param shippingCost 
     * @param shippingDetails 
     * @param statementDescriptor Extra information about a charge for the customer\\\&#39;s credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default &#x60;statement_descriptor&#x60; will be set to the first subscription item\\\&#39;s product\\\&#39;s &#x60;statement_descriptor&#x60;.
     * @param subscription The ID of the subscription to invoice, if any. If set, the created invoice will only include pending invoice items for that subscription. The subscription\\\&#39;s billing cycle and regular subscription events won\\\&#39;t be affected.
     * @param transferData 
     */
    public async postInvoices (accountTaxIds?: PostInvoicesRequestAccountTaxIds, applicationFeeAmount?: number, autoAdvance?: boolean, automaticTax?: AutomaticTaxParam, collectionMethod?: string, currency?: string, customFields?: PostInvoicesRequestCustomFields, customer?: string, daysUntilDue?: number, defaultPaymentMethod?: string, defaultSource?: string, defaultTaxRates?: Array<string>, description?: string, discounts?: PostInvoicesRequestDiscounts, dueDate?: number, expand?: Array<string>, footer?: string, fromInvoice?: FromInvoice, metadata?: IndividualSpecsMetadata, onBehalfOf?: string, paymentSettings?: PaymentSettings, pendingInvoiceItemsBehavior?: string, renderingOptions?: PostInvoicesRequestRenderingOptions, shippingCost?: ShippingCost, shippingDetails?: RecipientShippingWithOptionalFieldsAddress, statementDescriptor?: string, subscription?: string, transferData?: TransferDataSpecs3, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountTaxIds !== undefined) {
            localVarFormParams['account_tax_ids'] = ObjectSerializer.serialize(accountTaxIds, "PostInvoicesRequestAccountTaxIds");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (autoAdvance !== undefined) {
            localVarFormParams['auto_advance'] = ObjectSerializer.serialize(autoAdvance, "boolean");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParam");
        }

        if (collectionMethod !== undefined) {
            localVarFormParams['collection_method'] = ObjectSerializer.serialize(collectionMethod, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customFields !== undefined) {
            localVarFormParams['custom_fields'] = ObjectSerializer.serialize(customFields, "PostInvoicesRequestCustomFields");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (daysUntilDue !== undefined) {
            localVarFormParams['days_until_due'] = ObjectSerializer.serialize(daysUntilDue, "number");
        }

        if (defaultPaymentMethod !== undefined) {
            localVarFormParams['default_payment_method'] = ObjectSerializer.serialize(defaultPaymentMethod, "string");
        }

        if (defaultSource !== undefined) {
            localVarFormParams['default_source'] = ObjectSerializer.serialize(defaultSource, "string");
        }

        if (defaultTaxRates !== undefined) {
            localVarFormParams['default_tax_rates'] = ObjectSerializer.serialize(defaultTaxRates, "Array<string>");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (discounts !== undefined) {
            localVarFormParams['discounts'] = ObjectSerializer.serialize(discounts, "PostInvoicesRequestDiscounts");
        }

        if (dueDate !== undefined) {
            localVarFormParams['due_date'] = ObjectSerializer.serialize(dueDate, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (footer !== undefined) {
            localVarFormParams['footer'] = ObjectSerializer.serialize(footer, "string");
        }

        if (fromInvoice !== undefined) {
            localVarFormParams['from_invoice'] = ObjectSerializer.serialize(fromInvoice, "FromInvoice");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        if (paymentSettings !== undefined) {
            localVarFormParams['payment_settings'] = ObjectSerializer.serialize(paymentSettings, "PaymentSettings");
        }

        if (pendingInvoiceItemsBehavior !== undefined) {
            localVarFormParams['pending_invoice_items_behavior'] = ObjectSerializer.serialize(pendingInvoiceItemsBehavior, "string");
        }

        if (renderingOptions !== undefined) {
            localVarFormParams['rendering_options'] = ObjectSerializer.serialize(renderingOptions, "PostInvoicesRequestRenderingOptions");
        }

        if (shippingCost !== undefined) {
            localVarFormParams['shipping_cost'] = ObjectSerializer.serialize(shippingCost, "ShippingCost");
        }

        if (shippingDetails !== undefined) {
            localVarFormParams['shipping_details'] = ObjectSerializer.serialize(shippingDetails, "RecipientShippingWithOptionalFieldsAddress");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (subscription !== undefined) {
            localVarFormParams['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataSpecs3");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Draft invoices are fully editable. Once an invoice is <a href=\"/docs/billing/invoices/workflow#finalized\">finalized</a>, monetary values, as well as <code>collection_method</code>, become uneditable.</p>  <p>If you would like to stop the Stripe Billing engine from automatically finalizing, reattempting payments on, sending reminders for, or <a href=\"/docs/billing/invoices/reconciliation\">automatically reconciling</a> invoices, pass <code>auto_advance=false</code>.</p>
     * @param invoice 
     * @param accountTaxIds 
     * @param applicationFeeAmount A fee in cents (or local equivalent) that will be applied to the invoice and transferred to the application owner\\\&#39;s Stripe account. The request must be made with an OAuth key or the Stripe-Account header in order to take an application fee. For more information, see the application fees [documentation](https://stripe.com/docs/billing/invoices/connect#collecting-fees).
     * @param autoAdvance Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/billing/invoices/workflow/#auto_advance) of the invoice.
     * @param automaticTax 
     * @param collectionMethod Either &#x60;charge_automatically&#x60; or &#x60;send_invoice&#x60;. This field can be updated only on &#x60;draft&#x60; invoices.
     * @param customFields 
     * @param daysUntilDue The number of days from which the invoice is created until it is due. Only valid for invoices where &#x60;collection_method&#x3D;send_invoice&#x60;. This field can only be updated on &#x60;draft&#x60; invoices.
     * @param defaultPaymentMethod ID of the default payment method for the invoice. It must belong to the customer associated with the invoice. If not set, defaults to the subscription\\\&#39;s default payment method, if any, or to the default payment method in the customer\\\&#39;s invoice settings.
     * @param defaultSource ID of the default payment source for the invoice. It must belong to the customer associated with the invoice and be in a chargeable state. If not set, defaults to the subscription\\\&#39;s default source, if any, or to the customer\\\&#39;s default source.
     * @param defaultTaxRates 
     * @param description An arbitrary string attached to the object. Often useful for displaying to users. Referenced as \\\&#39;memo\\\&#39; in the Dashboard.
     * @param discounts 
     * @param dueDate The date on which payment for this invoice is due. Only valid for invoices where &#x60;collection_method&#x3D;send_invoice&#x60;. This field can only be updated on &#x60;draft&#x60; invoices.
     * @param expand Specifies which fields in the response should be expanded.
     * @param footer Footer to be displayed on the invoice.
     * @param metadata 
     * @param onBehalfOf 
     * @param paymentSettings 
     * @param renderingOptions 
     * @param shippingCost 
     * @param shippingDetails 
     * @param statementDescriptor Extra information about a charge for the customer\\\&#39;s credit card statement. It must contain at least one letter. If not specified and this invoice is part of a subscription, the default &#x60;statement_descriptor&#x60; will be set to the first subscription item\\\&#39;s product\\\&#39;s &#x60;statement_descriptor&#x60;.
     * @param transferData 
     */
    public async postInvoicesInvoice (invoice: string, accountTaxIds?: PostInvoicesRequestAccountTaxIds, applicationFeeAmount?: number, autoAdvance?: boolean, automaticTax?: AutomaticTaxParam, collectionMethod?: string, customFields?: PostInvoicesInvoiceRequestCustomFields, daysUntilDue?: number, defaultPaymentMethod?: string, defaultSource?: string, defaultTaxRates?: PostInvoicesInvoiceRequestDefaultTaxRates, description?: string, discounts?: PostInvoicesInvoiceRequestDiscounts, dueDate?: number, expand?: Array<string>, footer?: string, metadata?: IndividualSpecsMetadata, onBehalfOf?: PostInvoicesInvoiceRequestOnBehalfOf, paymentSettings?: PaymentSettings, renderingOptions?: PostInvoicesRequestRenderingOptions, shippingCost?: PostInvoicesInvoiceRequestShippingCost, shippingDetails?: PostInvoicesInvoiceRequestShippingDetails, statementDescriptor?: string, transferData?: PostInvoicesInvoiceRequestTransferData, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling postInvoicesInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (accountTaxIds !== undefined) {
            localVarFormParams['account_tax_ids'] = ObjectSerializer.serialize(accountTaxIds, "PostInvoicesRequestAccountTaxIds");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (autoAdvance !== undefined) {
            localVarFormParams['auto_advance'] = ObjectSerializer.serialize(autoAdvance, "boolean");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParam");
        }

        if (collectionMethod !== undefined) {
            localVarFormParams['collection_method'] = ObjectSerializer.serialize(collectionMethod, "string");
        }

        if (customFields !== undefined) {
            localVarFormParams['custom_fields'] = ObjectSerializer.serialize(customFields, "PostInvoicesInvoiceRequestCustomFields");
        }

        if (daysUntilDue !== undefined) {
            localVarFormParams['days_until_due'] = ObjectSerializer.serialize(daysUntilDue, "number");
        }

        if (defaultPaymentMethod !== undefined) {
            localVarFormParams['default_payment_method'] = ObjectSerializer.serialize(defaultPaymentMethod, "string");
        }

        if (defaultSource !== undefined) {
            localVarFormParams['default_source'] = ObjectSerializer.serialize(defaultSource, "string");
        }

        if (defaultTaxRates !== undefined) {
            localVarFormParams['default_tax_rates'] = ObjectSerializer.serialize(defaultTaxRates, "PostInvoicesInvoiceRequestDefaultTaxRates");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (discounts !== undefined) {
            localVarFormParams['discounts'] = ObjectSerializer.serialize(discounts, "PostInvoicesInvoiceRequestDiscounts");
        }

        if (dueDate !== undefined) {
            localVarFormParams['due_date'] = ObjectSerializer.serialize(dueDate, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (footer !== undefined) {
            localVarFormParams['footer'] = ObjectSerializer.serialize(footer, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "PostInvoicesInvoiceRequestOnBehalfOf");
        }

        if (paymentSettings !== undefined) {
            localVarFormParams['payment_settings'] = ObjectSerializer.serialize(paymentSettings, "PaymentSettings");
        }

        if (renderingOptions !== undefined) {
            localVarFormParams['rendering_options'] = ObjectSerializer.serialize(renderingOptions, "PostInvoicesRequestRenderingOptions");
        }

        if (shippingCost !== undefined) {
            localVarFormParams['shipping_cost'] = ObjectSerializer.serialize(shippingCost, "PostInvoicesInvoiceRequestShippingCost");
        }

        if (shippingDetails !== undefined) {
            localVarFormParams['shipping_details'] = ObjectSerializer.serialize(shippingDetails, "PostInvoicesInvoiceRequestShippingDetails");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "PostInvoicesInvoiceRequestTransferData");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Stripe automatically finalizes drafts before sending and attempting payment on invoices. However, if you’d like to finalize a draft invoice manually, you can do so using this method.</p>
     * @param invoice 
     * @param autoAdvance Controls whether Stripe will perform [automatic collection](https://stripe.com/docs/invoicing/automatic-charging) of the invoice. When &#x60;false&#x60;, the invoice\\\&#39;s state will not automatically advance without an explicit action.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postInvoicesInvoiceFinalize (invoice: string, autoAdvance?: boolean, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}/finalize'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling postInvoicesInvoiceFinalize.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (autoAdvance !== undefined) {
            localVarFormParams['auto_advance'] = ObjectSerializer.serialize(autoAdvance, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Marking an invoice as uncollectible is useful for keeping track of bad debts that can be written off for accounting purposes.</p>
     * @param invoice 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postInvoicesInvoiceMarkUncollectible (invoice: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}/mark_uncollectible'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling postInvoicesInvoiceMarkUncollectible.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Stripe automatically creates and then attempts to collect payment on invoices for customers on subscriptions according to your <a href=\"https://dashboard.stripe.com/account/billing/automatic\">subscriptions settings</a>. However, if you’d like to attempt payment on an invoice out of the normal collection schedule or for some other reason, you can do so.</p>
     * @param invoice 
     * @param expand Specifies which fields in the response should be expanded.
     * @param forgive In cases where the source used to pay the invoice has insufficient funds, passing &#x60;forgive&#x3D;true&#x60; controls whether a charge should be attempted for the full amount available on the source, up to the amount to fully pay the invoice. This effectively forgives the difference between the amount available on the source and the amount due.   Passing &#x60;forgive&#x3D;false&#x60; will fail the charge if the source hasn\\\&#39;t been pre-funded with the right amount. An example for this case is with ACH Credit Transfers and wires: if the amount wired is less than the amount due by a small amount, you might want to forgive the difference. Defaults to &#x60;false&#x60;.
     * @param mandate ID of the mandate to be used for this invoice. It must correspond to the payment method used to pay the invoice, including the payment_method param or the invoice\\\&#39;s default_payment_method or default_source, if set.
     * @param offSession Indicates if a customer is on or off-session while an invoice payment is attempted. Defaults to &#x60;true&#x60; (off-session).
     * @param paidOutOfBand Boolean representing whether an invoice is paid outside of Stripe. This will result in no charge being made. Defaults to &#x60;false&#x60;.
     * @param paymentMethod A PaymentMethod to be charged. The PaymentMethod must be the ID of a PaymentMethod belonging to the customer associated with the invoice being paid.
     * @param source A payment source to be charged. The source must be the ID of a source belonging to the customer associated with the invoice being paid.
     */
    public async postInvoicesInvoicePay (invoice: string, expand?: Array<string>, forgive?: boolean, mandate?: string, offSession?: boolean, paidOutOfBand?: boolean, paymentMethod?: string, source?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}/pay'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling postInvoicesInvoicePay.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (forgive !== undefined) {
            localVarFormParams['forgive'] = ObjectSerializer.serialize(forgive, "boolean");
        }

        if (mandate !== undefined) {
            localVarFormParams['mandate'] = ObjectSerializer.serialize(mandate, "string");
        }

        if (offSession !== undefined) {
            localVarFormParams['off_session'] = ObjectSerializer.serialize(offSession, "boolean");
        }

        if (paidOutOfBand !== undefined) {
            localVarFormParams['paid_out_of_band'] = ObjectSerializer.serialize(paidOutOfBand, "boolean");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (source !== undefined) {
            localVarFormParams['source'] = ObjectSerializer.serialize(source, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Stripe will automatically send invoices to customers according to your <a href=\"https://dashboard.stripe.com/account/billing/automatic\">subscriptions settings</a>. However, if you’d like to manually send an invoice to your customer out of the normal schedule, you can do so. When sending invoices that have already been paid, there will be no reference to the payment in the email.</p>  <p>Requests made in test-mode result in no emails being sent, despite sending an <code>invoice.sent</code> event.</p>
     * @param invoice 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postInvoicesInvoiceSend (invoice: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}/send'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling postInvoicesInvoiceSend.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Mark a finalized invoice as void. This cannot be undone. Voiding an invoice is similar to <a href=\"#delete_invoice\">deletion</a>, however it only applies to finalized invoices and maintains a papertrail where the invoice can still be found.</p>
     * @param invoice 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postInvoicesInvoiceVoid (invoice: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Invoice;  }> {
        const localVarPath = this.basePath + '/v1/invoices/{invoice}/void'
            .replace('{' + 'invoice' + '}', encodeURIComponent(String(invoice)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'invoice' is not null or undefined
        if (invoice === null || invoice === undefined) {
            throw new Error('Required parameter invoice was null or undefined when calling postInvoicesInvoiceVoid.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Invoice;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Invoice");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified Issuing <code>Authorization</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param authorization 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postIssuingAuthorizationsAuthorization (authorization: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }> {
        const localVarPath = this.basePath + '/v1/issuing/authorizations/{authorization}'
            .replace('{' + 'authorization' + '}', encodeURIComponent(String(authorization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postIssuingAuthorizationsAuthorization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingAuthorization");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Approves a pending Issuing <code>Authorization</code> object. This request should be made within the timeout window of the <a href=\"/docs/issuing/controls/real-time-authorizations\">real-time authorization</a> flow.  You can also respond directly to the webhook request to approve an authorization (preferred). More details can be found <a href=\"https://site-admin.stripe.com/docs/issuing/controls/real-time-authorizations#authorization-handling\">here</a>.</p>
     * @param authorization 
     * @param amount If the authorization\\\&#39;s &#x60;pending_request.is_amount_controllable&#x60; property is &#x60;true&#x60;, you may provide this value to control how much to hold for the authorization. Must be positive (use [&#x60;decline&#x60;](https://stripe.com/docs/api/issuing/authorizations/decline) to decline an authorization request).
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postIssuingAuthorizationsAuthorizationApprove (authorization: string, amount?: number, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }> {
        const localVarPath = this.basePath + '/v1/issuing/authorizations/{authorization}/approve'
            .replace('{' + 'authorization' + '}', encodeURIComponent(String(authorization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postIssuingAuthorizationsAuthorizationApprove.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingAuthorization");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Declines a pending Issuing <code>Authorization</code> object. This request should be made within the timeout window of the <a href=\"/docs/issuing/controls/real-time-authorizations\">real time authorization</a> flow. You can also respond directly to the webhook request to decline an authorization (preferred). More details can be found <a href=\"https://site-admin.stripe.com/docs/issuing/controls/real-time-authorizations#authorization-handling\">here</a>.</p>
     * @param authorization 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postIssuingAuthorizationsAuthorizationDecline (authorization: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }> {
        const localVarPath = this.basePath + '/v1/issuing/authorizations/{authorization}/decline'
            .replace('{' + 'authorization' + '}', encodeURIComponent(String(authorization)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'authorization' is not null or undefined
        if (authorization === null || authorization === undefined) {
            throw new Error('Required parameter authorization was null or undefined when calling postIssuingAuthorizationsAuthorizationDecline.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingAuthorization;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingAuthorization");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new Issuing <code>Cardholder</code> object that can be issued cards.</p>
     * @param billing 
     * @param name The cardholder\\\&#39;s name. This will be printed on cards issued to them. The maximum length of this field is 24 characters. This field cannot contain any special characters or numbers.
     * @param type One of &#x60;individual&#x60; or &#x60;company&#x60;. See [Choose a cardholder type](https://stripe.com/docs/issuing/other/choose-cardholder) for more details.
     * @param company 
     * @param email The cardholder\\\&#39;s email address.
     * @param expand Specifies which fields in the response should be expanded.
     * @param individual 
     * @param phoneNumber The cardholder\\\&#39;s phone number. This will be transformed to [E.164](https://en.wikipedia.org/wiki/E.164) if it is not provided in that format already. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure#when-is-3d-secure-applied) for more details.
     * @param spendingControls 
     * @param status Specifies whether to permit authorizations on this cardholder\\\&#39;s cards. Defaults to &#x60;active&#x60;.
     */
    public async postIssuingCardholders (billing: BillingSpecs, name: string, type: string, company?: CompanyParam, email?: string, expand?: Array<string>, individual?: IndividualParam, phoneNumber?: string, spendingControls?: AuthorizationControlsParamV2, status?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCardholder;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cardholders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'billing' is not null or undefined
        if (billing === null || billing === undefined) {
            throw new Error('Required parameter billing was null or undefined when calling postIssuingCardholders.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postIssuingCardholders.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling postIssuingCardholders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (billing !== undefined) {
            localVarFormParams['billing'] = ObjectSerializer.serialize(billing, "BillingSpecs");
        }

        if (company !== undefined) {
            localVarFormParams['company'] = ObjectSerializer.serialize(company, "CompanyParam");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (individual !== undefined) {
            localVarFormParams['individual'] = ObjectSerializer.serialize(individual, "IndividualParam");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (phoneNumber !== undefined) {
            localVarFormParams['phone_number'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (spendingControls !== undefined) {
            localVarFormParams['spending_controls'] = ObjectSerializer.serialize(spendingControls, "AuthorizationControlsParamV2");
        }

        if (status !== undefined) {
            localVarFormParams['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCardholder;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCardholder");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified Issuing <code>Cardholder</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param cardholder 
     * @param billing 
     * @param company 
     * @param email The cardholder\\\&#39;s email address.
     * @param expand Specifies which fields in the response should be expanded.
     * @param individual 
     * @param phoneNumber The cardholder\\\&#39;s phone number. This is required for all cardholders who will be creating EU cards. See the [3D Secure documentation](https://stripe.com/docs/issuing/3d-secure) for more details.
     * @param spendingControls 
     * @param status Specifies whether to permit authorizations on this cardholder\\\&#39;s cards.
     */
    public async postIssuingCardholdersCardholder (cardholder: string, billing?: BillingSpecs, company?: CompanyParam, email?: string, expand?: Array<string>, individual?: IndividualParam, phoneNumber?: string, spendingControls?: AuthorizationControlsParamV2, status?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCardholder;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cardholders/{cardholder}'
            .replace('{' + 'cardholder' + '}', encodeURIComponent(String(cardholder)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'cardholder' is not null or undefined
        if (cardholder === null || cardholder === undefined) {
            throw new Error('Required parameter cardholder was null or undefined when calling postIssuingCardholdersCardholder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (billing !== undefined) {
            localVarFormParams['billing'] = ObjectSerializer.serialize(billing, "BillingSpecs");
        }

        if (company !== undefined) {
            localVarFormParams['company'] = ObjectSerializer.serialize(company, "CompanyParam");
        }

        if (email !== undefined) {
            localVarFormParams['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (individual !== undefined) {
            localVarFormParams['individual'] = ObjectSerializer.serialize(individual, "IndividualParam");
        }

        if (phoneNumber !== undefined) {
            localVarFormParams['phone_number'] = ObjectSerializer.serialize(phoneNumber, "string");
        }

        if (spendingControls !== undefined) {
            localVarFormParams['spending_controls'] = ObjectSerializer.serialize(spendingControls, "AuthorizationControlsParamV2");
        }

        if (status !== undefined) {
            localVarFormParams['status'] = ObjectSerializer.serialize(status, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCardholder;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCardholder");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an Issuing <code>Card</code> object.</p>
     * @param currency The currency for the card.
     * @param type The type of card to issue. Possible values are &#x60;physical&#x60; or &#x60;virtual&#x60;.
     * @param cardholder The [Cardholder](https://stripe.com/docs/api#issuing_cardholder_object) object with which the card will be associated.
     * @param expand Specifies which fields in the response should be expanded.
     * @param financialAccount 
     * @param replacementFor The card this is meant to be a replacement for (if any).
     * @param replacementReason If &#x60;replacement_for&#x60; is specified, this should indicate why that card is being replaced.
     * @param shipping 
     * @param spendingControls 
     * @param status Whether authorizations can be approved on this card. May be blocked from activating cards depending on past-due Cardholder requirements. Defaults to &#x60;inactive&#x60;.
     */
    public async postIssuingCards (currency: string, type: string, cardholder?: string, expand?: Array<string>, financialAccount?: string, replacementFor?: string, replacementReason?: string, shipping?: ShippingSpecs, spendingControls?: AuthorizationControlsParam, status?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCard;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cards';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postIssuingCards.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling postIssuingCards.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cardholder !== undefined) {
            localVarFormParams['cardholder'] = ObjectSerializer.serialize(cardholder, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarFormParams['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (replacementFor !== undefined) {
            localVarFormParams['replacement_for'] = ObjectSerializer.serialize(replacementFor, "string");
        }

        if (replacementReason !== undefined) {
            localVarFormParams['replacement_reason'] = ObjectSerializer.serialize(replacementReason, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "ShippingSpecs");
        }

        if (spendingControls !== undefined) {
            localVarFormParams['spending_controls'] = ObjectSerializer.serialize(spendingControls, "AuthorizationControlsParam");
        }

        if (status !== undefined) {
            localVarFormParams['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCard;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCard");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified Issuing <code>Card</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param card 
     * @param cancellationReason Reason why the &#x60;status&#x60; of this card is &#x60;canceled&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param pin 
     * @param spendingControls 
     * @param status Dictates whether authorizations can be approved on this card. May be blocked from activating cards depending on past-due Cardholder requirements. Defaults to &#x60;inactive&#x60;. If this card is being canceled because it was lost or stolen, this information should be provided as &#x60;cancellation_reason&#x60;.
     */
    public async postIssuingCardsCard (card: string, cancellationReason?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, pin?: EncryptedPinParam, spendingControls?: AuthorizationControlsParam, status?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCard;  }> {
        const localVarPath = this.basePath + '/v1/issuing/cards/{card}'
            .replace('{' + 'card' + '}', encodeURIComponent(String(card)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling postIssuingCardsCard.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cancellationReason !== undefined) {
            localVarFormParams['cancellation_reason'] = ObjectSerializer.serialize(cancellationReason, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (pin !== undefined) {
            localVarFormParams['pin'] = ObjectSerializer.serialize(pin, "EncryptedPinParam");
        }

        if (spendingControls !== undefined) {
            localVarFormParams['spending_controls'] = ObjectSerializer.serialize(spendingControls, "AuthorizationControlsParam");
        }

        if (status !== undefined) {
            localVarFormParams['status'] = ObjectSerializer.serialize(status, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCard;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCard");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an Issuing <code>Dispute</code> object. Individual pieces of evidence within the <code>evidence</code> object are optional at this point. Stripe only validates that required evidence is present during submission. Refer to <a href=\"/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\">Dispute reasons and evidence</a> for more details about evidence requirements.</p>
     * @param amount The dispute amount in the card\\\&#39;s currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal). If not set, defaults to the full transaction amount.
     * @param evidence 
     * @param expand Specifies which fields in the response should be expanded.
     * @param transaction The ID of the issuing transaction to create a dispute for. For transaction on Treasury FinancialAccounts, use &#x60;treasury.received_debit&#x60;.
     * @param treasury 
     */
    public async postIssuingDisputes (amount?: number, evidence?: EvidenceParam, expand?: Array<string>, transaction?: string, treasury?: TreasuryParam, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }> {
        const localVarPath = this.basePath + '/v1/issuing/disputes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (evidence !== undefined) {
            localVarFormParams['evidence'] = ObjectSerializer.serialize(evidence, "EvidenceParam");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (transaction !== undefined) {
            localVarFormParams['transaction'] = ObjectSerializer.serialize(transaction, "string");
        }

        if (treasury !== undefined) {
            localVarFormParams['treasury'] = ObjectSerializer.serialize(treasury, "TreasuryParam");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingDispute");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified Issuing <code>Dispute</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Properties on the <code>evidence</code> object can be unset by passing in an empty string.</p>
     * @param dispute 
     * @param amount The dispute amount in the card\\\&#39;s currency and in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal).
     * @param evidence 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postIssuingDisputesDispute (dispute: string, amount?: number, evidence?: EvidenceParam, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }> {
        const localVarPath = this.basePath + '/v1/issuing/disputes/{dispute}'
            .replace('{' + 'dispute' + '}', encodeURIComponent(String(dispute)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'dispute' is not null or undefined
        if (dispute === null || dispute === undefined) {
            throw new Error('Required parameter dispute was null or undefined when calling postIssuingDisputesDispute.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (evidence !== undefined) {
            localVarFormParams['evidence'] = ObjectSerializer.serialize(evidence, "EvidenceParam");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingDispute");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Submits an Issuing <code>Dispute</code> to the card network. Stripe validates that all evidence fields required for the dispute’s reason are present. For more details, see <a href=\"/docs/issuing/purchases/disputes#dispute-reasons-and-evidence\">Dispute reasons and evidence</a>.</p>
     * @param dispute 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postIssuingDisputesDisputeSubmit (dispute: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }> {
        const localVarPath = this.basePath + '/v1/issuing/disputes/{dispute}/submit'
            .replace('{' + 'dispute' + '}', encodeURIComponent(String(dispute)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'dispute' is not null or undefined
        if (dispute === null || dispute === undefined) {
            throw new Error('Required parameter dispute was null or undefined when calling postIssuingDisputesDisputeSubmit.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingDispute;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingDispute");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified Issuing <code>Transaction</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param transaction 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postIssuingTransactionsTransaction (transaction: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingTransaction;  }> {
        const localVarPath = this.basePath + '/v1/issuing/transactions/{transaction}'
            .replace('{' + 'transaction' + '}', encodeURIComponent(String(transaction)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'transaction' is not null or undefined
        if (transaction === null || transaction === undefined) {
            throw new Error('Required parameter transaction was null or undefined when calling postIssuingTransactionsTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a PaymentIntent object.</p>  <p>After the PaymentIntent is created, attach a payment method and <a href=\"/docs/api/payment_intents/confirm\">confirm</a> to continue the payment. You can read more about the different payment flows available via the Payment Intents API <a href=\"/docs/payments/payment-intents\">here</a>.</p>  <p>When <code>confirm=true</code> is used during creation, it is equivalent to creating and confirming the PaymentIntent in the same call. You may use any parameters available in the <a href=\"/docs/api/payment_intents/confirm\">confirm API</a> when <code>confirm=true</code> is supplied.</p>
     * @param amount Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param applicationFeeAmount The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner\\\&#39;s Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
     * @param automaticPaymentMethods 
     * @param captureMethod Controls when the funds will be captured from the customer\\\&#39;s account.
     * @param confirm Set to &#x60;true&#x60; to attempt to [confirm](https://stripe.com/docs/api/payment_intents/confirm) this PaymentIntent immediately. This parameter defaults to &#x60;false&#x60;. When creating and confirming a PaymentIntent at the same time, parameters available in the [confirm](https://stripe.com/docs/api/payment_intents/confirm) API may also be provided.
     * @param confirmationMethod 
     * @param customer ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent\\\&#39;s payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param errorOnRequiresAction Set to &#x60;true&#x60; to fail the payment attempt if the PaymentIntent transitions into &#x60;requires_action&#x60;. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication). This parameter can only be used with [&#x60;confirm&#x3D;true&#x60;](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
     * @param expand Specifies which fields in the response should be expanded.
     * @param mandate ID of the mandate to be used for this payment. This parameter can only be used with [&#x60;confirm&#x3D;true&#x60;](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
     * @param mandateData 
     * @param offSession 
     * @param onBehalfOf The Stripe account ID for which these funds are intended. For details, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
     * @param paymentMethod ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods#compatibility) object) to attach to this PaymentIntent.  If neither the &#x60;payment_method&#x60; parameter nor the &#x60;source&#x60; parameter are provided with &#x60;confirm&#x3D;true&#x60;, &#x60;source&#x60; will be automatically populated with &#x60;customer.default_source&#x60; to improve the migration experience for users of the Charges API. We recommend that you explicitly provide the &#x60;payment_method&#x60; going forward.
     * @param paymentMethodData 
     * @param paymentMethodOptions 
     * @param paymentMethodTypes The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. If this is not provided, defaults to [\\\&quot;card\\\&quot;]. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
     * @param radarOptions 
     * @param receiptEmail Email address that the receipt for the resulting payment will be sent to. If &#x60;receipt_email&#x60; is specified for a payment in live mode, a receipt will be sent regardless of your [email settings](https://dashboard.stripe.com/account/emails).
     * @param returnUrl The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method\\\&#39;s app or site. If you\\\&#39;d prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [&#x60;confirm&#x3D;true&#x60;](https://stripe.com/docs/api/payment_intents/create#create_payment_intent-confirm).
     * @param setupFutureUsage Indicates that you intend to make future payments with this PaymentIntent\\\&#39;s payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent\\\&#39;s Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses &#x60;setup_future_usage&#x60; to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).
     * @param shipping 
     * @param statementDescriptor For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
     * @param statementDescriptorSuffix Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
     * @param transferData 
     * @param transferGroup A string that identifies the resulting payment as part of a group. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
     * @param useStripeSdk Set to &#x60;true&#x60; only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
     */
    public async postPaymentIntents (amount: number, currency: string, applicationFeeAmount?: number, automaticPaymentMethods?: AutomaticPaymentMethodsParam, captureMethod?: string, confirm?: boolean, confirmationMethod?: string, customer?: string, description?: string, errorOnRequiresAction?: boolean, expand?: Array<string>, mandate?: string, mandateData?: SecretKeyParam, offSession?: PostPaymentIntentsRequestOffSession, onBehalfOf?: string, paymentMethod?: string, paymentMethodData?: PaymentMethodDataParams, paymentMethodOptions?: PaymentMethodOptionsParam25, paymentMethodTypes?: Array<string>, radarOptions?: RadarOptions, receiptEmail?: string, returnUrl?: string, setupFutureUsage?: string, shipping?: OptionalFieldsShipping1, statementDescriptor?: string, statementDescriptorSuffix?: string, transferData?: TransferDataCreationParams, transferGroup?: string, useStripeSdk?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postPaymentIntents.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postPaymentIntents.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (automaticPaymentMethods !== undefined) {
            localVarFormParams['automatic_payment_methods'] = ObjectSerializer.serialize(automaticPaymentMethods, "AutomaticPaymentMethodsParam");
        }

        if (captureMethod !== undefined) {
            localVarFormParams['capture_method'] = ObjectSerializer.serialize(captureMethod, "string");
        }

        if (confirm !== undefined) {
            localVarFormParams['confirm'] = ObjectSerializer.serialize(confirm, "boolean");
        }

        if (confirmationMethod !== undefined) {
            localVarFormParams['confirmation_method'] = ObjectSerializer.serialize(confirmationMethod, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (errorOnRequiresAction !== undefined) {
            localVarFormParams['error_on_requires_action'] = ObjectSerializer.serialize(errorOnRequiresAction, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (mandate !== undefined) {
            localVarFormParams['mandate'] = ObjectSerializer.serialize(mandate, "string");
        }

        if (mandateData !== undefined) {
            localVarFormParams['mandate_data'] = ObjectSerializer.serialize(mandateData, "SecretKeyParam");
        }

        if (offSession !== undefined) {
            localVarFormParams['off_session'] = ObjectSerializer.serialize(offSession, "PostPaymentIntentsRequestOffSession");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (paymentMethodData !== undefined) {
            localVarFormParams['payment_method_data'] = ObjectSerializer.serialize(paymentMethodData, "PaymentMethodDataParams");
        }

        if (paymentMethodOptions !== undefined) {
            localVarFormParams['payment_method_options'] = ObjectSerializer.serialize(paymentMethodOptions, "PaymentMethodOptionsParam25");
        }

        if (paymentMethodTypes !== undefined) {
            localVarFormParams['payment_method_types'] = ObjectSerializer.serialize(paymentMethodTypes, "Array<string>");
        }

        if (radarOptions !== undefined) {
            localVarFormParams['radar_options'] = ObjectSerializer.serialize(radarOptions, "RadarOptions");
        }

        if (receiptEmail !== undefined) {
            localVarFormParams['receipt_email'] = ObjectSerializer.serialize(receiptEmail, "string");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        if (setupFutureUsage !== undefined) {
            localVarFormParams['setup_future_usage'] = ObjectSerializer.serialize(setupFutureUsage, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "OptionalFieldsShipping1");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (statementDescriptorSuffix !== undefined) {
            localVarFormParams['statement_descriptor_suffix'] = ObjectSerializer.serialize(statementDescriptorSuffix, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataCreationParams");
        }

        if (transferGroup !== undefined) {
            localVarFormParams['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        if (useStripeSdk !== undefined) {
            localVarFormParams['use_stripe_sdk'] = ObjectSerializer.serialize(useStripeSdk, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates properties on a PaymentIntent object without confirming.</p>  <p>Depending on which properties you update, you may need to confirm the PaymentIntent again. For example, updating the <code>payment_method</code> will always require you to confirm the PaymentIntent again. If you prefer to update and confirm at the same time, we recommend updating properties via the <a href=\"/docs/api/payment_intents/confirm\">confirm API</a> instead.</p>
     * @param intent 
     * @param amount Amount intended to be collected by this PaymentIntent. A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency). The minimum amount is $0.50 US or [equivalent in charge currency](https://stripe.com/docs/currencies#minimum-and-maximum-charge-amounts). The amount value supports up to eight digits (e.g., a value of 99999999 for a USD charge of $999,999.99).
     * @param applicationFeeAmount 
     * @param captureMethod Controls when the funds will be captured from the customer\\\&#39;s account.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param customer ID of the Customer this PaymentIntent belongs to, if one exists.  Payment methods attached to other Customers cannot be used with this PaymentIntent.  If present in combination with [setup_future_usage](https://stripe.com/docs/api#payment_intent_object-setup_future_usage), this PaymentIntent\\\&#39;s payment method will be attached to the Customer after the PaymentIntent has been confirmed and any required actions from the user are complete.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param paymentMethod ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
     * @param paymentMethodData 
     * @param paymentMethodOptions 
     * @param paymentMethodTypes The list of payment method types (e.g. card) that this PaymentIntent is allowed to use. Use automatic_payment_methods to manage payment methods from the [Stripe Dashboard](https://dashboard.stripe.com/settings/payment_methods).
     * @param receiptEmail 
     * @param setupFutureUsage Indicates that you intend to make future payments with this PaymentIntent\\\&#39;s payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent\\\&#39;s Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses &#x60;setup_future_usage&#x60; to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If &#x60;setup_future_usage&#x60; is already set and you are performing a request using a publishable key, you may only update the value from &#x60;on_session&#x60; to &#x60;off_session&#x60;.
     * @param shipping 
     * @param statementDescriptor For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
     * @param statementDescriptorSuffix Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
     * @param transferData 
     * @param transferGroup A string that identifies the resulting payment as part of a group. &#x60;transfer_group&#x60; may only be provided if it has not been set. See the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts) for details.
     */
    public async postPaymentIntentsIntent (intent: string, amount?: number, applicationFeeAmount?: PostPaymentIntentsIntentRequestApplicationFeeAmount, captureMethod?: string, currency?: string, customer?: string, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, paymentMethod?: string, paymentMethodData?: PaymentMethodDataParams, paymentMethodOptions?: PaymentMethodOptionsParam25, paymentMethodTypes?: Array<string>, receiptEmail?: PostPaymentIntentsIntentRequestReceiptEmail, setupFutureUsage?: string, shipping?: PostPaymentIntentsIntentRequestShipping, statementDescriptor?: string, statementDescriptorSuffix?: string, transferData?: TransferDataUpdateParams, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postPaymentIntentsIntent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "PostPaymentIntentsIntentRequestApplicationFeeAmount");
        }

        if (captureMethod !== undefined) {
            localVarFormParams['capture_method'] = ObjectSerializer.serialize(captureMethod, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (paymentMethodData !== undefined) {
            localVarFormParams['payment_method_data'] = ObjectSerializer.serialize(paymentMethodData, "PaymentMethodDataParams");
        }

        if (paymentMethodOptions !== undefined) {
            localVarFormParams['payment_method_options'] = ObjectSerializer.serialize(paymentMethodOptions, "PaymentMethodOptionsParam25");
        }

        if (paymentMethodTypes !== undefined) {
            localVarFormParams['payment_method_types'] = ObjectSerializer.serialize(paymentMethodTypes, "Array<string>");
        }

        if (receiptEmail !== undefined) {
            localVarFormParams['receipt_email'] = ObjectSerializer.serialize(receiptEmail, "PostPaymentIntentsIntentRequestReceiptEmail");
        }

        if (setupFutureUsage !== undefined) {
            localVarFormParams['setup_future_usage'] = ObjectSerializer.serialize(setupFutureUsage, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "PostPaymentIntentsIntentRequestShipping");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (statementDescriptorSuffix !== undefined) {
            localVarFormParams['statement_descriptor_suffix'] = ObjectSerializer.serialize(statementDescriptorSuffix, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataUpdateParams");
        }

        if (transferGroup !== undefined) {
            localVarFormParams['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Manually reconcile the remaining amount for a customer_balance PaymentIntent.</p>
     * @param intent 
     * @param amount Amount intended to be applied to this PaymentIntent from the customer’s cash balance.  A positive integer representing how much to charge in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to charge $1.00 or 100 to charge ¥100, a zero-decimal currency).  The maximum amount is the amount of the PaymentIntent.  When omitted, the amount defaults to the remaining amount requested on the PaymentIntent.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postPaymentIntentsIntentApplyCustomerBalance (intent: string, amount?: number, currency?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}/apply_customer_balance'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postPaymentIntentsIntentApplyCustomerBalance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A PaymentIntent object can be canceled when it is in one of these statuses: <code>requires_payment_method</code>, <code>requires_capture</code>, <code>requires_confirmation</code>, <code>requires_action</code> or, <a href=\"/docs/payments/intents\">in rare cases</a>, <code>processing</code>. </p>  <p>Once canceled, no additional charges will be made by the PaymentIntent and any operations on the PaymentIntent will fail with an error. For PaymentIntents with <code>status=’requires_capture’</code>, the remaining <code>amount_capturable</code> will automatically be refunded. </p>  <p>You cannot cancel the PaymentIntent for a Checkout Session. <a href=\"/docs/api/checkout/sessions/expire\">Expire the Checkout Session</a> instead.</p>
     * @param intent 
     * @param cancellationReason Reason for canceling this PaymentIntent. Possible values are &#x60;duplicate&#x60;, &#x60;fraudulent&#x60;, &#x60;requested_by_customer&#x60;, or &#x60;abandoned&#x60;
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postPaymentIntentsIntentCancel (intent: string, cancellationReason?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}/cancel'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postPaymentIntentsIntentCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cancellationReason !== undefined) {
            localVarFormParams['cancellation_reason'] = ObjectSerializer.serialize(cancellationReason, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Capture the funds of an existing uncaptured PaymentIntent when its status is <code>requires_capture</code>.</p>  <p>Uncaptured PaymentIntents will be canceled a set number of days after they are created (7 by default).</p>  <p>Learn more about <a href=\"/docs/payments/capture-later\">separate authorization and capture</a>.</p>
     * @param intent 
     * @param amountToCapture The amount to capture from the PaymentIntent, which must be less than or equal to the original amount. Any additional amount will be automatically refunded. Defaults to the full &#x60;amount_capturable&#x60; if not provided.
     * @param applicationFeeAmount The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner\\\&#39;s Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
     * @param expand Specifies which fields in the response should be expanded.
     * @param statementDescriptor For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
     * @param statementDescriptorSuffix Provides information about a card payment that customers see on their statements. Concatenated with the prefix (shortened descriptor) or statement descriptor that’s set on the account to form the complete statement descriptor. Maximum 22 characters for the concatenated descriptor.
     * @param transferData 
     */
    public async postPaymentIntentsIntentCapture (intent: string, amountToCapture?: number, applicationFeeAmount?: number, expand?: Array<string>, statementDescriptor?: string, statementDescriptorSuffix?: string, transferData?: TransferDataUpdateParams1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}/capture'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postPaymentIntentsIntentCapture.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amountToCapture !== undefined) {
            localVarFormParams['amount_to_capture'] = ObjectSerializer.serialize(amountToCapture, "number");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (statementDescriptorSuffix !== undefined) {
            localVarFormParams['statement_descriptor_suffix'] = ObjectSerializer.serialize(statementDescriptorSuffix, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataUpdateParams1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Confirm that your customer intends to pay with current or provided payment method. Upon confirmation, the PaymentIntent will attempt to initiate a payment. If the selected payment method requires additional authentication steps, the PaymentIntent will transition to the <code>requires_action</code> status and suggest additional actions via <code>next_action</code>. If payment fails, the PaymentIntent will transition to the <code>requires_payment_method</code> status. If payment succeeds, the PaymentIntent will transition to the <code>succeeded</code> status (or <code>requires_capture</code>, if <code>capture_method</code> is set to <code>manual</code>). If the <code>confirmation_method</code> is <code>automatic</code>, payment may be attempted using our <a href=\"/docs/stripe-js/reference#stripe-handle-card-payment\">client SDKs</a> and the PaymentIntent’s <a href=\"#payment_intent_object-client_secret\">client_secret</a>. After <code>next_action</code>s are handled by the client, no additional confirmation is required to complete the payment. If the <code>confirmation_method</code> is <code>manual</code>, all payment attempts must be initiated using a secret key. If any actions are required for the payment, the PaymentIntent will return to the <code>requires_confirmation</code> state after those actions are completed. Your server needs to then explicitly re-confirm the PaymentIntent to initiate the next payment attempt. Read the <a href=\"/docs/payments/payment-intents/web-manual\">expanded documentation</a> to learn more about manual confirmation.</p>
     * @param intent 
     * @param captureMethod Controls when the funds will be captured from the customer\\\&#39;s account.
     * @param errorOnRequiresAction Set to &#x60;true&#x60; to fail the payment attempt if the PaymentIntent transitions into &#x60;requires_action&#x60;. This parameter is intended for simpler integrations that do not handle customer actions, like [saving cards without authentication](https://stripe.com/docs/payments/save-card-without-authentication).
     * @param expand Specifies which fields in the response should be expanded.
     * @param mandate ID of the mandate to be used for this payment.
     * @param mandateData 
     * @param offSession 
     * @param paymentMethod ID of the payment method (a PaymentMethod, Card, or [compatible Source](https://stripe.com/docs/payments/payment-methods/transitioning#compatibility) object) to attach to this PaymentIntent.
     * @param paymentMethodData 
     * @param paymentMethodOptions 
     * @param radarOptions 
     * @param receiptEmail 
     * @param returnUrl The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method\\\&#39;s app or site. If you\\\&#39;d prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
     * @param setupFutureUsage Indicates that you intend to make future payments with this PaymentIntent\\\&#39;s payment method.  Providing this parameter will [attach the payment method](https://stripe.com/docs/payments/save-during-payment) to the PaymentIntent\\\&#39;s Customer, if present, after the PaymentIntent is confirmed and any required actions from the user are complete. If no Customer was provided, the payment method can still be [attached](https://stripe.com/docs/api/payment_methods/attach) to a Customer after the transaction completes.  When processing card payments, Stripe also uses &#x60;setup_future_usage&#x60; to dynamically optimize your payment flow and comply with regional legislation and network rules, such as [SCA](https://stripe.com/docs/strong-customer-authentication).  If &#x60;setup_future_usage&#x60; is already set and you are performing a request using a publishable key, you may only update the value from &#x60;on_session&#x60; to &#x60;off_session&#x60;.
     * @param shipping 
     * @param useStripeSdk Set to &#x60;true&#x60; only when using manual confirmation and the iOS or Android SDKs to handle additional authentication steps.
     */
    public async postPaymentIntentsIntentConfirm (intent: string, captureMethod?: string, errorOnRequiresAction?: boolean, expand?: Array<string>, mandate?: string, mandateData?: PostPaymentIntentsIntentConfirmRequestMandateData, offSession?: PostPaymentIntentsIntentConfirmRequestOffSession, paymentMethod?: string, paymentMethodData?: PaymentMethodDataParams, paymentMethodOptions?: PaymentMethodOptionsParam25, radarOptions?: RadarOptions, receiptEmail?: PostPaymentIntentsIntentRequestReceiptEmail, returnUrl?: string, setupFutureUsage?: string, shipping?: PostPaymentIntentsIntentRequestShipping, useStripeSdk?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}/confirm'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postPaymentIntentsIntentConfirm.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (captureMethod !== undefined) {
            localVarFormParams['capture_method'] = ObjectSerializer.serialize(captureMethod, "string");
        }

        if (errorOnRequiresAction !== undefined) {
            localVarFormParams['error_on_requires_action'] = ObjectSerializer.serialize(errorOnRequiresAction, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (mandate !== undefined) {
            localVarFormParams['mandate'] = ObjectSerializer.serialize(mandate, "string");
        }

        if (mandateData !== undefined) {
            localVarFormParams['mandate_data'] = ObjectSerializer.serialize(mandateData, "PostPaymentIntentsIntentConfirmRequestMandateData");
        }

        if (offSession !== undefined) {
            localVarFormParams['off_session'] = ObjectSerializer.serialize(offSession, "PostPaymentIntentsIntentConfirmRequestOffSession");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (paymentMethodData !== undefined) {
            localVarFormParams['payment_method_data'] = ObjectSerializer.serialize(paymentMethodData, "PaymentMethodDataParams");
        }

        if (paymentMethodOptions !== undefined) {
            localVarFormParams['payment_method_options'] = ObjectSerializer.serialize(paymentMethodOptions, "PaymentMethodOptionsParam25");
        }

        if (radarOptions !== undefined) {
            localVarFormParams['radar_options'] = ObjectSerializer.serialize(radarOptions, "RadarOptions");
        }

        if (receiptEmail !== undefined) {
            localVarFormParams['receipt_email'] = ObjectSerializer.serialize(receiptEmail, "PostPaymentIntentsIntentRequestReceiptEmail");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        if (setupFutureUsage !== undefined) {
            localVarFormParams['setup_future_usage'] = ObjectSerializer.serialize(setupFutureUsage, "string");
        }

        if (shipping !== undefined) {
            localVarFormParams['shipping'] = ObjectSerializer.serialize(shipping, "PostPaymentIntentsIntentRequestShipping");
        }

        if (useStripeSdk !== undefined) {
            localVarFormParams['use_stripe_sdk'] = ObjectSerializer.serialize(useStripeSdk, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Perform an incremental authorization on an eligible <a href=\"/docs/api/payment_intents/object\">PaymentIntent</a>. To be eligible, the PaymentIntent’s status must be <code>requires_capture</code> and <a href=\"/docs/api/charges/object#charge_object-payment_method_details-card_present-incremental_authorization_supported\">incremental_authorization_supported</a> must be <code>true</code>.</p>  <p>Incremental authorizations attempt to increase the authorized amount on your customer’s card to the new, higher <code>amount</code> provided. As with the initial authorization, incremental authorizations may be declined. A single PaymentIntent can call this endpoint multiple times to further increase the authorized amount.</p>  <p>If the incremental authorization succeeds, the PaymentIntent object is returned with the updated <a href=\"/docs/api/payment_intents/object#payment_intent_object-amount\">amount</a>. If the incremental authorization fails, a <a href=\"/docs/error-codes#card-declined\">card_declined</a> error is returned, and no fields on the PaymentIntent or Charge are updated. The PaymentIntent object remains capturable for the previously authorized amount.</p>  <p>Each PaymentIntent can have a maximum of 10 incremental authorization attempts, including declines. Once captured, a PaymentIntent can no longer be incremented.</p>  <p>Learn more about <a href=\"/docs/terminal/features/incremental-authorizations\">incremental authorizations</a>.</p>
     * @param intent 
     * @param amount The updated total amount you intend to collect from the cardholder. This amount must be greater than the currently authorized amount.
     * @param applicationFeeAmount The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner\\\&#39;s Stripe account. The amount of the application fee collected will be capped at the total payment amount. For more information, see the PaymentIntents [use case for connected accounts](https://stripe.com/docs/payments/connected-accounts).
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param statementDescriptor For non-card charges, you can use this value as the complete description that appears on your customers’ statements. Must contain at least one letter, maximum 22 characters.
     * @param transferData 
     */
    public async postPaymentIntentsIntentIncrementAuthorization (intent: string, amount: number, applicationFeeAmount?: number, description?: string, expand?: Array<string>, statementDescriptor?: string, transferData?: TransferDataUpdateParams2, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}/increment_authorization'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postPaymentIntentsIntentIncrementAuthorization.');
        }

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postPaymentIntentsIntentIncrementAuthorization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataUpdateParams2");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Verifies microdeposits on a PaymentIntent object.</p>
     * @param intent 
     * @param amounts Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
     * @param descriptorCode A six-character code starting with SM present in the microdeposit sent to the bank account.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postPaymentIntentsIntentVerifyMicrodeposits (intent: string, amounts?: Array<number>, descriptorCode?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }> {
        const localVarPath = this.basePath + '/v1/payment_intents/{intent}/verify_microdeposits'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postPaymentIntentsIntentVerifyMicrodeposits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amounts !== undefined) {
            localVarFormParams['amounts'] = ObjectSerializer.serialize(amounts, "Array<number>");
        }

        if (descriptorCode !== undefined) {
            localVarFormParams['descriptor_code'] = ObjectSerializer.serialize(descriptorCode, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a payment link.</p>
     * @param lineItems The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
     * @param afterCompletion 
     * @param allowPromotionCodes Enables user redeemable promotion codes.
     * @param applicationFeeAmount The amount of the application fee (if any) that will be requested to be applied to the payment and transferred to the application owner\\\&#39;s Stripe account. Can only be applied when there are no line items with recurring prices.
     * @param applicationFeePercent A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner\\\&#39;s Stripe account. There must be at least 1 line item with a recurring price to use this field.
     * @param automaticTax 
     * @param billingAddressCollection Configuration for collecting the customer\\\&#39;s billing address.
     * @param consentCollection 
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies) and supported by each line item\\\&#39;s price.
     * @param customFields Collect additional information from your customer using custom fields. Up to 2 fields are supported.
     * @param customText 
     * @param customerCreation Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoiceCreation 
     * @param onBehalfOf The account on behalf of which to charge.
     * @param paymentIntentData 
     * @param paymentMethodCollection Specify whether Checkout should collect a payment method. When set to &#x60;if_required&#x60;, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in &#x60;subscription&#x60; mode.  If you\\\&#39;d like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
     * @param paymentMethodTypes The list of payment method types that customers can use. If no value is passed, Stripe will dynamically show relevant payment methods from your [payment method settings](https://dashboard.stripe.com/settings/payment_methods) (20+ payment methods [supported](https://stripe.com/docs/payments/payment-methods/integration-options#payment-method-product-support)).
     * @param phoneNumberCollection 
     * @param shippingAddressCollection 
     * @param shippingOptions The shipping rate options to apply to [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link.
     * @param submitType Describes the type of transaction being performed in order to customize relevant text on the page, such as the submit button. Changing this value will also affect the hostname in the [url](https://stripe.com/docs/api/payment_links/payment_links/object#url) property (example: &#x60;donate.stripe.com&#x60;).
     * @param subscriptionData 
     * @param taxIdCollection 
     * @param transferData 
     */
    public async postPaymentLinks (lineItems: Array<LineItemsCreateParams>, afterCompletion?: AfterCompletionParams, allowPromotionCodes?: boolean, applicationFeeAmount?: number, applicationFeePercent?: number, automaticTax?: AutomaticTaxParams1, billingAddressCollection?: string, consentCollection?: ConsentCollectionParams1, currency?: string, customFields?: Array<CustomFieldParam>, customText?: CustomTextParam, customerCreation?: string, expand?: Array<string>, invoiceCreation?: InvoiceCreationCreateParams, onBehalfOf?: string, paymentIntentData?: PaymentIntentDataParams1, paymentMethodCollection?: string, paymentMethodTypes?: Array<string>, phoneNumberCollection?: PhoneNumberCollectionParams1, shippingAddressCollection?: ShippingAddressCollectionParams1, shippingOptions?: Array<ShippingOptionParams1>, submitType?: string, subscriptionData?: SubscriptionDataParams1, taxIdCollection?: TaxIdCollectionParams1, transferData?: TransferDataParams1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentLink;  }> {
        const localVarPath = this.basePath + '/v1/payment_links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'lineItems' is not null or undefined
        if (lineItems === null || lineItems === undefined) {
            throw new Error('Required parameter lineItems was null or undefined when calling postPaymentLinks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (afterCompletion !== undefined) {
            localVarFormParams['after_completion'] = ObjectSerializer.serialize(afterCompletion, "AfterCompletionParams");
        }

        if (allowPromotionCodes !== undefined) {
            localVarFormParams['allow_promotion_codes'] = ObjectSerializer.serialize(allowPromotionCodes, "boolean");
        }

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "number");
        }

        if (applicationFeePercent !== undefined) {
            localVarFormParams['application_fee_percent'] = ObjectSerializer.serialize(applicationFeePercent, "number");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParams1");
        }

        if (billingAddressCollection !== undefined) {
            localVarFormParams['billing_address_collection'] = ObjectSerializer.serialize(billingAddressCollection, "string");
        }

        if (consentCollection !== undefined) {
            localVarFormParams['consent_collection'] = ObjectSerializer.serialize(consentCollection, "ConsentCollectionParams1");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customFields !== undefined) {
            localVarFormParams['custom_fields'] = ObjectSerializer.serialize(customFields, "Array<CustomFieldParam>");
        }

        if (customText !== undefined) {
            localVarFormParams['custom_text'] = ObjectSerializer.serialize(customText, "CustomTextParam");
        }

        if (customerCreation !== undefined) {
            localVarFormParams['customer_creation'] = ObjectSerializer.serialize(customerCreation, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoiceCreation !== undefined) {
            localVarFormParams['invoice_creation'] = ObjectSerializer.serialize(invoiceCreation, "InvoiceCreationCreateParams");
        }

        if (lineItems !== undefined) {
            localVarFormParams['line_items'] = ObjectSerializer.serialize(lineItems, "Array<LineItemsCreateParams>");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        if (paymentIntentData !== undefined) {
            localVarFormParams['payment_intent_data'] = ObjectSerializer.serialize(paymentIntentData, "PaymentIntentDataParams1");
        }

        if (paymentMethodCollection !== undefined) {
            localVarFormParams['payment_method_collection'] = ObjectSerializer.serialize(paymentMethodCollection, "string");
        }

        if (paymentMethodTypes !== undefined) {
            localVarFormParams['payment_method_types'] = ObjectSerializer.serialize(paymentMethodTypes, "Array<string>");
        }

        if (phoneNumberCollection !== undefined) {
            localVarFormParams['phone_number_collection'] = ObjectSerializer.serialize(phoneNumberCollection, "PhoneNumberCollectionParams1");
        }

        if (shippingAddressCollection !== undefined) {
            localVarFormParams['shipping_address_collection'] = ObjectSerializer.serialize(shippingAddressCollection, "ShippingAddressCollectionParams1");
        }

        if (shippingOptions !== undefined) {
            localVarFormParams['shipping_options'] = ObjectSerializer.serialize(shippingOptions, "Array<ShippingOptionParams1>");
        }

        if (submitType !== undefined) {
            localVarFormParams['submit_type'] = ObjectSerializer.serialize(submitType, "string");
        }

        if (subscriptionData !== undefined) {
            localVarFormParams['subscription_data'] = ObjectSerializer.serialize(subscriptionData, "SubscriptionDataParams1");
        }

        if (taxIdCollection !== undefined) {
            localVarFormParams['tax_id_collection'] = ObjectSerializer.serialize(taxIdCollection, "TaxIdCollectionParams1");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataParams1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a payment link.</p>
     * @param paymentLink 
     * @param active Whether the payment link\\\&#39;s &#x60;url&#x60; is active. If &#x60;false&#x60;, customers visiting the URL will be shown a page saying that the link has been deactivated.
     * @param afterCompletion 
     * @param allowPromotionCodes Enables user redeemable promotion codes.
     * @param automaticTax 
     * @param billingAddressCollection Configuration for collecting the customer\\\&#39;s billing address.
     * @param customFields 
     * @param customText 
     * @param customerCreation Configures whether [checkout sessions](https://stripe.com/docs/api/checkout/sessions) created by this payment link create a [Customer](https://stripe.com/docs/api/customers).
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoiceCreation 
     * @param lineItems The line items representing what is being sold. Each line item represents an item being sold. Up to 20 line items are supported.
     * @param paymentMethodCollection Specify whether Checkout should collect a payment method. When set to &#x60;if_required&#x60;, Checkout will not collect a payment method when the total due for the session is 0.This may occur if the Checkout Session includes a free trial or a discount.  Can only be set in &#x60;subscription&#x60; mode.  If you\\\&#39;d like information on how to collect a payment method outside of Checkout, read the guide on [configuring subscriptions with a free trial](https://stripe.com/docs/payments/checkout/free-trials).
     * @param paymentMethodTypes 
     * @param shippingAddressCollection 
     */
    public async postPaymentLinksPaymentLink (paymentLink: string, active?: boolean, afterCompletion?: AfterCompletionParams, allowPromotionCodes?: boolean, automaticTax?: AutomaticTaxParams1, billingAddressCollection?: string, customFields?: PostPaymentLinksPaymentLinkRequestCustomFields, customText?: CustomTextParam, customerCreation?: string, expand?: Array<string>, invoiceCreation?: InvoiceCreationUpdateParams, lineItems?: Array<LineItemsUpdateParams>, paymentMethodCollection?: string, paymentMethodTypes?: PostPaymentLinksPaymentLinkRequestPaymentMethodTypes, shippingAddressCollection?: PostPaymentLinksPaymentLinkRequestShippingAddressCollection, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentLink;  }> {
        const localVarPath = this.basePath + '/v1/payment_links/{payment_link}'
            .replace('{' + 'payment_link' + '}', encodeURIComponent(String(paymentLink)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'paymentLink' is not null or undefined
        if (paymentLink === null || paymentLink === undefined) {
            throw new Error('Required parameter paymentLink was null or undefined when calling postPaymentLinksPaymentLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (afterCompletion !== undefined) {
            localVarFormParams['after_completion'] = ObjectSerializer.serialize(afterCompletion, "AfterCompletionParams");
        }

        if (allowPromotionCodes !== undefined) {
            localVarFormParams['allow_promotion_codes'] = ObjectSerializer.serialize(allowPromotionCodes, "boolean");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParams1");
        }

        if (billingAddressCollection !== undefined) {
            localVarFormParams['billing_address_collection'] = ObjectSerializer.serialize(billingAddressCollection, "string");
        }

        if (customFields !== undefined) {
            localVarFormParams['custom_fields'] = ObjectSerializer.serialize(customFields, "PostPaymentLinksPaymentLinkRequestCustomFields");
        }

        if (customText !== undefined) {
            localVarFormParams['custom_text'] = ObjectSerializer.serialize(customText, "CustomTextParam");
        }

        if (customerCreation !== undefined) {
            localVarFormParams['customer_creation'] = ObjectSerializer.serialize(customerCreation, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoiceCreation !== undefined) {
            localVarFormParams['invoice_creation'] = ObjectSerializer.serialize(invoiceCreation, "InvoiceCreationUpdateParams");
        }

        if (lineItems !== undefined) {
            localVarFormParams['line_items'] = ObjectSerializer.serialize(lineItems, "Array<LineItemsUpdateParams>");
        }

        if (paymentMethodCollection !== undefined) {
            localVarFormParams['payment_method_collection'] = ObjectSerializer.serialize(paymentMethodCollection, "string");
        }

        if (paymentMethodTypes !== undefined) {
            localVarFormParams['payment_method_types'] = ObjectSerializer.serialize(paymentMethodTypes, "PostPaymentLinksPaymentLinkRequestPaymentMethodTypes");
        }

        if (shippingAddressCollection !== undefined) {
            localVarFormParams['shipping_address_collection'] = ObjectSerializer.serialize(shippingAddressCollection, "PostPaymentLinksPaymentLinkRequestShippingAddressCollection");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentLink;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentLink");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a PaymentMethod object. Read the <a href=\"/docs/stripe-js/reference#stripe-create-payment-method\">Stripe.js reference</a> to learn how to create PaymentMethods via Stripe.js.</p>  <p>Instead of creating a PaymentMethod directly, we recommend using the <a href=\"/docs/payments/accept-a-payment\">PaymentIntents</a> API to accept a payment immediately or the <a href=\"/docs/payments/save-and-reuse\">SetupIntent</a> API to collect payment method details ahead of a future payment.</p>
     * @param acssDebit 
     * @param affirm If this is an &#x60;affirm&#x60; PaymentMethod, this hash contains details about the Affirm payment method.
     * @param afterpayClearpay If this is an &#x60;AfterpayClearpay&#x60; PaymentMethod, this hash contains details about the AfterpayClearpay payment method.
     * @param alipay If this is an &#x60;Alipay&#x60; PaymentMethod, this hash contains details about the Alipay payment method.
     * @param auBecsDebit 
     * @param bacsDebit 
     * @param bancontact If this is a &#x60;bancontact&#x60; PaymentMethod, this hash contains details about the Bancontact payment method.
     * @param billingDetails 
     * @param blik If this is a &#x60;blik&#x60; PaymentMethod, this hash contains details about the BLIK payment method.
     * @param boleto 
     * @param card 
     * @param customer The &#x60;Customer&#x60; to whom the original PaymentMethod is attached.
     * @param customerBalance If this is a &#x60;customer_balance&#x60; PaymentMethod, this hash contains details about the CustomerBalance payment method.
     * @param eps 
     * @param expand Specifies which fields in the response should be expanded.
     * @param fpx 
     * @param giropay If this is a &#x60;giropay&#x60; PaymentMethod, this hash contains details about the Giropay payment method.
     * @param grabpay If this is a &#x60;grabpay&#x60; PaymentMethod, this hash contains details about the GrabPay payment method.
     * @param ideal 
     * @param interacPresent If this is an &#x60;interac_present&#x60; PaymentMethod, this hash contains details about the Interac Present payment method.
     * @param klarna 
     * @param konbini If this is a &#x60;konbini&#x60; PaymentMethod, this hash contains details about the Konbini payment method.
     * @param link If this is an &#x60;Link&#x60; PaymentMethod, this hash contains details about the Link payment method.
     * @param oxxo If this is an &#x60;oxxo&#x60; PaymentMethod, this hash contains details about the OXXO payment method.
     * @param p24 
     * @param paymentMethod The PaymentMethod to share.
     * @param paynow If this is a &#x60;paynow&#x60; PaymentMethod, this hash contains details about the PayNow payment method.
     * @param pix If this is a &#x60;pix&#x60; PaymentMethod, this hash contains details about the Pix payment method.
     * @param promptpay If this is a &#x60;promptpay&#x60; PaymentMethod, this hash contains details about the PromptPay payment method.
     * @param radarOptions 
     * @param sepaDebit 
     * @param sofort 
     * @param type The type of the PaymentMethod. An additional hash is included on the PaymentMethod with a name matching this value. It contains additional information specific to the PaymentMethod type.
     * @param usBankAccount 
     * @param wechatPay If this is an &#x60;wechat_pay&#x60; PaymentMethod, this hash contains details about the wechat_pay payment method.
     */
    public async postPaymentMethods (acssDebit?: PaymentMethodParam, affirm?: object, afterpayClearpay?: object, alipay?: object, auBecsDebit?: Param, bacsDebit?: Param1, bancontact?: object, billingDetails?: BillingDetailsInnerParams, blik?: object, boleto?: Param2, card?: PostPaymentMethodsRequestCard, customer?: string, customerBalance?: object, eps?: Param3, expand?: Array<string>, fpx?: Param4, giropay?: object, grabpay?: object, ideal?: Param5, interacPresent?: object, klarna?: Param6, konbini?: object, link?: object, oxxo?: object, p24?: Param7, paymentMethod?: string, paynow?: object, pix?: object, promptpay?: object, radarOptions?: RadarOptions, sepaDebit?: Param8, sofort?: Param9, type?: string, usBankAccount?: PaymentMethodParam1, wechatPay?: object, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }> {
        const localVarPath = this.basePath + '/v1/payment_methods';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (acssDebit !== undefined) {
            localVarFormParams['acss_debit'] = ObjectSerializer.serialize(acssDebit, "PaymentMethodParam");
        }

        if (affirm !== undefined) {
            localVarFormParams['affirm'] = ObjectSerializer.serialize(affirm, "object");
        }

        if (afterpayClearpay !== undefined) {
            localVarFormParams['afterpay_clearpay'] = ObjectSerializer.serialize(afterpayClearpay, "object");
        }

        if (alipay !== undefined) {
            localVarFormParams['alipay'] = ObjectSerializer.serialize(alipay, "object");
        }

        if (auBecsDebit !== undefined) {
            localVarFormParams['au_becs_debit'] = ObjectSerializer.serialize(auBecsDebit, "Param");
        }

        if (bacsDebit !== undefined) {
            localVarFormParams['bacs_debit'] = ObjectSerializer.serialize(bacsDebit, "Param1");
        }

        if (bancontact !== undefined) {
            localVarFormParams['bancontact'] = ObjectSerializer.serialize(bancontact, "object");
        }

        if (billingDetails !== undefined) {
            localVarFormParams['billing_details'] = ObjectSerializer.serialize(billingDetails, "BillingDetailsInnerParams");
        }

        if (blik !== undefined) {
            localVarFormParams['blik'] = ObjectSerializer.serialize(blik, "object");
        }

        if (boleto !== undefined) {
            localVarFormParams['boleto'] = ObjectSerializer.serialize(boleto, "Param2");
        }

        if (card !== undefined) {
            localVarFormParams['card'] = ObjectSerializer.serialize(card, "PostPaymentMethodsRequestCard");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (customerBalance !== undefined) {
            localVarFormParams['customer_balance'] = ObjectSerializer.serialize(customerBalance, "object");
        }

        if (eps !== undefined) {
            localVarFormParams['eps'] = ObjectSerializer.serialize(eps, "Param3");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (fpx !== undefined) {
            localVarFormParams['fpx'] = ObjectSerializer.serialize(fpx, "Param4");
        }

        if (giropay !== undefined) {
            localVarFormParams['giropay'] = ObjectSerializer.serialize(giropay, "object");
        }

        if (grabpay !== undefined) {
            localVarFormParams['grabpay'] = ObjectSerializer.serialize(grabpay, "object");
        }

        if (ideal !== undefined) {
            localVarFormParams['ideal'] = ObjectSerializer.serialize(ideal, "Param5");
        }

        if (interacPresent !== undefined) {
            localVarFormParams['interac_present'] = ObjectSerializer.serialize(interacPresent, "object");
        }

        if (klarna !== undefined) {
            localVarFormParams['klarna'] = ObjectSerializer.serialize(klarna, "Param6");
        }

        if (konbini !== undefined) {
            localVarFormParams['konbini'] = ObjectSerializer.serialize(konbini, "object");
        }

        if (link !== undefined) {
            localVarFormParams['link'] = ObjectSerializer.serialize(link, "object");
        }

        if (oxxo !== undefined) {
            localVarFormParams['oxxo'] = ObjectSerializer.serialize(oxxo, "object");
        }

        if (p24 !== undefined) {
            localVarFormParams['p24'] = ObjectSerializer.serialize(p24, "Param7");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (paynow !== undefined) {
            localVarFormParams['paynow'] = ObjectSerializer.serialize(paynow, "object");
        }

        if (pix !== undefined) {
            localVarFormParams['pix'] = ObjectSerializer.serialize(pix, "object");
        }

        if (promptpay !== undefined) {
            localVarFormParams['promptpay'] = ObjectSerializer.serialize(promptpay, "object");
        }

        if (radarOptions !== undefined) {
            localVarFormParams['radar_options'] = ObjectSerializer.serialize(radarOptions, "RadarOptions");
        }

        if (sepaDebit !== undefined) {
            localVarFormParams['sepa_debit'] = ObjectSerializer.serialize(sepaDebit, "Param8");
        }

        if (sofort !== undefined) {
            localVarFormParams['sofort'] = ObjectSerializer.serialize(sofort, "Param9");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (usBankAccount !== undefined) {
            localVarFormParams['us_bank_account'] = ObjectSerializer.serialize(usBankAccount, "PaymentMethodParam1");
        }

        if (wechatPay !== undefined) {
            localVarFormParams['wechat_pay'] = ObjectSerializer.serialize(wechatPay, "object");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentMethod");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a PaymentMethod object. A PaymentMethod must be attached a customer to be updated.</p>
     * @param paymentMethod 
     * @param acssDebit This is a legacy parameter that will be removed in the future. It is a hash that does not accept any keys.
     * @param affirm This is a legacy parameter that will be removed in the future. It is a hash that does not accept any keys.
     * @param auBecsDebit This is a legacy parameter that will be removed in the future. It is a hash that does not accept any keys.
     * @param bacsDebit This is a legacy parameter that will be removed in the future. It is a hash that does not accept any keys.
     * @param billingDetails 
     * @param blik This is a legacy parameter that will be removed in the future. It is a hash that does not accept any keys.
     * @param card 
     * @param expand Specifies which fields in the response should be expanded.
     * @param link If this is an &#x60;Link&#x60; PaymentMethod, this hash contains details about the Link payment method.
     * @param metadata 
     * @param sepaDebit This is a legacy parameter that will be removed in the future. It is a hash that does not accept any keys.
     * @param usBankAccount 
     */
    public async postPaymentMethodsPaymentMethod (paymentMethod: string, acssDebit?: object, affirm?: object, auBecsDebit?: object, bacsDebit?: object, billingDetails?: BillingDetailsInnerParams, blik?: object, card?: UpdateApiParam, expand?: Array<string>, link?: object, metadata?: IndividualSpecsMetadata, sepaDebit?: object, usBankAccount?: UpdateParam, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }> {
        const localVarPath = this.basePath + '/v1/payment_methods/{payment_method}'
            .replace('{' + 'payment_method' + '}', encodeURIComponent(String(paymentMethod)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'paymentMethod' is not null or undefined
        if (paymentMethod === null || paymentMethod === undefined) {
            throw new Error('Required parameter paymentMethod was null or undefined when calling postPaymentMethodsPaymentMethod.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (acssDebit !== undefined) {
            localVarFormParams['acss_debit'] = ObjectSerializer.serialize(acssDebit, "object");
        }

        if (affirm !== undefined) {
            localVarFormParams['affirm'] = ObjectSerializer.serialize(affirm, "object");
        }

        if (auBecsDebit !== undefined) {
            localVarFormParams['au_becs_debit'] = ObjectSerializer.serialize(auBecsDebit, "object");
        }

        if (bacsDebit !== undefined) {
            localVarFormParams['bacs_debit'] = ObjectSerializer.serialize(bacsDebit, "object");
        }

        if (billingDetails !== undefined) {
            localVarFormParams['billing_details'] = ObjectSerializer.serialize(billingDetails, "BillingDetailsInnerParams");
        }

        if (blik !== undefined) {
            localVarFormParams['blik'] = ObjectSerializer.serialize(blik, "object");
        }

        if (card !== undefined) {
            localVarFormParams['card'] = ObjectSerializer.serialize(card, "UpdateApiParam");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (link !== undefined) {
            localVarFormParams['link'] = ObjectSerializer.serialize(link, "object");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (sepaDebit !== undefined) {
            localVarFormParams['sepa_debit'] = ObjectSerializer.serialize(sepaDebit, "object");
        }

        if (usBankAccount !== undefined) {
            localVarFormParams['us_bank_account'] = ObjectSerializer.serialize(usBankAccount, "UpdateParam");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentMethod");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Attaches a PaymentMethod object to a Customer.</p>  <p>To attach a new PaymentMethod to a customer for future payments, we recommend you use a <a href=\"/docs/api/setup_intents\">SetupIntent</a> or a PaymentIntent with <a href=\"/docs/api/payment_intents/create#create_payment_intent-setup_future_usage\">setup_future_usage</a>. These approaches will perform any necessary steps to set up the PaymentMethod for future payments. Using the <code>/v1/payment_methods/:id/attach</code> endpoint without first using a SetupIntent or PaymentIntent with <code>setup_future_usage</code> does not optimize the PaymentMethod for future use, which makes later declines and payment friction more likely. See <a href=\"/docs/payments/payment-intents#future-usage\">Optimizing cards for future payments</a> for more information about setting up future payments.</p>  <p>To use this PaymentMethod as the default for invoice or subscription payments, set <a href=\"/docs/api/customers/update#update_customer-invoice_settings-default_payment_method\"><code>invoice_settings.default_payment_method</code></a>, on the Customer to the PaymentMethod’s ID.</p>
     * @param paymentMethod 
     * @param customer The ID of the customer to which to attach the PaymentMethod.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postPaymentMethodsPaymentMethodAttach (paymentMethod: string, customer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }> {
        const localVarPath = this.basePath + '/v1/payment_methods/{payment_method}/attach'
            .replace('{' + 'payment_method' + '}', encodeURIComponent(String(paymentMethod)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'paymentMethod' is not null or undefined
        if (paymentMethod === null || paymentMethod === undefined) {
            throw new Error('Required parameter paymentMethod was null or undefined when calling postPaymentMethodsPaymentMethodAttach.');
        }

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postPaymentMethodsPaymentMethodAttach.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentMethod");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Detaches a PaymentMethod object from a Customer. After a PaymentMethod is detached, it can no longer be used for a payment or re-attached to a Customer.</p>
     * @param paymentMethod 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postPaymentMethodsPaymentMethodDetach (paymentMethod: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }> {
        const localVarPath = this.basePath + '/v1/payment_methods/{payment_method}/detach'
            .replace('{' + 'payment_method' + '}', encodeURIComponent(String(paymentMethod)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'paymentMethod' is not null or undefined
        if (paymentMethod === null || paymentMethod === undefined) {
            throw new Error('Required parameter paymentMethod was null or undefined when calling postPaymentMethodsPaymentMethodDetach.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PaymentMethod;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PaymentMethod");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>To send funds to your own bank account, you create a new payout object. Your <a href=\"#balance\">Stripe balance</a> must be able to cover the payout amount, or you’ll receive an “Insufficient Funds” error.</p>  <p>If your API key is in test mode, money won’t actually be sent, though everything else will occur as if in live mode.</p>  <p>If you are creating a manual payout on a Stripe account that uses multiple payment source types, you’ll need to specify the source type balance that the payout should draw from. The <a href=\"#balance_object\">balance object</a> details available and pending amounts by source type.</p>
     * @param amount A positive integer in cents representing how much to payout.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param destination The ID of a bank account or a card to send the payout to. If no destination is supplied, the default external account for the specified currency will be used.
     * @param expand Specifies which fields in the response should be expanded.
     * @param method The method used to send this payout, which can be &#x60;standard&#x60; or &#x60;instant&#x60;. &#x60;instant&#x60; is only supported for payouts to debit cards. (See [Instant payouts for marketplaces for more information](https://stripe.com/blog/instant-payouts-for-marketplaces).)
     * @param sourceType The balance type of your Stripe balance to draw this payout from. Balances for different payment sources are kept separately. You can find the amounts with the balances API. One of &#x60;bank_account&#x60;, &#x60;card&#x60;, or &#x60;fpx&#x60;.
     * @param statementDescriptor A string to be displayed on the recipient\\\&#39;s bank or card statement. This may be at most 22 characters. Attempting to use a &#x60;statement_descriptor&#x60; longer than 22 characters will return an error. Note: Most banks will truncate this information and/or display it inconsistently. Some may not display it at all.
     */
    public async postPayouts (amount: number, currency: string, description?: string, destination?: string, expand?: Array<string>, method?: string, sourceType?: string, statementDescriptor?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Payout;  }> {
        const localVarPath = this.basePath + '/v1/payouts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postPayouts.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postPayouts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (destination !== undefined) {
            localVarFormParams['destination'] = ObjectSerializer.serialize(destination, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (method !== undefined) {
            localVarFormParams['method'] = ObjectSerializer.serialize(method, "string");
        }

        if (sourceType !== undefined) {
            localVarFormParams['source_type'] = ObjectSerializer.serialize(sourceType, "string");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Payout;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Payout");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified payout by setting the values of the parameters passed. Any parameters not provided will be left unchanged. This request accepts only the metadata as arguments.</p>
     * @param payout 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postPayoutsPayout (payout: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Payout;  }> {
        const localVarPath = this.basePath + '/v1/payouts/{payout}'
            .replace('{' + 'payout' + '}', encodeURIComponent(String(payout)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'payout' is not null or undefined
        if (payout === null || payout === undefined) {
            throw new Error('Required parameter payout was null or undefined when calling postPayoutsPayout.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Payout;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Payout");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A previously created payout can be canceled if it has not yet been paid out. Funds will be refunded to your available balance. You may not cancel automatic Stripe payouts.</p>
     * @param payout 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postPayoutsPayoutCancel (payout: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Payout;  }> {
        const localVarPath = this.basePath + '/v1/payouts/{payout}/cancel'
            .replace('{' + 'payout' + '}', encodeURIComponent(String(payout)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'payout' is not null or undefined
        if (payout === null || payout === undefined) {
            throw new Error('Required parameter payout was null or undefined when calling postPayoutsPayoutCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Payout;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Payout");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Reverses a payout by debiting the destination bank account. Only payouts for connected accounts to US bank accounts may be reversed at this time. If the payout is in the <code>pending</code> status, <code>/v1/payouts/:id/cancel</code> should be used instead.</p>  <p>By requesting a reversal via <code>/v1/payouts/:id/reverse</code>, you confirm that the authorized signatory of the selected bank account has authorized the debit on the bank account and that no other authorization is required.</p>
     * @param payout 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postPayoutsPayoutReverse (payout: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Payout;  }> {
        const localVarPath = this.basePath + '/v1/payouts/{payout}/reverse'
            .replace('{' + 'payout' + '}', encodeURIComponent(String(payout)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'payout' is not null or undefined
        if (payout === null || payout === undefined) {
            throw new Error('Required parameter payout was null or undefined when calling postPayoutsPayoutReverse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Payout;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Payout");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>You can now model subscriptions more flexibly using the <a href=\"#prices\">Prices API</a>. It replaces the Plans API and is backwards compatible to simplify your migration.</p>
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param interval Specifies billing frequency. Either &#x60;day&#x60;, &#x60;week&#x60;, &#x60;month&#x60; or &#x60;year&#x60;.
     * @param active Whether the plan is currently available for new subscriptions. Defaults to &#x60;true&#x60;.
     * @param aggregateUsage Specifies a usage aggregation strategy for plans of &#x60;usage_type&#x3D;metered&#x60;. Allowed values are &#x60;sum&#x60; for summing up all usage during a period, &#x60;last_during_period&#x60; for using the last usage record reported within a period, &#x60;last_ever&#x60; for using the last usage record ever (across period bounds) or &#x60;max&#x60; which uses the usage record with the maximum reported usage during a period. Defaults to &#x60;sum&#x60;.
     * @param amount A positive integer in cents (or local equivalent) (or 0 for a free plan) representing how much to charge on a recurring basis.
     * @param amountDecimal Same as &#x60;amount&#x60;, but accepts a decimal value with at most 12 decimal places. Only one of &#x60;amount&#x60; and &#x60;amount_decimal&#x60; can be set.
     * @param billingScheme Describes how to compute the price per period. Either &#x60;per_unit&#x60; or &#x60;tiered&#x60;. &#x60;per_unit&#x60; indicates that the fixed amount (specified in &#x60;amount&#x60;) will be charged per unit in &#x60;quantity&#x60; (for plans with &#x60;usage_type&#x3D;licensed&#x60;), or per unit of total usage (for plans with &#x60;usage_type&#x3D;metered&#x60;). &#x60;tiered&#x60; indicates that the unit pricing will be computed using a tiering strategy as defined using the &#x60;tiers&#x60; and &#x60;tiers_mode&#x60; attributes.
     * @param expand Specifies which fields in the response should be expanded.
     * @param id An identifier randomly generated by Stripe. Used to identify this plan when subscribing a customer. You can optionally override this ID, but the ID must be unique across all plans in your Stripe account. You can, however, use the same plan ID in both live and test modes.
     * @param intervalCount The number of intervals between subscription billings. For example, &#x60;interval&#x3D;month&#x60; and &#x60;interval_count&#x3D;3&#x60; bills every 3 months. Maximum of one year interval allowed (1 year, 12 months, or 52 weeks).
     * @param metadata 
     * @param nickname A brief description of the plan, hidden from customers.
     * @param product 
     * @param tiers Each element represents a pricing tier. This parameter requires &#x60;billing_scheme&#x60; to be set to &#x60;tiered&#x60;. See also the documentation for &#x60;billing_scheme&#x60;.
     * @param tiersMode Defines if the tiering price should be &#x60;graduated&#x60; or &#x60;volume&#x60; based. In &#x60;volume&#x60;-based tiering, the maximum quantity within a period determines the per unit price, in &#x60;graduated&#x60; tiering pricing can successively change as the quantity grows.
     * @param transformUsage 
     * @param trialPeriodDays Default number of trial days when subscribing a customer to this plan using [&#x60;trial_from_plan&#x3D;true&#x60;](https://stripe.com/docs/api#create_subscription-trial_from_plan).
     * @param usageType Configures how the quantity per period should be determined. Can be either &#x60;metered&#x60; or &#x60;licensed&#x60;. &#x60;licensed&#x60; automatically bills the &#x60;quantity&#x60; set when adding it to a subscription. &#x60;metered&#x60; aggregates the total usage based on usage records. Defaults to &#x60;licensed&#x60;.
     */
    public async postPlans (currency: string, interval: string, active?: boolean, aggregateUsage?: string, amount?: number, amountDecimal?: string, billingScheme?: string, expand?: Array<string>, id?: string, intervalCount?: number, metadata?: IndividualSpecsMetadata, nickname?: string, product?: PostPlansRequestProduct, tiers?: Array<Tier>, tiersMode?: string, transformUsage?: TransformUsageParam, trialPeriodDays?: number, usageType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Plan;  }> {
        const localVarPath = this.basePath + '/v1/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postPlans.');
        }

        // verify required parameter 'interval' is not null or undefined
        if (interval === null || interval === undefined) {
            throw new Error('Required parameter interval was null or undefined when calling postPlans.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (aggregateUsage !== undefined) {
            localVarFormParams['aggregate_usage'] = ObjectSerializer.serialize(aggregateUsage, "string");
        }

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (amountDecimal !== undefined) {
            localVarFormParams['amount_decimal'] = ObjectSerializer.serialize(amountDecimal, "string");
        }

        if (billingScheme !== undefined) {
            localVarFormParams['billing_scheme'] = ObjectSerializer.serialize(billingScheme, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (id !== undefined) {
            localVarFormParams['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (interval !== undefined) {
            localVarFormParams['interval'] = ObjectSerializer.serialize(interval, "string");
        }

        if (intervalCount !== undefined) {
            localVarFormParams['interval_count'] = ObjectSerializer.serialize(intervalCount, "number");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (nickname !== undefined) {
            localVarFormParams['nickname'] = ObjectSerializer.serialize(nickname, "string");
        }

        if (product !== undefined) {
            localVarFormParams['product'] = ObjectSerializer.serialize(product, "PostPlansRequestProduct");
        }

        if (tiers !== undefined) {
            localVarFormParams['tiers'] = ObjectSerializer.serialize(tiers, "Array<Tier>");
        }

        if (tiersMode !== undefined) {
            localVarFormParams['tiers_mode'] = ObjectSerializer.serialize(tiersMode, "string");
        }

        if (transformUsage !== undefined) {
            localVarFormParams['transform_usage'] = ObjectSerializer.serialize(transformUsage, "TransformUsageParam");
        }

        if (trialPeriodDays !== undefined) {
            localVarFormParams['trial_period_days'] = ObjectSerializer.serialize(trialPeriodDays, "number");
        }

        if (usageType !== undefined) {
            localVarFormParams['usage_type'] = ObjectSerializer.serialize(usageType, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Plan;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Plan");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified plan by setting the values of the parameters passed. Any parameters not provided are left unchanged. By design, you cannot change a plan’s ID, amount, currency, or billing cycle.</p>
     * @param plan 
     * @param active Whether the plan is currently available for new subscriptions.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param nickname A brief description of the plan, hidden from customers.
     * @param product The product the plan belongs to. This cannot be changed once it has been used in a subscription or subscription schedule.
     * @param trialPeriodDays Default number of trial days when subscribing a customer to this plan using [&#x60;trial_from_plan&#x3D;true&#x60;](https://stripe.com/docs/api#create_subscription-trial_from_plan).
     */
    public async postPlansPlan (plan: string, active?: boolean, expand?: Array<string>, metadata?: IndividualSpecsMetadata, nickname?: string, product?: string, trialPeriodDays?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Plan;  }> {
        const localVarPath = this.basePath + '/v1/plans/{plan}'
            .replace('{' + 'plan' + '}', encodeURIComponent(String(plan)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'plan' is not null or undefined
        if (plan === null || plan === undefined) {
            throw new Error('Required parameter plan was null or undefined when calling postPlansPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (nickname !== undefined) {
            localVarFormParams['nickname'] = ObjectSerializer.serialize(nickname, "string");
        }

        if (product !== undefined) {
            localVarFormParams['product'] = ObjectSerializer.serialize(product, "string");
        }

        if (trialPeriodDays !== undefined) {
            localVarFormParams['trial_period_days'] = ObjectSerializer.serialize(trialPeriodDays, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Plan;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Plan");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new price for an existing product. The price can be recurring or one-time.</p>
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param active Whether the price can be used for new purchases. Defaults to &#x60;true&#x60;.
     * @param billingScheme Describes how to compute the price per period. Either &#x60;per_unit&#x60; or &#x60;tiered&#x60;. &#x60;per_unit&#x60; indicates that the fixed amount (specified in &#x60;unit_amount&#x60; or &#x60;unit_amount_decimal&#x60;) will be charged per unit in &#x60;quantity&#x60; (for prices with &#x60;usage_type&#x3D;licensed&#x60;), or per unit of total usage (for prices with &#x60;usage_type&#x3D;metered&#x60;). &#x60;tiered&#x60; indicates that the unit pricing will be computed using a tiering strategy as defined using the &#x60;tiers&#x60; and &#x60;tiers_mode&#x60; attributes.
     * @param customUnitAmount 
     * @param expand Specifies which fields in the response should be expanded.
     * @param lookupKey A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
     * @param nickname A brief description of the price, hidden from customers.
     * @param product The ID of the product that this price will belong to.
     * @param productData 
     * @param recurring 
     * @param taxBehavior Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of &#x60;inclusive&#x60;, &#x60;exclusive&#x60;, or &#x60;unspecified&#x60;. Once specified as either &#x60;inclusive&#x60; or &#x60;exclusive&#x60;, it cannot be changed.
     * @param tiers Each element represents a pricing tier. This parameter requires &#x60;billing_scheme&#x60; to be set to &#x60;tiered&#x60;. See also the documentation for &#x60;billing_scheme&#x60;.
     * @param tiersMode Defines if the tiering price should be &#x60;graduated&#x60; or &#x60;volume&#x60; based. In &#x60;volume&#x60;-based tiering, the maximum quantity within a period determines the per unit price, in &#x60;graduated&#x60; tiering pricing can successively change as the quantity grows.
     * @param transferLookupKey If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
     * @param transformQuantity 
     * @param unitAmount A positive integer in cents (or local equivalent) (or 0 for a free price) representing how much to charge. One of &#x60;unit_amount&#x60; or &#x60;custom_unit_amount&#x60; is required, unless &#x60;billing_scheme&#x3D;tiered&#x60;.
     * @param unitAmountDecimal Same as &#x60;unit_amount&#x60;, but accepts a decimal value in cents (or local equivalent) with at most 12 decimal places. Only one of &#x60;unit_amount&#x60; and &#x60;unit_amount_decimal&#x60; can be set.
     */
    public async postPrices (currency: string, active?: boolean, billingScheme?: string, customUnitAmount?: CustomUnitAmount1, expand?: Array<string>, lookupKey?: string, nickname?: string, product?: string, productData?: InlineProductParams1, recurring?: Recurring1, taxBehavior?: string, tiers?: Array<Tier>, tiersMode?: string, transferLookupKey?: boolean, transformQuantity?: TransformUsageParam, unitAmount?: number, unitAmountDecimal?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Price;  }> {
        const localVarPath = this.basePath + '/v1/prices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postPrices.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (billingScheme !== undefined) {
            localVarFormParams['billing_scheme'] = ObjectSerializer.serialize(billingScheme, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customUnitAmount !== undefined) {
            localVarFormParams['custom_unit_amount'] = ObjectSerializer.serialize(customUnitAmount, "CustomUnitAmount1");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (lookupKey !== undefined) {
            localVarFormParams['lookup_key'] = ObjectSerializer.serialize(lookupKey, "string");
        }

        if (nickname !== undefined) {
            localVarFormParams['nickname'] = ObjectSerializer.serialize(nickname, "string");
        }

        if (product !== undefined) {
            localVarFormParams['product'] = ObjectSerializer.serialize(product, "string");
        }

        if (productData !== undefined) {
            localVarFormParams['product_data'] = ObjectSerializer.serialize(productData, "InlineProductParams1");
        }

        if (recurring !== undefined) {
            localVarFormParams['recurring'] = ObjectSerializer.serialize(recurring, "Recurring1");
        }

        if (taxBehavior !== undefined) {
            localVarFormParams['tax_behavior'] = ObjectSerializer.serialize(taxBehavior, "string");
        }

        if (tiers !== undefined) {
            localVarFormParams['tiers'] = ObjectSerializer.serialize(tiers, "Array<Tier>");
        }

        if (tiersMode !== undefined) {
            localVarFormParams['tiers_mode'] = ObjectSerializer.serialize(tiersMode, "string");
        }

        if (transferLookupKey !== undefined) {
            localVarFormParams['transfer_lookup_key'] = ObjectSerializer.serialize(transferLookupKey, "boolean");
        }

        if (transformQuantity !== undefined) {
            localVarFormParams['transform_quantity'] = ObjectSerializer.serialize(transformQuantity, "TransformUsageParam");
        }

        if (unitAmount !== undefined) {
            localVarFormParams['unit_amount'] = ObjectSerializer.serialize(unitAmount, "number");
        }

        if (unitAmountDecimal !== undefined) {
            localVarFormParams['unit_amount_decimal'] = ObjectSerializer.serialize(unitAmountDecimal, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Price;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Price");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified price by setting the values of the parameters passed. Any parameters not provided are left unchanged.</p>
     * @param price 
     * @param active Whether the price can be used for new purchases. Defaults to &#x60;true&#x60;.
     * @param currencyOptions 
     * @param expand Specifies which fields in the response should be expanded.
     * @param lookupKey A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.
     * @param metadata 
     * @param nickname A brief description of the price, hidden from customers.
     * @param recurring 
     * @param taxBehavior Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of &#x60;inclusive&#x60;, &#x60;exclusive&#x60;, or &#x60;unspecified&#x60;. Once specified as either &#x60;inclusive&#x60; or &#x60;exclusive&#x60;, it cannot be changed.
     * @param transferLookupKey If set to true, will atomically remove the lookup key from the existing price, and assign it to this price.
     */
    public async postPricesPrice (price: string, active?: boolean, currencyOptions?: PostPricesPriceRequestCurrencyOptions, expand?: Array<string>, lookupKey?: string, metadata?: IndividualSpecsMetadata, nickname?: string, recurring?: PostPricesPriceRequestRecurring, taxBehavior?: string, transferLookupKey?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Price;  }> {
        const localVarPath = this.basePath + '/v1/prices/{price}'
            .replace('{' + 'price' + '}', encodeURIComponent(String(price)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'price' is not null or undefined
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling postPricesPrice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (currencyOptions !== undefined) {
            localVarFormParams['currency_options'] = ObjectSerializer.serialize(currencyOptions, "PostPricesPriceRequestCurrencyOptions");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (lookupKey !== undefined) {
            localVarFormParams['lookup_key'] = ObjectSerializer.serialize(lookupKey, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (nickname !== undefined) {
            localVarFormParams['nickname'] = ObjectSerializer.serialize(nickname, "string");
        }

        if (recurring !== undefined) {
            localVarFormParams['recurring'] = ObjectSerializer.serialize(recurring, "PostPricesPriceRequestRecurring");
        }

        if (taxBehavior !== undefined) {
            localVarFormParams['tax_behavior'] = ObjectSerializer.serialize(taxBehavior, "string");
        }

        if (transferLookupKey !== undefined) {
            localVarFormParams['transfer_lookup_key'] = ObjectSerializer.serialize(transferLookupKey, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Price;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Price");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new product object.</p>
     * @param name The product\\\&#39;s name, meant to be displayable to the customer.
     * @param active Whether the product is currently available for purchase. Defaults to &#x60;true&#x60;.
     * @param attributes A list of up to 5 alphanumeric attributes. Should only be set if type&#x3D;&#x60;good&#x60;.
     * @param caption A short one-line description of the product, meant to be displayable to the customer. May only be set if type&#x3D;&#x60;good&#x60;.
     * @param deactivateOn An array of Connect application names or identifiers that should not be able to order the SKUs for this product. May only be set if type&#x3D;&#x60;good&#x60;.
     * @param defaultPriceData 
     * @param description The product\\\&#39;s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
     * @param expand Specifies which fields in the response should be expanded.
     * @param id An identifier will be randomly generated by Stripe. You can optionally override this ID, but the ID must be unique across all products in your Stripe account.
     * @param images A list of up to 8 URLs of images for this product, meant to be displayable to the customer.
     * @param packageDimensions 
     * @param shippable Whether this product is shipped (i.e., physical goods).
     * @param statementDescriptor An arbitrary string to be displayed on your customer\\\&#39;s credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include &#x60;&lt;&#x60;, &#x60;&gt;&#x60;, &#x60;\\\\&#x60;, &#x60;\\\&quot;&#x60;, &#x60;\\\&#39;&#x60; characters, and will appear on your customer\\\&#39;s statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter.
     * @param taxCode A [tax code](https://stripe.com/docs/tax/tax-categories) ID.
     * @param type The type of the product. Defaults to &#x60;service&#x60; if not explicitly specified, enabling use of this product with Subscriptions and Plans. Set this parameter to &#x60;good&#x60; to use this product with Orders and SKUs. On API versions before &#x60;2018-02-05&#x60;, this field defaults to &#x60;good&#x60; for compatibility reasons.
     * @param unitLabel A label that represents units of this product. When set, this will be included in customers\\\&#39; receipts, invoices, Checkout, and the customer portal.
     * @param url A URL of a publicly-accessible webpage for this product.
     */
    public async postProducts (name: string, active?: boolean, attributes?: Array<string>, caption?: string, deactivateOn?: Array<string>, defaultPriceData?: PriceDataWithoutProduct, description?: string, expand?: Array<string>, id?: string, images?: Array<string>, packageDimensions?: PackageDimensionsSpecs, shippable?: boolean, statementDescriptor?: string, taxCode?: string, type?: string, unitLabel?: string, url?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Product;  }> {
        const localVarPath = this.basePath + '/v1/products';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postProducts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (attributes !== undefined) {
            localVarFormParams['attributes'] = ObjectSerializer.serialize(attributes, "Array<string>");
        }

        if (caption !== undefined) {
            localVarFormParams['caption'] = ObjectSerializer.serialize(caption, "string");
        }

        if (deactivateOn !== undefined) {
            localVarFormParams['deactivate_on'] = ObjectSerializer.serialize(deactivateOn, "Array<string>");
        }

        if (defaultPriceData !== undefined) {
            localVarFormParams['default_price_data'] = ObjectSerializer.serialize(defaultPriceData, "PriceDataWithoutProduct");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (id !== undefined) {
            localVarFormParams['id'] = ObjectSerializer.serialize(id, "string");
        }

        if (images !== undefined) {
            localVarFormParams['images'] = ObjectSerializer.serialize(images, "Array<string>");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (packageDimensions !== undefined) {
            localVarFormParams['package_dimensions'] = ObjectSerializer.serialize(packageDimensions, "PackageDimensionsSpecs");
        }

        if (shippable !== undefined) {
            localVarFormParams['shippable'] = ObjectSerializer.serialize(shippable, "boolean");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (taxCode !== undefined) {
            localVarFormParams['tax_code'] = ObjectSerializer.serialize(taxCode, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (unitLabel !== undefined) {
            localVarFormParams['unit_label'] = ObjectSerializer.serialize(unitLabel, "string");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Product;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Product");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specific product by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param id 
     * @param active Whether the product is available for purchase.
     * @param attributes 
     * @param caption A short one-line description of the product, meant to be displayable to the customer. May only be set if &#x60;type&#x3D;good&#x60;.
     * @param deactivateOn An array of Connect application names or identifiers that should not be able to order the SKUs for this product. May only be set if &#x60;type&#x3D;good&#x60;.
     * @param defaultPrice The ID of the [Price](https://stripe.com/docs/api/prices) object that is the default price for this product.
     * @param description The product\\\&#39;s description, meant to be displayable to the customer. Use this field to optionally store a long form explanation of the product being sold for your own rendering purposes.
     * @param expand Specifies which fields in the response should be expanded.
     * @param images 
     * @param metadata 
     * @param name The product\\\&#39;s name, meant to be displayable to the customer.
     * @param packageDimensions 
     * @param shippable Whether this product is shipped (i.e., physical goods).
     * @param statementDescriptor An arbitrary string to be displayed on your customer\\\&#39;s credit card or bank statement. While most banks display this information consistently, some may display it incorrectly or not at all.  This may be up to 22 characters. The statement description may not include &#x60;&lt;&#x60;, &#x60;&gt;&#x60;, &#x60;\\\\&#x60;, &#x60;\\\&quot;&#x60;, &#x60;\\\&#39;&#x60; characters, and will appear on your customer\\\&#39;s statement in capital letters. Non-ASCII characters are automatically stripped.  It must contain at least one letter. May only be set if &#x60;type&#x3D;service&#x60;.
     * @param taxCode 
     * @param unitLabel A label that represents units of this product. When set, this will be included in customers\\\&#39; receipts, invoices, Checkout, and the customer portal. May only be set if &#x60;type&#x3D;service&#x60;.
     * @param url 
     */
    public async postProductsId (id: string, active?: boolean, attributes?: PostProductsIdRequestAttributes, caption?: string, deactivateOn?: Array<string>, defaultPrice?: string, description?: string, expand?: Array<string>, images?: PostProductsIdRequestImages, metadata?: IndividualSpecsMetadata, name?: string, packageDimensions?: PostProductsIdRequestPackageDimensions, shippable?: boolean, statementDescriptor?: string, taxCode?: PostInvoiceitemsRequestTaxCode, unitLabel?: string, url?: PostProductsIdRequestUrl, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Product;  }> {
        const localVarPath = this.basePath + '/v1/products/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postProductsId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (attributes !== undefined) {
            localVarFormParams['attributes'] = ObjectSerializer.serialize(attributes, "PostProductsIdRequestAttributes");
        }

        if (caption !== undefined) {
            localVarFormParams['caption'] = ObjectSerializer.serialize(caption, "string");
        }

        if (deactivateOn !== undefined) {
            localVarFormParams['deactivate_on'] = ObjectSerializer.serialize(deactivateOn, "Array<string>");
        }

        if (defaultPrice !== undefined) {
            localVarFormParams['default_price'] = ObjectSerializer.serialize(defaultPrice, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (images !== undefined) {
            localVarFormParams['images'] = ObjectSerializer.serialize(images, "PostProductsIdRequestImages");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (packageDimensions !== undefined) {
            localVarFormParams['package_dimensions'] = ObjectSerializer.serialize(packageDimensions, "PostProductsIdRequestPackageDimensions");
        }

        if (shippable !== undefined) {
            localVarFormParams['shippable'] = ObjectSerializer.serialize(shippable, "boolean");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (taxCode !== undefined) {
            localVarFormParams['tax_code'] = ObjectSerializer.serialize(taxCode, "PostInvoiceitemsRequestTaxCode");
        }

        if (unitLabel !== undefined) {
            localVarFormParams['unit_label'] = ObjectSerializer.serialize(unitLabel, "string");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "PostProductsIdRequestUrl");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Product;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Product");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A promotion code points to a coupon. You can optionally restrict the code to a specific customer, redemption limit, and expiration date.</p>
     * @param coupon The coupon for this promotion code.
     * @param active Whether the promotion code is currently active.
     * @param code The customer-facing code. Regardless of case, this code must be unique across all active promotion codes for a specific customer. If left blank, we will generate one automatically.
     * @param customer The customer that this promotion code can be used by. If not set, the promotion code can be used by all customers.
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt The timestamp at which this promotion code will expire. If the coupon has specified a &#x60;redeems_by&#x60;, then this value cannot be after the coupon\\\&#39;s &#x60;redeems_by&#x60;.
     * @param maxRedemptions A positive integer specifying the number of times the promotion code can be redeemed. If the coupon has specified a &#x60;max_redemptions&#x60;, then this value cannot be greater than the coupon\\\&#39;s &#x60;max_redemptions&#x60;.
     * @param restrictions 
     */
    public async postPromotionCodes (coupon: string, active?: boolean, code?: string, customer?: string, expand?: Array<string>, expiresAt?: number, maxRedemptions?: number, restrictions?: RestrictionsParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PromotionCode;  }> {
        const localVarPath = this.basePath + '/v1/promotion_codes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'coupon' is not null or undefined
        if (coupon === null || coupon === undefined) {
            throw new Error('Required parameter coupon was null or undefined when calling postPromotionCodes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (code !== undefined) {
            localVarFormParams['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (coupon !== undefined) {
            localVarFormParams['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "number");
        }

        if (maxRedemptions !== undefined) {
            localVarFormParams['max_redemptions'] = ObjectSerializer.serialize(maxRedemptions, "number");
        }

        if (restrictions !== undefined) {
            localVarFormParams['restrictions'] = ObjectSerializer.serialize(restrictions, "RestrictionsParams");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PromotionCode;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PromotionCode");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified promotion code by setting the values of the parameters passed. Most fields are, by design, not editable.</p>
     * @param promotionCode 
     * @param active Whether the promotion code is currently active. A promotion code can only be reactivated when the coupon is still valid and the promotion code is otherwise redeemable.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param restrictions 
     */
    public async postPromotionCodesPromotionCode (promotionCode: string, active?: boolean, expand?: Array<string>, metadata?: IndividualSpecsMetadata, restrictions?: RestrictionsParams1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: PromotionCode;  }> {
        const localVarPath = this.basePath + '/v1/promotion_codes/{promotion_code}'
            .replace('{' + 'promotion_code' + '}', encodeURIComponent(String(promotionCode)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'promotionCode' is not null or undefined
        if (promotionCode === null || promotionCode === undefined) {
            throw new Error('Required parameter promotionCode was null or undefined when calling postPromotionCodesPromotionCode.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (restrictions !== undefined) {
            localVarFormParams['restrictions'] = ObjectSerializer.serialize(restrictions, "RestrictionsParams1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: PromotionCode;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "PromotionCode");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A quote models prices and services for a customer. Default options for <code>header</code>, <code>description</code>, <code>footer</code>, and <code>expires_at</code> can be set in the dashboard via the <a href=\"https://dashboard.stripe.com/settings/billing/quote\">quote template</a>.</p>
     * @param applicationFeeAmount 
     * @param applicationFeePercent 
     * @param automaticTax 
     * @param collectionMethod Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as &#x60;active&#x60;. Defaults to &#x60;charge_automatically&#x60;.
     * @param customer The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
     * @param defaultTaxRates 
     * @param description A description that will be displayed on the quote PDF. If no value is passed, the default description configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
     * @param discounts 
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt A future timestamp on which the quote will be canceled if in &#x60;open&#x60; or &#x60;draft&#x60; status. Measured in seconds since the Unix epoch. If no value is passed, the default expiration date configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
     * @param footer A footer that will be displayed on the quote PDF. If no value is passed, the default footer configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
     * @param fromQuote 
     * @param header A header that will be displayed on the quote PDF. If no value is passed, the default header configured in your [quote template settings](https://dashboard.stripe.com/settings/billing/quote) will be used.
     * @param invoiceSettings 
     * @param lineItems A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
     * @param onBehalfOf 
     * @param subscriptionData 
     * @param testClock ID of the test clock to attach to the quote.
     * @param transferData 
     */
    public async postQuotes (applicationFeeAmount?: PostQuotesRequestApplicationFeeAmount, applicationFeePercent?: PostQuotesRequestApplicationFeePercent, automaticTax?: AutomaticTaxParam2, collectionMethod?: string, customer?: string, defaultTaxRates?: PostQuotesRequestDefaultTaxRates, description?: string, discounts?: PostQuotesRequestDiscounts, expand?: Array<string>, expiresAt?: number, footer?: string, fromQuote?: FromQuoteParams, header?: string, invoiceSettings?: QuoteParam, lineItems?: Array<LineItemCreateParams>, onBehalfOf?: PostQuotesRequestOnBehalfOf, subscriptionData?: SubscriptionDataCreateParams, testClock?: string, transferData?: PostQuotesRequestTransferData, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Quote;  }> {
        const localVarPath = this.basePath + '/v1/quotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "PostQuotesRequestApplicationFeeAmount");
        }

        if (applicationFeePercent !== undefined) {
            localVarFormParams['application_fee_percent'] = ObjectSerializer.serialize(applicationFeePercent, "PostQuotesRequestApplicationFeePercent");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParam2");
        }

        if (collectionMethod !== undefined) {
            localVarFormParams['collection_method'] = ObjectSerializer.serialize(collectionMethod, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (defaultTaxRates !== undefined) {
            localVarFormParams['default_tax_rates'] = ObjectSerializer.serialize(defaultTaxRates, "PostQuotesRequestDefaultTaxRates");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (discounts !== undefined) {
            localVarFormParams['discounts'] = ObjectSerializer.serialize(discounts, "PostQuotesRequestDiscounts");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "number");
        }

        if (footer !== undefined) {
            localVarFormParams['footer'] = ObjectSerializer.serialize(footer, "string");
        }

        if (fromQuote !== undefined) {
            localVarFormParams['from_quote'] = ObjectSerializer.serialize(fromQuote, "FromQuoteParams");
        }

        if (header !== undefined) {
            localVarFormParams['header'] = ObjectSerializer.serialize(header, "string");
        }

        if (invoiceSettings !== undefined) {
            localVarFormParams['invoice_settings'] = ObjectSerializer.serialize(invoiceSettings, "QuoteParam");
        }

        if (lineItems !== undefined) {
            localVarFormParams['line_items'] = ObjectSerializer.serialize(lineItems, "Array<LineItemCreateParams>");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "PostQuotesRequestOnBehalfOf");
        }

        if (subscriptionData !== undefined) {
            localVarFormParams['subscription_data'] = ObjectSerializer.serialize(subscriptionData, "SubscriptionDataCreateParams");
        }

        if (testClock !== undefined) {
            localVarFormParams['test_clock'] = ObjectSerializer.serialize(testClock, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "PostQuotesRequestTransferData");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Quote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Quote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A quote models prices and services for a customer.</p>
     * @param quote 
     * @param applicationFeeAmount 
     * @param applicationFeePercent 
     * @param automaticTax 
     * @param collectionMethod Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay invoices at the end of the subscription cycle or at invoice finalization using the default payment method attached to the subscription or customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as &#x60;active&#x60;. Defaults to &#x60;charge_automatically&#x60;.
     * @param customer The customer for which this quote belongs to. A customer is required before finalizing the quote. Once specified, it cannot be changed.
     * @param defaultTaxRates 
     * @param description A description that will be displayed on the quote PDF.
     * @param discounts 
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt A future timestamp on which the quote will be canceled if in &#x60;open&#x60; or &#x60;draft&#x60; status. Measured in seconds since the Unix epoch.
     * @param footer A footer that will be displayed on the quote PDF.
     * @param header A header that will be displayed on the quote PDF.
     * @param invoiceSettings 
     * @param lineItems A list of line items the customer is being quoted for. Each line item includes information about the product, the quantity, and the resulting cost.
     * @param onBehalfOf 
     * @param subscriptionData 
     * @param transferData 
     */
    public async postQuotesQuote (quote: string, applicationFeeAmount?: PostQuotesRequestApplicationFeeAmount, applicationFeePercent?: PostQuotesRequestApplicationFeePercent, automaticTax?: AutomaticTaxParam2, collectionMethod?: string, customer?: string, defaultTaxRates?: PostQuotesRequestDefaultTaxRates, description?: string, discounts?: PostQuotesRequestDiscounts, expand?: Array<string>, expiresAt?: number, footer?: string, header?: string, invoiceSettings?: QuoteParam, lineItems?: Array<LineItemUpdateParams>, onBehalfOf?: PostQuotesRequestOnBehalfOf, subscriptionData?: SubscriptionDataUpdateParams, transferData?: PostQuotesRequestTransferData, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Quote;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling postQuotesQuote.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (applicationFeeAmount !== undefined) {
            localVarFormParams['application_fee_amount'] = ObjectSerializer.serialize(applicationFeeAmount, "PostQuotesRequestApplicationFeeAmount");
        }

        if (applicationFeePercent !== undefined) {
            localVarFormParams['application_fee_percent'] = ObjectSerializer.serialize(applicationFeePercent, "PostQuotesRequestApplicationFeePercent");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxParam2");
        }

        if (collectionMethod !== undefined) {
            localVarFormParams['collection_method'] = ObjectSerializer.serialize(collectionMethod, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (defaultTaxRates !== undefined) {
            localVarFormParams['default_tax_rates'] = ObjectSerializer.serialize(defaultTaxRates, "PostQuotesRequestDefaultTaxRates");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (discounts !== undefined) {
            localVarFormParams['discounts'] = ObjectSerializer.serialize(discounts, "PostQuotesRequestDiscounts");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "number");
        }

        if (footer !== undefined) {
            localVarFormParams['footer'] = ObjectSerializer.serialize(footer, "string");
        }

        if (header !== undefined) {
            localVarFormParams['header'] = ObjectSerializer.serialize(header, "string");
        }

        if (invoiceSettings !== undefined) {
            localVarFormParams['invoice_settings'] = ObjectSerializer.serialize(invoiceSettings, "QuoteParam");
        }

        if (lineItems !== undefined) {
            localVarFormParams['line_items'] = ObjectSerializer.serialize(lineItems, "Array<LineItemUpdateParams>");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "PostQuotesRequestOnBehalfOf");
        }

        if (subscriptionData !== undefined) {
            localVarFormParams['subscription_data'] = ObjectSerializer.serialize(subscriptionData, "SubscriptionDataUpdateParams");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "PostQuotesRequestTransferData");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Quote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Quote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Accepts the specified quote.</p>
     * @param quote 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postQuotesQuoteAccept (quote: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Quote;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}/accept'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling postQuotesQuoteAccept.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Quote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Quote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancels the quote.</p>
     * @param quote 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postQuotesQuoteCancel (quote: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Quote;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}/cancel'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling postQuotesQuoteCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Quote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Quote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Finalizes the quote.</p>
     * @param quote 
     * @param expand Specifies which fields in the response should be expanded.
     * @param expiresAt A future timestamp on which the quote will be canceled if in &#x60;open&#x60; or &#x60;draft&#x60; status. Measured in seconds since the Unix epoch.
     */
    public async postQuotesQuoteFinalize (quote: string, expand?: Array<string>, expiresAt?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Quote;  }> {
        const localVarPath = this.basePath + '/v1/quotes/{quote}/finalize'
            .replace('{' + 'quote' + '}', encodeURIComponent(String(quote)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'quote' is not null or undefined
        if (quote === null || quote === undefined) {
            throw new Error('Required parameter quote was null or undefined when calling postQuotesQuoteFinalize.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (expiresAt !== undefined) {
            localVarFormParams['expires_at'] = ObjectSerializer.serialize(expiresAt, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Quote;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Quote");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new <code>ValueListItem</code> object, which is added to the specified parent value list.</p>
     * @param value The value of the item (whose type must match the type of the parent value list).
     * @param valueList The identifier of the value list which the created item will be added to.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postRadarValueListItems (value: string, valueList: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarValueListItem;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_list_items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling postRadarValueListItems.');
        }

        // verify required parameter 'valueList' is not null or undefined
        if (valueList === null || valueList === undefined) {
            throw new Error('Required parameter valueList was null or undefined when calling postRadarValueListItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (value !== undefined) {
            localVarFormParams['value'] = ObjectSerializer.serialize(value, "string");
        }

        if (valueList !== undefined) {
            localVarFormParams['value_list'] = ObjectSerializer.serialize(valueList, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarValueListItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarValueListItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new <code>ValueList</code> object, which can then be referenced in rules.</p>
     * @param alias The name of the value list for use in rules.
     * @param name The human-readable name of the value list.
     * @param expand Specifies which fields in the response should be expanded.
     * @param itemType Type of the items in the value list. One of &#x60;card_fingerprint&#x60;, &#x60;card_bin&#x60;, &#x60;email&#x60;, &#x60;ip_address&#x60;, &#x60;country&#x60;, &#x60;string&#x60;, &#x60;case_sensitive_string&#x60;, or &#x60;customer_id&#x60;. Use &#x60;string&#x60; if the item type is unknown or mixed.
     */
    public async postRadarValueLists (alias: string, name: string, expand?: Array<string>, itemType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarValueList;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_lists';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'alias' is not null or undefined
        if (alias === null || alias === undefined) {
            throw new Error('Required parameter alias was null or undefined when calling postRadarValueLists.');
        }

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postRadarValueLists.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (alias !== undefined) {
            localVarFormParams['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (itemType !== undefined) {
            localVarFormParams['item_type'] = ObjectSerializer.serialize(itemType, "string");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarValueList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarValueList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a <code>ValueList</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged. Note that <code>item_type</code> is immutable.</p>
     * @param valueList 
     * @param alias The name of the value list for use in rules.
     * @param expand Specifies which fields in the response should be expanded.
     * @param name The human-readable name of the value list.
     */
    public async postRadarValueListsValueList (valueList: string, alias?: string, expand?: Array<string>, name?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: RadarValueList;  }> {
        const localVarPath = this.basePath + '/v1/radar/value_lists/{value_list}'
            .replace('{' + 'value_list' + '}', encodeURIComponent(String(valueList)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'valueList' is not null or undefined
        if (valueList === null || valueList === undefined) {
            throw new Error('Required parameter valueList was null or undefined when calling postRadarValueListsValueList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (alias !== undefined) {
            localVarFormParams['alias'] = ObjectSerializer.serialize(alias, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: RadarValueList;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "RadarValueList");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Create a refund.</p>
     * @param amount A positive integer representing how much to refund.
     * @param charge 
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param customer Customer whose customer balance to refund from.
     * @param expand Specifies which fields in the response should be expanded.
     * @param instructionsEmail Address to send refund email, use customer email if not specified
     * @param metadata 
     * @param origin Origin of the refund
     * @param paymentIntent 
     * @param reason 
     * @param refundApplicationFee 
     * @param reverseTransfer 
     */
    public async postRefunds (amount?: number, charge?: string, currency?: string, customer?: string, expand?: Array<string>, instructionsEmail?: string, metadata?: IndividualSpecsMetadata, origin?: string, paymentIntent?: string, reason?: string, refundApplicationFee?: boolean, reverseTransfer?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Refund;  }> {
        const localVarPath = this.basePath + '/v1/refunds';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (charge !== undefined) {
            localVarFormParams['charge'] = ObjectSerializer.serialize(charge, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (instructionsEmail !== undefined) {
            localVarFormParams['instructions_email'] = ObjectSerializer.serialize(instructionsEmail, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (origin !== undefined) {
            localVarFormParams['origin'] = ObjectSerializer.serialize(origin, "string");
        }

        if (paymentIntent !== undefined) {
            localVarFormParams['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (reason !== undefined) {
            localVarFormParams['reason'] = ObjectSerializer.serialize(reason, "string");
        }

        if (refundApplicationFee !== undefined) {
            localVarFormParams['refund_application_fee'] = ObjectSerializer.serialize(refundApplicationFee, "boolean");
        }

        if (reverseTransfer !== undefined) {
            localVarFormParams['reverse_transfer'] = ObjectSerializer.serialize(reverseTransfer, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Refund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Refund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified refund by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request only accepts <code>metadata</code> as an argument.</p>
     * @param refund 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postRefundsRefund (refund: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Refund;  }> {
        const localVarPath = this.basePath + '/v1/refunds/{refund}'
            .replace('{' + 'refund' + '}', encodeURIComponent(String(refund)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'refund' is not null or undefined
        if (refund === null || refund === undefined) {
            throw new Error('Required parameter refund was null or undefined when calling postRefundsRefund.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Refund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Refund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancels a refund with a status of <code>requires_action</code>.</p>  <p>Refunds in other states cannot be canceled, and only refunds for payment methods that require customer action will enter the <code>requires_action</code> state.</p>
     * @param refund 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postRefundsRefundCancel (refund: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Refund;  }> {
        const localVarPath = this.basePath + '/v1/refunds/{refund}/cancel'
            .replace('{' + 'refund' + '}', encodeURIComponent(String(refund)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'refund' is not null or undefined
        if (refund === null || refund === undefined) {
            throw new Error('Required parameter refund was null or undefined when calling postRefundsRefundCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Refund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Refund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new object and begin running the report. (Certain report types require a <a href=\"https://stripe.com/docs/keys#test-live-modes\">live-mode API key</a>.)</p>
     * @param reportType The ID of the [report type](https://stripe.com/docs/reporting/statements/api#report-types) to run, such as &#x60;\\\&quot;balance.summary.1\\\&quot;&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     * @param parameters 
     */
    public async postReportingReportRuns (reportType: string, expand?: Array<string>, parameters?: RunParameterSpecs, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ReportingReportRun;  }> {
        const localVarPath = this.basePath + '/v1/reporting/report_runs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reportType' is not null or undefined
        if (reportType === null || reportType === undefined) {
            throw new Error('Required parameter reportType was null or undefined when calling postReportingReportRuns.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (parameters !== undefined) {
            localVarFormParams['parameters'] = ObjectSerializer.serialize(parameters, "RunParameterSpecs");
        }

        if (reportType !== undefined) {
            localVarFormParams['report_type'] = ObjectSerializer.serialize(reportType, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ReportingReportRun;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ReportingReportRun");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Approves a <code>Review</code> object, closing it and removing it from the list of reviews.</p>
     * @param review 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postReviewsReviewApprove (review: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Review;  }> {
        const localVarPath = this.basePath + '/v1/reviews/{review}/approve'
            .replace('{' + 'review' + '}', encodeURIComponent(String(review)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'review' is not null or undefined
        if (review === null || review === undefined) {
            throw new Error('Required parameter review was null or undefined when calling postReviewsReviewApprove.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Review;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Review");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a SetupIntent object.</p>  <p>After the SetupIntent is created, attach a payment method and <a href=\"/docs/api/setup_intents/confirm\">confirm</a> to collect any required permissions to charge the payment method later.</p>
     * @param attachToSelf If present, the SetupIntent\\\&#39;s payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
     * @param confirm Set to &#x60;true&#x60; to attempt to confirm this SetupIntent immediately. This parameter defaults to &#x60;false&#x60;. If the payment method attached is a card, a return_url may be provided in case additional authentication is required.
     * @param customer ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent\\\&#39;s payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param flowDirections Indicates the directions of money movement for which this payment method is intended to be used.  Include &#x60;inbound&#x60; if you intend to use the payment method as the origin to pull funds from. Include &#x60;outbound&#x60; if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
     * @param mandateData 
     * @param onBehalfOf The Stripe account ID for which this SetupIntent is created.
     * @param paymentMethod ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
     * @param paymentMethodData 
     * @param paymentMethodOptions 
     * @param paymentMethodTypes The list of payment method types (e.g. card) that this SetupIntent is allowed to use. If this is not provided, defaults to [\\\&quot;card\\\&quot;].
     * @param returnUrl The URL to redirect your customer back to after they authenticate or cancel their payment on the payment method\\\&#39;s app or site. If you\\\&#39;d prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter can only be used with [&#x60;confirm&#x3D;true&#x60;](https://stripe.com/docs/api/setup_intents/create#create_setup_intent-confirm).
     * @param singleUse 
     * @param usage Indicates how the payment method is intended to be used in the future. If not provided, this value defaults to &#x60;off_session&#x60;.
     */
    public async postSetupIntents (attachToSelf?: boolean, confirm?: boolean, customer?: string, description?: string, expand?: Array<string>, flowDirections?: Array<string>, mandateData?: SecretKeyParam2, onBehalfOf?: string, paymentMethod?: string, paymentMethodData?: PaymentMethodDataParams1, paymentMethodOptions?: PaymentMethodOptionsParam40, paymentMethodTypes?: Array<string>, returnUrl?: string, singleUse?: SetupIntentSingleUseParams, usage?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SetupIntent;  }> {
        const localVarPath = this.basePath + '/v1/setup_intents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (attachToSelf !== undefined) {
            localVarFormParams['attach_to_self'] = ObjectSerializer.serialize(attachToSelf, "boolean");
        }

        if (confirm !== undefined) {
            localVarFormParams['confirm'] = ObjectSerializer.serialize(confirm, "boolean");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (flowDirections !== undefined) {
            localVarFormParams['flow_directions'] = ObjectSerializer.serialize(flowDirections, "Array<string>");
        }

        if (mandateData !== undefined) {
            localVarFormParams['mandate_data'] = ObjectSerializer.serialize(mandateData, "SecretKeyParam2");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "string");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (paymentMethodData !== undefined) {
            localVarFormParams['payment_method_data'] = ObjectSerializer.serialize(paymentMethodData, "PaymentMethodDataParams1");
        }

        if (paymentMethodOptions !== undefined) {
            localVarFormParams['payment_method_options'] = ObjectSerializer.serialize(paymentMethodOptions, "PaymentMethodOptionsParam40");
        }

        if (paymentMethodTypes !== undefined) {
            localVarFormParams['payment_method_types'] = ObjectSerializer.serialize(paymentMethodTypes, "Array<string>");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        if (singleUse !== undefined) {
            localVarFormParams['single_use'] = ObjectSerializer.serialize(singleUse, "SetupIntentSingleUseParams");
        }

        if (usage !== undefined) {
            localVarFormParams['usage'] = ObjectSerializer.serialize(usage, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SetupIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SetupIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a SetupIntent object.</p>
     * @param intent 
     * @param attachToSelf If present, the SetupIntent\\\&#39;s payment method will be attached to the in-context Stripe Account.  It can only be used for this Stripe Account’s own money movement flows like InboundTransfer and OutboundTransfers. It cannot be set to true when setting up a PaymentMethod for a Customer, and defaults to false when attaching a PaymentMethod to a Customer.
     * @param customer ID of the Customer this SetupIntent belongs to, if one exists.  If present, the SetupIntent\\\&#39;s payment method will be attached to the Customer on successful setup. Payment methods attached to other Customers cannot be used with this SetupIntent.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param flowDirections Indicates the directions of money movement for which this payment method is intended to be used.  Include &#x60;inbound&#x60; if you intend to use the payment method as the origin to pull funds from. Include &#x60;outbound&#x60; if you intend to use the payment method as the destination to send funds to. You can include both if you intend to use the payment method for both purposes.
     * @param metadata 
     * @param paymentMethod ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
     * @param paymentMethodData 
     * @param paymentMethodOptions 
     * @param paymentMethodTypes The list of payment method types (e.g. card) that this SetupIntent is allowed to set up. If this is not provided, defaults to [\\\&quot;card\\\&quot;].
     */
    public async postSetupIntentsIntent (intent: string, attachToSelf?: boolean, customer?: string, description?: string, expand?: Array<string>, flowDirections?: Array<string>, metadata?: IndividualSpecsMetadata, paymentMethod?: string, paymentMethodData?: PaymentMethodDataParams1, paymentMethodOptions?: PaymentMethodOptionsParam40, paymentMethodTypes?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SetupIntent;  }> {
        const localVarPath = this.basePath + '/v1/setup_intents/{intent}'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postSetupIntentsIntent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (attachToSelf !== undefined) {
            localVarFormParams['attach_to_self'] = ObjectSerializer.serialize(attachToSelf, "boolean");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (flowDirections !== undefined) {
            localVarFormParams['flow_directions'] = ObjectSerializer.serialize(flowDirections, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (paymentMethodData !== undefined) {
            localVarFormParams['payment_method_data'] = ObjectSerializer.serialize(paymentMethodData, "PaymentMethodDataParams1");
        }

        if (paymentMethodOptions !== undefined) {
            localVarFormParams['payment_method_options'] = ObjectSerializer.serialize(paymentMethodOptions, "PaymentMethodOptionsParam40");
        }

        if (paymentMethodTypes !== undefined) {
            localVarFormParams['payment_method_types'] = ObjectSerializer.serialize(paymentMethodTypes, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SetupIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SetupIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A SetupIntent object can be canceled when it is in one of these statuses: <code>requires_payment_method</code>, <code>requires_confirmation</code>, or <code>requires_action</code>. </p>  <p>Once canceled, setup is abandoned and any operations on the SetupIntent will fail with an error.</p>
     * @param intent 
     * @param cancellationReason Reason for canceling this SetupIntent. Possible values are &#x60;abandoned&#x60;, &#x60;requested_by_customer&#x60;, or &#x60;duplicate&#x60;
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postSetupIntentsIntentCancel (intent: string, cancellationReason?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SetupIntent;  }> {
        const localVarPath = this.basePath + '/v1/setup_intents/{intent}/cancel'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postSetupIntentsIntentCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cancellationReason !== undefined) {
            localVarFormParams['cancellation_reason'] = ObjectSerializer.serialize(cancellationReason, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SetupIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SetupIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Confirm that your customer intends to set up the current or provided payment method. For example, you would confirm a SetupIntent when a customer hits the “Save” button on a payment method management page on your website.</p>  <p>If the selected payment method does not require any additional steps from the customer, the SetupIntent will transition to the <code>succeeded</code> status.</p>  <p>Otherwise, it will transition to the <code>requires_action</code> status and suggest additional actions via <code>next_action</code>. If setup fails, the SetupIntent will transition to the <code>requires_payment_method</code> status.</p>
     * @param intent 
     * @param expand Specifies which fields in the response should be expanded.
     * @param mandateData 
     * @param paymentMethod ID of the payment method (a PaymentMethod, Card, or saved Source object) to attach to this SetupIntent.
     * @param paymentMethodData 
     * @param paymentMethodOptions 
     * @param returnUrl The URL to redirect your customer back to after they authenticate on the payment method\\\&#39;s app or site. If you\\\&#39;d prefer to redirect to a mobile application, you can alternatively supply an application URI scheme. This parameter is only used for cards and other redirect-based payment methods.
     */
    public async postSetupIntentsIntentConfirm (intent: string, expand?: Array<string>, mandateData?: PostPaymentIntentsIntentConfirmRequestMandateData, paymentMethod?: string, paymentMethodData?: PaymentMethodDataParams1, paymentMethodOptions?: PaymentMethodOptionsParam40, returnUrl?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SetupIntent;  }> {
        const localVarPath = this.basePath + '/v1/setup_intents/{intent}/confirm'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postSetupIntentsIntentConfirm.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (mandateData !== undefined) {
            localVarFormParams['mandate_data'] = ObjectSerializer.serialize(mandateData, "PostPaymentIntentsIntentConfirmRequestMandateData");
        }

        if (paymentMethod !== undefined) {
            localVarFormParams['payment_method'] = ObjectSerializer.serialize(paymentMethod, "string");
        }

        if (paymentMethodData !== undefined) {
            localVarFormParams['payment_method_data'] = ObjectSerializer.serialize(paymentMethodData, "PaymentMethodDataParams1");
        }

        if (paymentMethodOptions !== undefined) {
            localVarFormParams['payment_method_options'] = ObjectSerializer.serialize(paymentMethodOptions, "PaymentMethodOptionsParam40");
        }

        if (returnUrl !== undefined) {
            localVarFormParams['return_url'] = ObjectSerializer.serialize(returnUrl, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SetupIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SetupIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Verifies microdeposits on a SetupIntent object.</p>
     * @param intent 
     * @param amounts Two positive integers, in *cents*, equal to the values of the microdeposits sent to the bank account.
     * @param descriptorCode A six-character code starting with SM present in the microdeposit sent to the bank account.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postSetupIntentsIntentVerifyMicrodeposits (intent: string, amounts?: Array<number>, descriptorCode?: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SetupIntent;  }> {
        const localVarPath = this.basePath + '/v1/setup_intents/{intent}/verify_microdeposits'
            .replace('{' + 'intent' + '}', encodeURIComponent(String(intent)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'intent' is not null or undefined
        if (intent === null || intent === undefined) {
            throw new Error('Required parameter intent was null or undefined when calling postSetupIntentsIntentVerifyMicrodeposits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amounts !== undefined) {
            localVarFormParams['amounts'] = ObjectSerializer.serialize(amounts, "Array<number>");
        }

        if (descriptorCode !== undefined) {
            localVarFormParams['descriptor_code'] = ObjectSerializer.serialize(descriptorCode, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SetupIntent;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SetupIntent");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new shipping rate object.</p>
     * @param displayName The name of the shipping rate, meant to be displayable to the customer. This will appear on CheckoutSessions.
     * @param deliveryEstimate 
     * @param expand Specifies which fields in the response should be expanded.
     * @param fixedAmount 
     * @param taxBehavior Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of &#x60;inclusive&#x60;, &#x60;exclusive&#x60;, or &#x60;unspecified&#x60;.
     * @param taxCode A [tax code](https://stripe.com/docs/tax/tax-categories) ID. The Shipping tax code is &#x60;txcd_92010001&#x60;.
     * @param type The type of calculation to use on the shipping rate. Can only be &#x60;fixed_amount&#x60; for now.
     */
    public async postShippingRates (displayName: string, deliveryEstimate?: DeliveryEstimate, expand?: Array<string>, fixedAmount?: FixedAmount, taxBehavior?: string, taxCode?: string, type?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ShippingRate;  }> {
        const localVarPath = this.basePath + '/v1/shipping_rates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'displayName' is not null or undefined
        if (displayName === null || displayName === undefined) {
            throw new Error('Required parameter displayName was null or undefined when calling postShippingRates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (deliveryEstimate !== undefined) {
            localVarFormParams['delivery_estimate'] = ObjectSerializer.serialize(deliveryEstimate, "DeliveryEstimate");
        }

        if (displayName !== undefined) {
            localVarFormParams['display_name'] = ObjectSerializer.serialize(displayName, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (fixedAmount !== undefined) {
            localVarFormParams['fixed_amount'] = ObjectSerializer.serialize(fixedAmount, "FixedAmount");
        }

        if (taxBehavior !== undefined) {
            localVarFormParams['tax_behavior'] = ObjectSerializer.serialize(taxBehavior, "string");
        }

        if (taxCode !== undefined) {
            localVarFormParams['tax_code'] = ObjectSerializer.serialize(taxCode, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ShippingRate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ShippingRate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing shipping rate object.</p>
     * @param shippingRateToken 
     * @param active Whether the shipping rate can be used for new purchases. Defaults to &#x60;true&#x60;.
     * @param expand Specifies which fields in the response should be expanded.
     * @param fixedAmount 
     * @param metadata 
     * @param taxBehavior Specifies whether the rate is considered inclusive of taxes or exclusive of taxes. One of &#x60;inclusive&#x60;, &#x60;exclusive&#x60;, or &#x60;unspecified&#x60;.
     */
    public async postShippingRatesShippingRateToken (shippingRateToken: string, active?: boolean, expand?: Array<string>, fixedAmount?: FixedAmountUpdate, metadata?: IndividualSpecsMetadata, taxBehavior?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: ShippingRate;  }> {
        const localVarPath = this.basePath + '/v1/shipping_rates/{shipping_rate_token}'
            .replace('{' + 'shipping_rate_token' + '}', encodeURIComponent(String(shippingRateToken)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'shippingRateToken' is not null or undefined
        if (shippingRateToken === null || shippingRateToken === undefined) {
            throw new Error('Required parameter shippingRateToken was null or undefined when calling postShippingRatesShippingRateToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (fixedAmount !== undefined) {
            localVarFormParams['fixed_amount'] = ObjectSerializer.serialize(fixedAmount, "FixedAmountUpdate");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (taxBehavior !== undefined) {
            localVarFormParams['tax_behavior'] = ObjectSerializer.serialize(taxBehavior, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: ShippingRate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "ShippingRate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new source object.</p>
     * @param amount Amount associated with the source. This is the amount for which the source will be chargeable once ready. Required for &#x60;single_use&#x60; sources. Not supported for &#x60;receiver&#x60; type sources, where charge amount may not be specified until funds land.
     * @param currency Three-letter [ISO code for the currency](https://stripe.com/docs/currencies) associated with the source. This is the currency for which the source will be chargeable once ready.
     * @param customer The &#x60;Customer&#x60; to whom the original source is attached to. Must be set when the original source is not a &#x60;Source&#x60; (e.g., &#x60;Card&#x60;).
     * @param expand Specifies which fields in the response should be expanded.
     * @param flow The authentication &#x60;flow&#x60; of the source to create. &#x60;flow&#x60; is one of &#x60;redirect&#x60;, &#x60;receiver&#x60;, &#x60;code_verification&#x60;, &#x60;none&#x60;. It is generally inferred unless a type supports multiple flows.
     * @param mandate 
     * @param originalSource The source to share.
     * @param owner 
     * @param receiver 
     * @param redirect 
     * @param sourceOrder 
     * @param statementDescriptor An arbitrary string to be displayed on your customer\\\&#39;s statement. As an example, if your website is &#x60;RunClub&#x60; and the item you\\\&#39;re charging for is a race ticket, you may want to specify a &#x60;statement_descriptor&#x60; of &#x60;RunClub 5K race ticket.&#x60; While many payment types will display this information, some may not display it at all.
     * @param token An optional token used to create the source. When passed, token properties will override source parameters.
     * @param type The &#x60;type&#x60; of the source to create. Required unless &#x60;customer&#x60; and &#x60;original_source&#x60; are specified (see the [Cloning card Sources](https://stripe.com/docs/sources/connect#cloning-card-sources) guide)
     * @param usage 
     */
    public async postSources (amount?: number, currency?: string, customer?: string, expand?: Array<string>, flow?: string, mandate?: MandateParams, originalSource?: string, owner?: Owner1, receiver?: ReceiverParams, redirect?: RedirectParams, sourceOrder?: ShallowOrderSpecs, statementDescriptor?: string, token?: string, type?: string, usage?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Source;  }> {
        const localVarPath = this.basePath + '/v1/sources';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (flow !== undefined) {
            localVarFormParams['flow'] = ObjectSerializer.serialize(flow, "string");
        }

        if (mandate !== undefined) {
            localVarFormParams['mandate'] = ObjectSerializer.serialize(mandate, "MandateParams");
        }

        if (originalSource !== undefined) {
            localVarFormParams['original_source'] = ObjectSerializer.serialize(originalSource, "string");
        }

        if (owner !== undefined) {
            localVarFormParams['owner'] = ObjectSerializer.serialize(owner, "Owner1");
        }

        if (receiver !== undefined) {
            localVarFormParams['receiver'] = ObjectSerializer.serialize(receiver, "ReceiverParams");
        }

        if (redirect !== undefined) {
            localVarFormParams['redirect'] = ObjectSerializer.serialize(redirect, "RedirectParams");
        }

        if (sourceOrder !== undefined) {
            localVarFormParams['source_order'] = ObjectSerializer.serialize(sourceOrder, "ShallowOrderSpecs");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (token !== undefined) {
            localVarFormParams['token'] = ObjectSerializer.serialize(token, "string");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (usage !== undefined) {
            localVarFormParams['usage'] = ObjectSerializer.serialize(usage, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Source;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Source");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified source by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request accepts the <code>metadata</code> and <code>owner</code> as arguments. It is also possible to update type specific information for selected payment methods. Please refer to our <a href=\"/docs/sources\">payment method guides</a> for more detail.</p>
     * @param source 
     * @param amount Amount associated with the source.
     * @param expand Specifies which fields in the response should be expanded.
     * @param mandate 
     * @param metadata 
     * @param owner 
     * @param sourceOrder 
     */
    public async postSourcesSource (source: string, amount?: number, expand?: Array<string>, mandate?: MandateParams, metadata?: IndividualSpecsMetadata, owner?: Owner1, sourceOrder?: OrderParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Source;  }> {
        const localVarPath = this.basePath + '/v1/sources/{source}'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling postSourcesSource.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (mandate !== undefined) {
            localVarFormParams['mandate'] = ObjectSerializer.serialize(mandate, "MandateParams");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (owner !== undefined) {
            localVarFormParams['owner'] = ObjectSerializer.serialize(owner, "Owner1");
        }

        if (sourceOrder !== undefined) {
            localVarFormParams['source_order'] = ObjectSerializer.serialize(sourceOrder, "OrderParams");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Source;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Source");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Verify a given source.</p>
     * @param source 
     * @param values The values needed to verify the source.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postSourcesSourceVerify (source: string, values: Array<string>, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Source;  }> {
        const localVarPath = this.basePath + '/v1/sources/{source}/verify'
            .replace('{' + 'source' + '}', encodeURIComponent(String(source)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'source' is not null or undefined
        if (source === null || source === undefined) {
            throw new Error('Required parameter source was null or undefined when calling postSourcesSourceVerify.');
        }

        // verify required parameter 'values' is not null or undefined
        if (values === null || values === undefined) {
            throw new Error('Required parameter values was null or undefined when calling postSourcesSourceVerify.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (values !== undefined) {
            localVarFormParams['values'] = ObjectSerializer.serialize(values, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Source;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Source");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Adds a new item to an existing subscription. No existing items will be changed or replaced.</p>
     * @param subscription The identifier of the subscription to modify.
     * @param billingThresholds 
     * @param expand Specifies which fields in the response should be expanded.
     * @param paymentBehavior Use &#x60;allow_incomplete&#x60; to transition the subscription to &#x60;status&#x3D;past_due&#x60; if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription\\\&#39;s invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use &#x60;default_incomplete&#x60; to transition the subscription to &#x60;status&#x3D;past_due&#x60; when payment is required and await explicit confirmation of the invoice\\\&#39;s payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use &#x60;pending_if_incomplete&#x60; to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use &#x60;pending_if_incomplete&#x60; you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use &#x60;error_if_incomplete&#x60; if you want Stripe to return an HTTP 402 status code if a subscription\\\&#39;s invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
     * @param plan The identifier of the plan to add to the subscription.
     * @param price The ID of the price object.
     * @param priceData 
     * @param prorationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting &#x60;billing_cycle_anchor&#x3D;now&#x60;, or starting a trial), or if an item\\\&#39;s &#x60;quantity&#x60; changes. The default value is &#x60;create_prorations&#x60;.
     * @param prorationDate If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
     * @param quantity The quantity you\\\&#39;d like to apply to the subscription item you\\\&#39;re creating.
     * @param taxRates 
     */
    public async postSubscriptionItems (subscription: string, billingThresholds?: SubscriptionItemUpdateParamsBillingThresholds, expand?: Array<string>, paymentBehavior?: string, plan?: string, price?: string, priceData?: RecurringPriceData, prorationBehavior?: string, prorationDate?: number, quantity?: number, taxRates?: SubscriptionItemUpdateParamsTaxRates, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionItem;  }> {
        const localVarPath = this.basePath + '/v1/subscription_items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscription' is not null or undefined
        if (subscription === null || subscription === undefined) {
            throw new Error('Required parameter subscription was null or undefined when calling postSubscriptionItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (billingThresholds !== undefined) {
            localVarFormParams['billing_thresholds'] = ObjectSerializer.serialize(billingThresholds, "SubscriptionItemUpdateParamsBillingThresholds");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (paymentBehavior !== undefined) {
            localVarFormParams['payment_behavior'] = ObjectSerializer.serialize(paymentBehavior, "string");
        }

        if (plan !== undefined) {
            localVarFormParams['plan'] = ObjectSerializer.serialize(plan, "string");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "string");
        }

        if (priceData !== undefined) {
            localVarFormParams['price_data'] = ObjectSerializer.serialize(priceData, "RecurringPriceData");
        }

        if (prorationBehavior !== undefined) {
            localVarFormParams['proration_behavior'] = ObjectSerializer.serialize(prorationBehavior, "string");
        }

        if (prorationDate !== undefined) {
            localVarFormParams['proration_date'] = ObjectSerializer.serialize(prorationDate, "number");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (subscription !== undefined) {
            localVarFormParams['subscription'] = ObjectSerializer.serialize(subscription, "string");
        }

        if (taxRates !== undefined) {
            localVarFormParams['tax_rates'] = ObjectSerializer.serialize(taxRates, "SubscriptionItemUpdateParamsTaxRates");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the plan or quantity of an item on a current subscription.</p>
     * @param item 
     * @param billingThresholds 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param offSession Indicates if a customer is on or off-session while an invoice payment is attempted.
     * @param paymentBehavior Use &#x60;allow_incomplete&#x60; to transition the subscription to &#x60;status&#x3D;past_due&#x60; if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription\\\&#39;s invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use &#x60;default_incomplete&#x60; to transition the subscription to &#x60;status&#x3D;past_due&#x60; when payment is required and await explicit confirmation of the invoice\\\&#39;s payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use &#x60;pending_if_incomplete&#x60; to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use &#x60;pending_if_incomplete&#x60; you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use &#x60;error_if_incomplete&#x60; if you want Stripe to return an HTTP 402 status code if a subscription\\\&#39;s invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
     * @param plan The identifier of the new plan for this subscription item.
     * @param price The ID of the price object. When changing a subscription item\\\&#39;s price, &#x60;quantity&#x60; is set to 1 unless a &#x60;quantity&#x60; parameter is provided.
     * @param priceData 
     * @param prorationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting &#x60;billing_cycle_anchor&#x3D;now&#x60;, or starting a trial), or if an item\\\&#39;s &#x60;quantity&#x60; changes. The default value is &#x60;create_prorations&#x60;.
     * @param prorationDate If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply the same proration that was previewed with the [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
     * @param quantity The quantity you\\\&#39;d like to apply to the subscription item you\\\&#39;re creating.
     * @param taxRates 
     */
    public async postSubscriptionItemsItem (item: string, billingThresholds?: SubscriptionItemUpdateParamsBillingThresholds, expand?: Array<string>, metadata?: IndividualSpecsMetadata, offSession?: boolean, paymentBehavior?: string, plan?: string, price?: string, priceData?: RecurringPriceData, prorationBehavior?: string, prorationDate?: number, quantity?: number, taxRates?: SubscriptionItemUpdateParamsTaxRates, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionItem;  }> {
        const localVarPath = this.basePath + '/v1/subscription_items/{item}'
            .replace('{' + 'item' + '}', encodeURIComponent(String(item)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'item' is not null or undefined
        if (item === null || item === undefined) {
            throw new Error('Required parameter item was null or undefined when calling postSubscriptionItemsItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (billingThresholds !== undefined) {
            localVarFormParams['billing_thresholds'] = ObjectSerializer.serialize(billingThresholds, "SubscriptionItemUpdateParamsBillingThresholds");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (offSession !== undefined) {
            localVarFormParams['off_session'] = ObjectSerializer.serialize(offSession, "boolean");
        }

        if (paymentBehavior !== undefined) {
            localVarFormParams['payment_behavior'] = ObjectSerializer.serialize(paymentBehavior, "string");
        }

        if (plan !== undefined) {
            localVarFormParams['plan'] = ObjectSerializer.serialize(plan, "string");
        }

        if (price !== undefined) {
            localVarFormParams['price'] = ObjectSerializer.serialize(price, "string");
        }

        if (priceData !== undefined) {
            localVarFormParams['price_data'] = ObjectSerializer.serialize(priceData, "RecurringPriceData");
        }

        if (prorationBehavior !== undefined) {
            localVarFormParams['proration_behavior'] = ObjectSerializer.serialize(prorationBehavior, "string");
        }

        if (prorationDate !== undefined) {
            localVarFormParams['proration_date'] = ObjectSerializer.serialize(prorationDate, "number");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (taxRates !== undefined) {
            localVarFormParams['tax_rates'] = ObjectSerializer.serialize(taxRates, "SubscriptionItemUpdateParamsTaxRates");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionItem;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionItem");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a usage record for a specified subscription item and date, and fills it with a quantity.</p>  <p>Usage records provide <code>quantity</code> information that Stripe uses to track how much a customer is using your service. With usage information and the pricing model set up by the <a href=\"https://stripe.com/docs/billing/subscriptions/metered-billing\">metered billing</a> plan, Stripe helps you send accurate invoices to your customers.</p>  <p>The default calculation for usage is to add up all the <code>quantity</code> values of the usage records within a billing period. You can change this default behavior with the billing plan’s <code>aggregate_usage</code> <a href=\"/docs/api/plans/create#create_plan-aggregate_usage\">parameter</a>. When there is more than one usage record with the same timestamp, Stripe adds the <code>quantity</code> values together. In most cases, this is the desired resolution, however, you can change this behavior with the <code>action</code> parameter.</p>  <p>The default pricing model for metered billing is <a href=\"/docs/api/plans/object#plan_object-billing_scheme\">per-unit pricing</a>. For finer granularity, you can configure metered billing to have a <a href=\"https://stripe.com/docs/billing/subscriptions/tiers\">tiered pricing</a> model.</p>
     * @param subscriptionItem 
     * @param quantity The usage quantity for the specified timestamp.
     * @param action Valid values are &#x60;increment&#x60; (default) or &#x60;set&#x60;. When using &#x60;increment&#x60; the specified &#x60;quantity&#x60; will be added to the usage at the specified timestamp. The &#x60;set&#x60; action will overwrite the usage quantity at that timestamp. If the subscription has [billing thresholds](https://stripe.com/docs/api/subscriptions/object#subscription_object-billing_thresholds), &#x60;increment&#x60; is the only allowed value.
     * @param expand Specifies which fields in the response should be expanded.
     * @param timestamp 
     */
    public async postSubscriptionItemsSubscriptionItemUsageRecords (subscriptionItem: string, quantity: number, action?: string, expand?: Array<string>, timestamp?: PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: UsageRecord;  }> {
        const localVarPath = this.basePath + '/v1/subscription_items/{subscription_item}/usage_records'
            .replace('{' + 'subscription_item' + '}', encodeURIComponent(String(subscriptionItem)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionItem' is not null or undefined
        if (subscriptionItem === null || subscriptionItem === undefined) {
            throw new Error('Required parameter subscriptionItem was null or undefined when calling postSubscriptionItemsSubscriptionItemUsageRecords.');
        }

        // verify required parameter 'quantity' is not null or undefined
        if (quantity === null || quantity === undefined) {
            throw new Error('Required parameter quantity was null or undefined when calling postSubscriptionItemsSubscriptionItemUsageRecords.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (action !== undefined) {
            localVarFormParams['action'] = ObjectSerializer.serialize(action, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (quantity !== undefined) {
            localVarFormParams['quantity'] = ObjectSerializer.serialize(quantity, "number");
        }

        if (timestamp !== undefined) {
            localVarFormParams['timestamp'] = ObjectSerializer.serialize(timestamp, "PostSubscriptionItemsSubscriptionItemUsageRecordsRequestTimestamp");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: UsageRecord;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "UsageRecord");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new subscription schedule object. Each customer can have up to 500 active or scheduled subscriptions.</p>
     * @param customer The identifier of the customer to create the subscription schedule for.
     * @param defaultSettings 
     * @param endBehavior Behavior of the subscription schedule and underlying subscription when it ends. Possible values are &#x60;release&#x60; or &#x60;cancel&#x60; with the default being &#x60;release&#x60;. &#x60;release&#x60; will end the subscription schedule and keep the underlying subscription running.&#x60;cancel&#x60; will end the subscription schedule and cancel the underlying subscription.
     * @param expand Specifies which fields in the response should be expanded.
     * @param fromSubscription Migrate an existing subscription to be managed by a subscription schedule. If this parameter is set, a subscription schedule will be created using the subscription\\\&#39;s item(s), set to auto-renew using the subscription\\\&#39;s interval. When using this parameter, other parameters (such as phase values) cannot be set. To create a subscription schedule with other modifications, we recommend making two separate API calls.
     * @param metadata 
     * @param phases List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the &#x60;end_date&#x60; of one phase will always equal the &#x60;start_date&#x60; of the next phase.
     * @param startDate 
     */
    public async postSubscriptionSchedules (customer?: string, defaultSettings?: DefaultSettingsParams, endBehavior?: string, expand?: Array<string>, fromSubscription?: string, metadata?: IndividualSpecsMetadata, phases?: Array<PhaseConfigurationParams>, startDate?: PostSubscriptionSchedulesRequestStartDate, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }> {
        const localVarPath = this.basePath + '/v1/subscription_schedules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (defaultSettings !== undefined) {
            localVarFormParams['default_settings'] = ObjectSerializer.serialize(defaultSettings, "DefaultSettingsParams");
        }

        if (endBehavior !== undefined) {
            localVarFormParams['end_behavior'] = ObjectSerializer.serialize(endBehavior, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (fromSubscription !== undefined) {
            localVarFormParams['from_subscription'] = ObjectSerializer.serialize(fromSubscription, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (phases !== undefined) {
            localVarFormParams['phases'] = ObjectSerializer.serialize(phases, "Array<PhaseConfigurationParams>");
        }

        if (startDate !== undefined) {
            localVarFormParams['start_date'] = ObjectSerializer.serialize(startDate, "PostSubscriptionSchedulesRequestStartDate");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionSchedule");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing subscription schedule.</p>
     * @param schedule 
     * @param defaultSettings 
     * @param endBehavior Behavior of the subscription schedule and underlying subscription when it ends. Possible values are &#x60;release&#x60; or &#x60;cancel&#x60; with the default being &#x60;release&#x60;. &#x60;release&#x60; will end the subscription schedule and keep the underlying subscription running.&#x60;cancel&#x60; will end the subscription schedule and cancel the underlying subscription.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param phases List representing phases of the subscription schedule. Each phase can be customized to have different durations, plans, and coupons. If there are multiple phases, the &#x60;end_date&#x60; of one phase will always equal the &#x60;start_date&#x60; of the next phase. Note that past phases can be omitted.
     * @param prorationBehavior If the update changes the current phase, indicates whether the changes should be prorated. The default value is &#x60;create_prorations&#x60;.
     */
    public async postSubscriptionSchedulesSchedule (schedule: string, defaultSettings?: DefaultSettingsParams, endBehavior?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, phases?: Array<PhaseConfigurationParams1>, prorationBehavior?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }> {
        const localVarPath = this.basePath + '/v1/subscription_schedules/{schedule}'
            .replace('{' + 'schedule' + '}', encodeURIComponent(String(schedule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'schedule' is not null or undefined
        if (schedule === null || schedule === undefined) {
            throw new Error('Required parameter schedule was null or undefined when calling postSubscriptionSchedulesSchedule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (defaultSettings !== undefined) {
            localVarFormParams['default_settings'] = ObjectSerializer.serialize(defaultSettings, "DefaultSettingsParams");
        }

        if (endBehavior !== undefined) {
            localVarFormParams['end_behavior'] = ObjectSerializer.serialize(endBehavior, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (phases !== undefined) {
            localVarFormParams['phases'] = ObjectSerializer.serialize(phases, "Array<PhaseConfigurationParams1>");
        }

        if (prorationBehavior !== undefined) {
            localVarFormParams['proration_behavior'] = ObjectSerializer.serialize(prorationBehavior, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionSchedule");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancels a subscription schedule and its associated subscription immediately (if the subscription schedule has an active subscription). A subscription schedule can only be canceled if its status is <code>not_started</code> or <code>active</code>.</p>
     * @param schedule 
     * @param expand Specifies which fields in the response should be expanded.
     * @param invoiceNow If the subscription schedule is &#x60;active&#x60;, indicates if a final invoice will be generated that contains any un-invoiced metered usage and new/pending proration invoice items. Defaults to &#x60;true&#x60;.
     * @param prorate If the subscription schedule is &#x60;active&#x60;, indicates if the cancellation should be prorated. Defaults to &#x60;true&#x60;.
     */
    public async postSubscriptionSchedulesScheduleCancel (schedule: string, expand?: Array<string>, invoiceNow?: boolean, prorate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }> {
        const localVarPath = this.basePath + '/v1/subscription_schedules/{schedule}/cancel'
            .replace('{' + 'schedule' + '}', encodeURIComponent(String(schedule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'schedule' is not null or undefined
        if (schedule === null || schedule === undefined) {
            throw new Error('Required parameter schedule was null or undefined when calling postSubscriptionSchedulesScheduleCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (invoiceNow !== undefined) {
            localVarFormParams['invoice_now'] = ObjectSerializer.serialize(invoiceNow, "boolean");
        }

        if (prorate !== undefined) {
            localVarFormParams['prorate'] = ObjectSerializer.serialize(prorate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionSchedule");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Releases the subscription schedule immediately, which will stop scheduling of its phases, but leave any existing subscription in place. A schedule can only be released if its status is <code>not_started</code> or <code>active</code>. If the subscription schedule is currently associated with a subscription, releasing it will remove its <code>subscription</code> property and set the subscription’s ID to the <code>released_subscription</code> property.</p>
     * @param schedule 
     * @param expand Specifies which fields in the response should be expanded.
     * @param preserveCancelDate Keep any cancellation on the subscription that the schedule has set
     */
    public async postSubscriptionSchedulesScheduleRelease (schedule: string, expand?: Array<string>, preserveCancelDate?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }> {
        const localVarPath = this.basePath + '/v1/subscription_schedules/{schedule}/release'
            .replace('{' + 'schedule' + '}', encodeURIComponent(String(schedule)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'schedule' is not null or undefined
        if (schedule === null || schedule === undefined) {
            throw new Error('Required parameter schedule was null or undefined when calling postSubscriptionSchedulesScheduleRelease.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (preserveCancelDate !== undefined) {
            localVarFormParams['preserve_cancel_date'] = ObjectSerializer.serialize(preserveCancelDate, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: SubscriptionSchedule;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "SubscriptionSchedule");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new subscription on an existing customer. Each customer can have up to 500 active or scheduled subscriptions.</p>  <p>When you create a subscription with <code>collection_method=charge_automatically</code>, the first invoice is finalized as part of the request. The <code>payment_behavior</code> parameter determines the exact behavior of the initial payment.</p>  <p>To start subscriptions where the first invoice always begins in a <code>draft</code> status, use <a href=\"/docs/billing/subscriptions/subscription-schedules#managing\">subscription schedules</a> instead. Schedules provide the flexibility to model more complex billing configurations that change over time.</p>
     * @param customer The identifier of the customer to subscribe.
     * @param addInvoiceItems A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
     * @param applicationFeePercent A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner\\\&#39;s Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
     * @param automaticTax 
     * @param backdateStartDate For new subscriptions, a past timestamp to backdate the subscription\\\&#39;s start date to. If set, the first invoice will contain a proration for the timespan between the start date and the current time. Can be combined with trials and the billing cycle anchor.
     * @param billingCycleAnchor A future timestamp to anchor the subscription\\\&#39;s [billing cycle](https://stripe.com/docs/subscriptions/billing-cycle). This is used to determine the date of the first full invoice, and, for plans with &#x60;month&#x60; or &#x60;year&#x60; intervals, the day of the month for subsequent invoices. The timestamp is in UTC format.
     * @param billingThresholds 
     * @param cancelAt A timestamp at which the subscription should cancel. If set to a date before the current period ends, this will cause a proration if prorations have been enabled using &#x60;proration_behavior&#x60;. If set during a future period, this will always cause a proration for that period.
     * @param cancelAtPeriodEnd Boolean indicating whether this subscription should cancel at the end of the current period.
     * @param collectionMethod Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as &#x60;active&#x60;. Defaults to &#x60;charge_automatically&#x60;.
     * @param coupon The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param daysUntilDue Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where &#x60;collection_method&#x60; is set to &#x60;send_invoice&#x60;.
     * @param defaultPaymentMethod ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over &#x60;default_source&#x60;. If neither are set, invoices will use the customer\\\&#39;s [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
     * @param defaultSource ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If &#x60;default_payment_method&#x60; is also set, &#x60;default_payment_method&#x60; will take precedence. If neither are set, invoices will use the customer\\\&#39;s [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
     * @param defaultTaxRates 
     * @param description The subscription\\\&#39;s description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
     * @param expand Specifies which fields in the response should be expanded.
     * @param items A list of up to 20 subscription items, each with an attached price.
     * @param metadata 
     * @param offSession Indicates if a customer is on or off-session while an invoice payment is attempted.
     * @param onBehalfOf 
     * @param paymentBehavior Only applies to subscriptions with &#x60;collection_method&#x3D;charge_automatically&#x60;.  Use &#x60;allow_incomplete&#x60; to create subscriptions with &#x60;status&#x3D;incomplete&#x60; if the first invoice cannot be paid. Creating subscriptions with this status allows you to manage scenarios where additional user actions are needed to pay a subscription\\\&#39;s invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use &#x60;default_incomplete&#x60; to create Subscriptions with &#x60;status&#x3D;incomplete&#x60; when the first invoice requires payment, otherwise start as active. Subscriptions transition to &#x60;status&#x3D;active&#x60; when successfully confirming the payment intent on the first invoice. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method. If the payment intent is not confirmed within 23 hours subscriptions transition to &#x60;status&#x3D;incomplete_expired&#x60;, which is a terminal state.  Use &#x60;error_if_incomplete&#x60; if you want Stripe to return an HTTP 402 status code if a subscription\\\&#39;s first invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not create a subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.  &#x60;pending_if_incomplete&#x60; is only used with updates and cannot be passed when creating a subscription.  Subscriptions with &#x60;collection_method&#x3D;send_invoice&#x60; are automatically activated regardless of the first invoice status.
     * @param paymentSettings 
     * @param pendingInvoiceItemInterval 
     * @param promotionCode The API ID of a promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
     * @param prorationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) resulting from the &#x60;billing_cycle_anchor&#x60;. If no value is passed, the default is &#x60;create_prorations&#x60;.
     * @param transferData 
     * @param trialEnd 
     * @param trialFromPlan Indicates if a plan\\\&#39;s &#x60;trial_period_days&#x60; should be applied to the subscription. Setting &#x60;trial_end&#x60; per subscription is preferred, and this defaults to &#x60;false&#x60;. Setting this flag to &#x60;true&#x60; together with &#x60;trial_end&#x60; is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
     * @param trialPeriodDays Integer representing the number of trial period days before the customer is charged for the first time. This will always overwrite any trials that might apply via a subscribed plan. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
     * @param trialSettings 
     */
    public async postSubscriptions (customer: string, addInvoiceItems?: Array<AddInvoiceItemEntry>, applicationFeePercent?: number, automaticTax?: AutomaticTaxConfig2, backdateStartDate?: number, billingCycleAnchor?: number, billingThresholds?: DefaultSettingsParamsBillingThresholds, cancelAt?: number, cancelAtPeriodEnd?: boolean, collectionMethod?: string, coupon?: string, currency?: string, daysUntilDue?: number, defaultPaymentMethod?: string, defaultSource?: string, defaultTaxRates?: PostSubscriptionsRequestDefaultTaxRates, description?: string, expand?: Array<string>, items?: Array<SubscriptionItemCreateParams>, metadata?: IndividualSpecsMetadata, offSession?: boolean, onBehalfOf?: PostSubscriptionsRequestOnBehalfOf, paymentBehavior?: string, paymentSettings?: PaymentSettings1, pendingInvoiceItemInterval?: PostSubscriptionsRequestPendingInvoiceItemInterval, promotionCode?: string, prorationBehavior?: string, transferData?: TransferDataSpecs2, trialEnd?: PostSubscriptionsRequestTrialEnd, trialFromPlan?: boolean, trialPeriodDays?: number, trialSettings?: TrialSettingsConfig, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postSubscriptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (addInvoiceItems !== undefined) {
            localVarFormParams['add_invoice_items'] = ObjectSerializer.serialize(addInvoiceItems, "Array<AddInvoiceItemEntry>");
        }

        if (applicationFeePercent !== undefined) {
            localVarFormParams['application_fee_percent'] = ObjectSerializer.serialize(applicationFeePercent, "number");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxConfig2");
        }

        if (backdateStartDate !== undefined) {
            localVarFormParams['backdate_start_date'] = ObjectSerializer.serialize(backdateStartDate, "number");
        }

        if (billingCycleAnchor !== undefined) {
            localVarFormParams['billing_cycle_anchor'] = ObjectSerializer.serialize(billingCycleAnchor, "number");
        }

        if (billingThresholds !== undefined) {
            localVarFormParams['billing_thresholds'] = ObjectSerializer.serialize(billingThresholds, "DefaultSettingsParamsBillingThresholds");
        }

        if (cancelAt !== undefined) {
            localVarFormParams['cancel_at'] = ObjectSerializer.serialize(cancelAt, "number");
        }

        if (cancelAtPeriodEnd !== undefined) {
            localVarFormParams['cancel_at_period_end'] = ObjectSerializer.serialize(cancelAtPeriodEnd, "boolean");
        }

        if (collectionMethod !== undefined) {
            localVarFormParams['collection_method'] = ObjectSerializer.serialize(collectionMethod, "string");
        }

        if (coupon !== undefined) {
            localVarFormParams['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (daysUntilDue !== undefined) {
            localVarFormParams['days_until_due'] = ObjectSerializer.serialize(daysUntilDue, "number");
        }

        if (defaultPaymentMethod !== undefined) {
            localVarFormParams['default_payment_method'] = ObjectSerializer.serialize(defaultPaymentMethod, "string");
        }

        if (defaultSource !== undefined) {
            localVarFormParams['default_source'] = ObjectSerializer.serialize(defaultSource, "string");
        }

        if (defaultTaxRates !== undefined) {
            localVarFormParams['default_tax_rates'] = ObjectSerializer.serialize(defaultTaxRates, "PostSubscriptionsRequestDefaultTaxRates");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (items !== undefined) {
            localVarFormParams['items'] = ObjectSerializer.serialize(items, "Array<SubscriptionItemCreateParams>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (offSession !== undefined) {
            localVarFormParams['off_session'] = ObjectSerializer.serialize(offSession, "boolean");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "PostSubscriptionsRequestOnBehalfOf");
        }

        if (paymentBehavior !== undefined) {
            localVarFormParams['payment_behavior'] = ObjectSerializer.serialize(paymentBehavior, "string");
        }

        if (paymentSettings !== undefined) {
            localVarFormParams['payment_settings'] = ObjectSerializer.serialize(paymentSettings, "PaymentSettings1");
        }

        if (pendingInvoiceItemInterval !== undefined) {
            localVarFormParams['pending_invoice_item_interval'] = ObjectSerializer.serialize(pendingInvoiceItemInterval, "PostSubscriptionsRequestPendingInvoiceItemInterval");
        }

        if (promotionCode !== undefined) {
            localVarFormParams['promotion_code'] = ObjectSerializer.serialize(promotionCode, "string");
        }

        if (prorationBehavior !== undefined) {
            localVarFormParams['proration_behavior'] = ObjectSerializer.serialize(prorationBehavior, "string");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "TransferDataSpecs2");
        }

        if (trialEnd !== undefined) {
            localVarFormParams['trial_end'] = ObjectSerializer.serialize(trialEnd, "PostSubscriptionsRequestTrialEnd");
        }

        if (trialFromPlan !== undefined) {
            localVarFormParams['trial_from_plan'] = ObjectSerializer.serialize(trialFromPlan, "boolean");
        }

        if (trialPeriodDays !== undefined) {
            localVarFormParams['trial_period_days'] = ObjectSerializer.serialize(trialPeriodDays, "number");
        }

        if (trialSettings !== undefined) {
            localVarFormParams['trial_settings'] = ObjectSerializer.serialize(trialSettings, "TrialSettingsConfig");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Subscription");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing subscription on a customer to match the specified parameters. When changing plans or quantities, we will optionally prorate the price we charge next month to make up for any price changes. To preview how the proration will be calculated, use the <a href=\"#upcoming_invoice\">upcoming invoice</a> endpoint.</p>
     * @param subscriptionExposedId 
     * @param addInvoiceItems A list of prices and quantities that will generate invoice items appended to the next invoice for this subscription. You may pass up to 20 items.
     * @param applicationFeePercent A non-negative decimal between 0 and 100, with at most two decimal places. This represents the percentage of the subscription invoice subtotal that will be transferred to the application owner\\\&#39;s Stripe account. The request must be made by a platform account on a connected account in order to set an application fee percentage. For more information, see the application fees [documentation](https://stripe.com/docs/connect/subscriptions#collecting-fees-on-subscriptions).
     * @param automaticTax 
     * @param billingCycleAnchor Either &#x60;now&#x60; or &#x60;unchanged&#x60;. Setting the value to &#x60;now&#x60; resets the subscription\\\&#39;s billing cycle anchor to the current time (in UTC). For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
     * @param billingThresholds 
     * @param cancelAt 
     * @param cancelAtPeriodEnd Boolean indicating whether this subscription should cancel at the end of the current period.
     * @param collectionMethod Either &#x60;charge_automatically&#x60;, or &#x60;send_invoice&#x60;. When charging automatically, Stripe will attempt to pay this subscription at the end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment instructions and mark the subscription as &#x60;active&#x60;. Defaults to &#x60;charge_automatically&#x60;.
     * @param coupon The ID of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that particular subscription.
     * @param daysUntilDue Number of days a customer has to pay invoices generated by this subscription. Valid only for subscriptions where &#x60;collection_method&#x60; is set to &#x60;send_invoice&#x60;.
     * @param defaultPaymentMethod ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. This takes precedence over &#x60;default_source&#x60;. If neither are set, invoices will use the customer\\\&#39;s [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
     * @param defaultSource ID of the default payment source for the subscription. It must belong to the customer associated with the subscription and be in a chargeable state. If &#x60;default_payment_method&#x60; is also set, &#x60;default_payment_method&#x60; will take precedence. If neither are set, invoices will use the customer\\\&#39;s [invoice_settings.default_payment_method](https://stripe.com/docs/api/customers/object#customer_object-invoice_settings-default_payment_method) or [default_source](https://stripe.com/docs/api/customers/object#customer_object-default_source).
     * @param defaultTaxRates 
     * @param description The subscription\\\&#39;s description, meant to be displayable to the customer. Use this field to optionally store an explanation of the subscription for rendering in Stripe surfaces.
     * @param expand Specifies which fields in the response should be expanded.
     * @param items A list of up to 20 subscription items, each with an attached price.
     * @param metadata 
     * @param offSession Indicates if a customer is on or off-session while an invoice payment is attempted.
     * @param onBehalfOf 
     * @param pauseCollection 
     * @param paymentBehavior Use &#x60;allow_incomplete&#x60; to transition the subscription to &#x60;status&#x3D;past_due&#x60; if a payment is required but cannot be paid. This allows you to manage scenarios where additional user actions are needed to pay a subscription\\\&#39;s invoice. For example, SCA regulation may require 3DS authentication to complete payment. See the [SCA Migration Guide](https://stripe.com/docs/billing/migration/strong-customer-authentication) for Billing to learn more. This is the default behavior.  Use &#x60;default_incomplete&#x60; to transition the subscription to &#x60;status&#x3D;past_due&#x60; when payment is required and await explicit confirmation of the invoice\\\&#39;s payment intent. This allows simpler management of scenarios where additional user actions are needed to pay a subscription’s invoice. Such as failed payments, [SCA regulation](https://stripe.com/docs/billing/migration/strong-customer-authentication), or collecting a mandate for a bank debit payment method.  Use &#x60;pending_if_incomplete&#x60; to update the subscription using [pending updates](https://stripe.com/docs/billing/subscriptions/pending-updates). When you use &#x60;pending_if_incomplete&#x60; you can only pass the parameters [supported by pending updates](https://stripe.com/docs/billing/pending-updates-reference#supported-attributes).  Use &#x60;error_if_incomplete&#x60; if you want Stripe to return an HTTP 402 status code if a subscription\\\&#39;s invoice cannot be paid. For example, if a payment method requires 3DS authentication due to SCA regulation and further user action is needed, this parameter does not update the subscription and returns an error instead. This was the default behavior for API versions prior to 2019-03-14. See the [changelog](https://stripe.com/docs/upgrades#2019-03-14) to learn more.
     * @param paymentSettings 
     * @param pendingInvoiceItemInterval 
     * @param promotionCode The promotion code to apply to this subscription. A promotion code applied to a subscription will only affect invoices created for that particular subscription.
     * @param prorationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting &#x60;billing_cycle_anchor&#x3D;now&#x60;, or starting a trial), or if an item\\\&#39;s &#x60;quantity&#x60; changes. The default value is &#x60;create_prorations&#x60;.
     * @param prorationDate If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint. It can also be used to implement custom proration logic, such as prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
     * @param transferData 
     * @param trialEnd 
     * @param trialFromPlan Indicates if a plan\\\&#39;s &#x60;trial_period_days&#x60; should be applied to the subscription. Setting &#x60;trial_end&#x60; per subscription is preferred, and this defaults to &#x60;false&#x60;. Setting this flag to &#x60;true&#x60; together with &#x60;trial_end&#x60; is not allowed. See [Using trial periods on subscriptions](https://stripe.com/docs/billing/subscriptions/trials) to learn more.
     * @param trialSettings 
     */
    public async postSubscriptionsSubscriptionExposedId (subscriptionExposedId: string, addInvoiceItems?: Array<AddInvoiceItemEntry>, applicationFeePercent?: number, automaticTax?: AutomaticTaxConfig2, billingCycleAnchor?: string, billingThresholds?: DefaultSettingsParamsBillingThresholds, cancelAt?: PostSubscriptionsSubscriptionExposedIdRequestCancelAt, cancelAtPeriodEnd?: boolean, collectionMethod?: string, coupon?: string, daysUntilDue?: number, defaultPaymentMethod?: string, defaultSource?: string, defaultTaxRates?: PostSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates, description?: string, expand?: Array<string>, items?: Array<SubscriptionItemUpdateParams>, metadata?: IndividualSpecsMetadata, offSession?: boolean, onBehalfOf?: PostSubscriptionsRequestOnBehalfOf, pauseCollection?: PostSubscriptionsSubscriptionExposedIdRequestPauseCollection, paymentBehavior?: string, paymentSettings?: PaymentSettings1, pendingInvoiceItemInterval?: PostSubscriptionsRequestPendingInvoiceItemInterval, promotionCode?: string, prorationBehavior?: string, prorationDate?: number, transferData?: PostSubscriptionsSubscriptionExposedIdRequestTransferData, trialEnd?: PostSubscriptionsSubscriptionExposedIdRequestTrialEnd, trialFromPlan?: boolean, trialSettings?: TrialSettingsConfig, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions/{subscription_exposed_id}'
            .replace('{' + 'subscription_exposed_id' + '}', encodeURIComponent(String(subscriptionExposedId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionExposedId' is not null or undefined
        if (subscriptionExposedId === null || subscriptionExposedId === undefined) {
            throw new Error('Required parameter subscriptionExposedId was null or undefined when calling postSubscriptionsSubscriptionExposedId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (addInvoiceItems !== undefined) {
            localVarFormParams['add_invoice_items'] = ObjectSerializer.serialize(addInvoiceItems, "Array<AddInvoiceItemEntry>");
        }

        if (applicationFeePercent !== undefined) {
            localVarFormParams['application_fee_percent'] = ObjectSerializer.serialize(applicationFeePercent, "number");
        }

        if (automaticTax !== undefined) {
            localVarFormParams['automatic_tax'] = ObjectSerializer.serialize(automaticTax, "AutomaticTaxConfig2");
        }

        if (billingCycleAnchor !== undefined) {
            localVarFormParams['billing_cycle_anchor'] = ObjectSerializer.serialize(billingCycleAnchor, "string");
        }

        if (billingThresholds !== undefined) {
            localVarFormParams['billing_thresholds'] = ObjectSerializer.serialize(billingThresholds, "DefaultSettingsParamsBillingThresholds");
        }

        if (cancelAt !== undefined) {
            localVarFormParams['cancel_at'] = ObjectSerializer.serialize(cancelAt, "PostSubscriptionsSubscriptionExposedIdRequestCancelAt");
        }

        if (cancelAtPeriodEnd !== undefined) {
            localVarFormParams['cancel_at_period_end'] = ObjectSerializer.serialize(cancelAtPeriodEnd, "boolean");
        }

        if (collectionMethod !== undefined) {
            localVarFormParams['collection_method'] = ObjectSerializer.serialize(collectionMethod, "string");
        }

        if (coupon !== undefined) {
            localVarFormParams['coupon'] = ObjectSerializer.serialize(coupon, "string");
        }

        if (daysUntilDue !== undefined) {
            localVarFormParams['days_until_due'] = ObjectSerializer.serialize(daysUntilDue, "number");
        }

        if (defaultPaymentMethod !== undefined) {
            localVarFormParams['default_payment_method'] = ObjectSerializer.serialize(defaultPaymentMethod, "string");
        }

        if (defaultSource !== undefined) {
            localVarFormParams['default_source'] = ObjectSerializer.serialize(defaultSource, "string");
        }

        if (defaultTaxRates !== undefined) {
            localVarFormParams['default_tax_rates'] = ObjectSerializer.serialize(defaultTaxRates, "PostSubscriptionsSubscriptionExposedIdRequestDefaultTaxRates");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (items !== undefined) {
            localVarFormParams['items'] = ObjectSerializer.serialize(items, "Array<SubscriptionItemUpdateParams>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (offSession !== undefined) {
            localVarFormParams['off_session'] = ObjectSerializer.serialize(offSession, "boolean");
        }

        if (onBehalfOf !== undefined) {
            localVarFormParams['on_behalf_of'] = ObjectSerializer.serialize(onBehalfOf, "PostSubscriptionsRequestOnBehalfOf");
        }

        if (pauseCollection !== undefined) {
            localVarFormParams['pause_collection'] = ObjectSerializer.serialize(pauseCollection, "PostSubscriptionsSubscriptionExposedIdRequestPauseCollection");
        }

        if (paymentBehavior !== undefined) {
            localVarFormParams['payment_behavior'] = ObjectSerializer.serialize(paymentBehavior, "string");
        }

        if (paymentSettings !== undefined) {
            localVarFormParams['payment_settings'] = ObjectSerializer.serialize(paymentSettings, "PaymentSettings1");
        }

        if (pendingInvoiceItemInterval !== undefined) {
            localVarFormParams['pending_invoice_item_interval'] = ObjectSerializer.serialize(pendingInvoiceItemInterval, "PostSubscriptionsRequestPendingInvoiceItemInterval");
        }

        if (promotionCode !== undefined) {
            localVarFormParams['promotion_code'] = ObjectSerializer.serialize(promotionCode, "string");
        }

        if (prorationBehavior !== undefined) {
            localVarFormParams['proration_behavior'] = ObjectSerializer.serialize(prorationBehavior, "string");
        }

        if (prorationDate !== undefined) {
            localVarFormParams['proration_date'] = ObjectSerializer.serialize(prorationDate, "number");
        }

        if (transferData !== undefined) {
            localVarFormParams['transfer_data'] = ObjectSerializer.serialize(transferData, "PostSubscriptionsSubscriptionExposedIdRequestTransferData");
        }

        if (trialEnd !== undefined) {
            localVarFormParams['trial_end'] = ObjectSerializer.serialize(trialEnd, "PostSubscriptionsSubscriptionExposedIdRequestTrialEnd");
        }

        if (trialFromPlan !== undefined) {
            localVarFormParams['trial_from_plan'] = ObjectSerializer.serialize(trialFromPlan, "boolean");
        }

        if (trialSettings !== undefined) {
            localVarFormParams['trial_settings'] = ObjectSerializer.serialize(trialSettings, "TrialSettingsConfig");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Subscription");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Initiates resumption of a paused subscription, optionally resetting the billing cycle anchor and creating prorations. If a resumption invoice is generated, it must be paid or marked uncollectible before the subscription will be unpaused. If payment succeeds the subscription will become <code>active</code>, and if payment fails the subscription will be <code>past_due</code>. The resumption invoice will void automatically if not paid by the expiration date.</p>
     * @param subscription 
     * @param billingCycleAnchor Either &#x60;now&#x60; or &#x60;unchanged&#x60;. Setting the value to &#x60;now&#x60; resets the subscription\\\&#39;s billing cycle anchor to the current time (in UTC). Setting the value to &#x60;unchanged&#x60; advances the subscription\\\&#39;s billing cycle anchor to the period that surrounds the current time. For more information, see the billing cycle [documentation](https://stripe.com/docs/billing/subscriptions/billing-cycle).
     * @param expand Specifies which fields in the response should be expanded.
     * @param prorationBehavior Determines how to handle [prorations](https://stripe.com/docs/subscriptions/billing-cycle#prorations) when the billing cycle changes (e.g., when switching plans, resetting &#x60;billing_cycle_anchor&#x3D;now&#x60;, or starting a trial), or if an item\\\&#39;s &#x60;quantity&#x60; changes. The default value is &#x60;create_prorations&#x60;.
     * @param prorationDate If set, the proration will be calculated as though the subscription was resumed at the given time. This can be used to apply exactly the same proration that was previewed with [upcoming invoice](https://stripe.com/docs/api#retrieve_customer_invoice) endpoint.
     */
    public async postSubscriptionsSubscriptionResume (subscription: string, billingCycleAnchor?: string, expand?: Array<string>, prorationBehavior?: string, prorationDate?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Subscription;  }> {
        const localVarPath = this.basePath + '/v1/subscriptions/{subscription}/resume'
            .replace('{' + 'subscription' + '}', encodeURIComponent(String(subscription)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'subscription' is not null or undefined
        if (subscription === null || subscription === undefined) {
            throw new Error('Required parameter subscription was null or undefined when calling postSubscriptionsSubscriptionResume.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (billingCycleAnchor !== undefined) {
            localVarFormParams['billing_cycle_anchor'] = ObjectSerializer.serialize(billingCycleAnchor, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (prorationBehavior !== undefined) {
            localVarFormParams['proration_behavior'] = ObjectSerializer.serialize(prorationBehavior, "string");
        }

        if (prorationDate !== undefined) {
            localVarFormParams['proration_date'] = ObjectSerializer.serialize(prorationDate, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Subscription;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Subscription");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new tax rate.</p>
     * @param displayName The display name of the tax rate, which will be shown to users.
     * @param inclusive This specifies if the tax rate is inclusive or exclusive.
     * @param percentage This represents the tax rate percent out of 100.
     * @param active Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
     * @param country Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @param description An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
     * @param expand Specifies which fields in the response should be expanded.
     * @param jurisdiction The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
     * @param state [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\&quot;NY\\\&quot; for New York, United States.
     * @param taxType The high-level tax type, such as &#x60;vat&#x60; or &#x60;sales_tax&#x60;.
     */
    public async postTaxRates (displayName: string, inclusive: boolean, percentage: number, active?: boolean, country?: string, description?: string, expand?: Array<string>, jurisdiction?: string, state?: string, taxType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxRate;  }> {
        const localVarPath = this.basePath + '/v1/tax_rates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'displayName' is not null or undefined
        if (displayName === null || displayName === undefined) {
            throw new Error('Required parameter displayName was null or undefined when calling postTaxRates.');
        }

        // verify required parameter 'inclusive' is not null or undefined
        if (inclusive === null || inclusive === undefined) {
            throw new Error('Required parameter inclusive was null or undefined when calling postTaxRates.');
        }

        // verify required parameter 'percentage' is not null or undefined
        if (percentage === null || percentage === undefined) {
            throw new Error('Required parameter percentage was null or undefined when calling postTaxRates.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (country !== undefined) {
            localVarFormParams['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (displayName !== undefined) {
            localVarFormParams['display_name'] = ObjectSerializer.serialize(displayName, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (inclusive !== undefined) {
            localVarFormParams['inclusive'] = ObjectSerializer.serialize(inclusive, "boolean");
        }

        if (jurisdiction !== undefined) {
            localVarFormParams['jurisdiction'] = ObjectSerializer.serialize(jurisdiction, "string");
        }

        if (percentage !== undefined) {
            localVarFormParams['percentage'] = ObjectSerializer.serialize(percentage, "number");
        }

        if (state !== undefined) {
            localVarFormParams['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (taxType !== undefined) {
            localVarFormParams['tax_type'] = ObjectSerializer.serialize(taxType, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxRate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxRate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates an existing tax rate.</p>
     * @param taxRate 
     * @param active Flag determining whether the tax rate is active or inactive (archived). Inactive tax rates cannot be used with new applications or Checkout Sessions, but will still work for subscriptions and invoices that already have it set.
     * @param country Two-letter country code ([ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)).
     * @param description An arbitrary string attached to the tax rate for your internal use only. It will not be visible to your customers.
     * @param displayName The display name of the tax rate, which will be shown to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param jurisdiction The jurisdiction for the tax rate. You can use this label field for tax reporting purposes. It also appears on your customer’s invoice.
     * @param metadata 
     * @param state [ISO 3166-2 subdivision code](https://en.wikipedia.org/wiki/ISO_3166-2:US), without country prefix. For example, \\\&quot;NY\\\&quot; for New York, United States.
     * @param taxType The high-level tax type, such as &#x60;vat&#x60; or &#x60;sales_tax&#x60;.
     */
    public async postTaxRatesTaxRate (taxRate: string, active?: boolean, country?: string, description?: string, displayName?: string, expand?: Array<string>, jurisdiction?: string, metadata?: IndividualSpecsMetadata, state?: string, taxType?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TaxRate;  }> {
        const localVarPath = this.basePath + '/v1/tax_rates/{tax_rate}'
            .replace('{' + 'tax_rate' + '}', encodeURIComponent(String(taxRate)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'taxRate' is not null or undefined
        if (taxRate === null || taxRate === undefined) {
            throw new Error('Required parameter taxRate was null or undefined when calling postTaxRatesTaxRate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (active !== undefined) {
            localVarFormParams['active'] = ObjectSerializer.serialize(active, "boolean");
        }

        if (country !== undefined) {
            localVarFormParams['country'] = ObjectSerializer.serialize(country, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (displayName !== undefined) {
            localVarFormParams['display_name'] = ObjectSerializer.serialize(displayName, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (jurisdiction !== undefined) {
            localVarFormParams['jurisdiction'] = ObjectSerializer.serialize(jurisdiction, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (state !== undefined) {
            localVarFormParams['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (taxType !== undefined) {
            localVarFormParams['tax_type'] = ObjectSerializer.serialize(taxType, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TaxRate;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TaxRate");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new <code>Configuration</code> object.</p>
     * @param bbposWiseposE 
     * @param expand Specifies which fields in the response should be expanded.
     * @param tipping 
     * @param verifoneP400 
     */
    public async postTerminalConfigurations (bbposWiseposE?: BbposWisePose, expand?: Array<string>, tipping?: PostTerminalConfigurationsRequestTipping, verifoneP400?: VerifoneP400, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalConfiguration;  }> {
        const localVarPath = this.basePath + '/v1/terminal/configurations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (bbposWiseposE !== undefined) {
            localVarFormParams['bbpos_wisepos_e'] = ObjectSerializer.serialize(bbposWiseposE, "BbposWisePose");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (tipping !== undefined) {
            localVarFormParams['tipping'] = ObjectSerializer.serialize(tipping, "PostTerminalConfigurationsRequestTipping");
        }

        if (verifoneP400 !== undefined) {
            localVarFormParams['verifone_p400'] = ObjectSerializer.serialize(verifoneP400, "VerifoneP400");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalConfiguration;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalConfiguration");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a new <code>Configuration</code> object.</p>
     * @param configuration 
     * @param bbposWiseposE 
     * @param expand Specifies which fields in the response should be expanded.
     * @param tipping 
     * @param verifoneP400 
     */
    public async postTerminalConfigurationsConfiguration (configuration: string, bbposWiseposE?: PostTerminalConfigurationsConfigurationRequestBbposWiseposE, expand?: Array<string>, tipping?: PostTerminalConfigurationsRequestTipping, verifoneP400?: PostTerminalConfigurationsConfigurationRequestVerifoneP400, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetTerminalConfigurationsConfiguration200Response;  }> {
        const localVarPath = this.basePath + '/v1/terminal/configurations/{configuration}'
            .replace('{' + 'configuration' + '}', encodeURIComponent(String(configuration)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'configuration' is not null or undefined
        if (configuration === null || configuration === undefined) {
            throw new Error('Required parameter configuration was null or undefined when calling postTerminalConfigurationsConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (bbposWiseposE !== undefined) {
            localVarFormParams['bbpos_wisepos_e'] = ObjectSerializer.serialize(bbposWiseposE, "PostTerminalConfigurationsConfigurationRequestBbposWiseposE");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (tipping !== undefined) {
            localVarFormParams['tipping'] = ObjectSerializer.serialize(tipping, "PostTerminalConfigurationsRequestTipping");
        }

        if (verifoneP400 !== undefined) {
            localVarFormParams['verifone_p400'] = ObjectSerializer.serialize(verifoneP400, "PostTerminalConfigurationsConfigurationRequestVerifoneP400");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetTerminalConfigurationsConfiguration200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetTerminalConfigurationsConfiguration200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>To connect to a reader the Stripe Terminal SDK needs to retrieve a short-lived connection token from Stripe, proxied through your server. On your backend, add an endpoint that creates and returns a connection token.</p>
     * @param expand Specifies which fields in the response should be expanded.
     * @param location The id of the location that this connection token is scoped to. If specified the connection token will only be usable with readers assigned to that location, otherwise the connection token will be usable with all readers. Note that location scoping only applies to internet-connected readers. For more details, see [the docs on scoping connection tokens](https://stripe.com/docs/terminal/fleet/locations#connection-tokens).
     */
    public async postTerminalConnectionTokens (expand?: Array<string>, location?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalConnectionToken;  }> {
        const localVarPath = this.basePath + '/v1/terminal/connection_tokens';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (location !== undefined) {
            localVarFormParams['location'] = ObjectSerializer.serialize(location, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalConnectionToken;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalConnectionToken");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new <code>Location</code> object. For further details, including which address fields are required in each country, see the <a href=\"/docs/terminal/fleet/locations\">Manage locations</a> guide.</p>
     * @param address 
     * @param displayName A name for the location.
     * @param configurationOverrides The ID of a configuration that will be used to customize all readers in this location.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postTerminalLocations (address: CreateLocationAddressParam, displayName: string, configurationOverrides?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalLocation;  }> {
        const localVarPath = this.basePath + '/v1/terminal/locations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'address' is not null or undefined
        if (address === null || address === undefined) {
            throw new Error('Required parameter address was null or undefined when calling postTerminalLocations.');
        }

        // verify required parameter 'displayName' is not null or undefined
        if (displayName === null || displayName === undefined) {
            throw new Error('Required parameter displayName was null or undefined when calling postTerminalLocations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (address !== undefined) {
            localVarFormParams['address'] = ObjectSerializer.serialize(address, "CreateLocationAddressParam");
        }

        if (configurationOverrides !== undefined) {
            localVarFormParams['configuration_overrides'] = ObjectSerializer.serialize(configurationOverrides, "string");
        }

        if (displayName !== undefined) {
            localVarFormParams['display_name'] = ObjectSerializer.serialize(displayName, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalLocation;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalLocation");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a <code>Location</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param location 
     * @param address 
     * @param configurationOverrides The ID of a configuration that will be used to customize all readers in this location.
     * @param displayName A name for the location.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postTerminalLocationsLocation (location: string, address?: OptionalFieldsAddress4, configurationOverrides?: string, displayName?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetTerminalLocationsLocation200Response;  }> {
        const localVarPath = this.basePath + '/v1/terminal/locations/{location}'
            .replace('{' + 'location' + '}', encodeURIComponent(String(location)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'location' is not null or undefined
        if (location === null || location === undefined) {
            throw new Error('Required parameter location was null or undefined when calling postTerminalLocationsLocation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (address !== undefined) {
            localVarFormParams['address'] = ObjectSerializer.serialize(address, "OptionalFieldsAddress4");
        }

        if (configurationOverrides !== undefined) {
            localVarFormParams['configuration_overrides'] = ObjectSerializer.serialize(configurationOverrides, "string");
        }

        if (displayName !== undefined) {
            localVarFormParams['display_name'] = ObjectSerializer.serialize(displayName, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetTerminalLocationsLocation200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetTerminalLocationsLocation200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new <code>Reader</code> object.</p>
     * @param registrationCode A code generated by the reader used for registering to an account.
     * @param expand Specifies which fields in the response should be expanded.
     * @param label Custom label given to the reader for easier identification. If no label is specified, the registration code will be used.
     * @param location The location to assign the reader to.
     * @param metadata 
     */
    public async postTerminalReaders (registrationCode: string, expand?: Array<string>, label?: string, location?: string, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'registrationCode' is not null or undefined
        if (registrationCode === null || registrationCode === undefined) {
            throw new Error('Required parameter registrationCode was null or undefined when calling postTerminalReaders.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (label !== undefined) {
            localVarFormParams['label'] = ObjectSerializer.serialize(label, "string");
        }

        if (location !== undefined) {
            localVarFormParams['location'] = ObjectSerializer.serialize(location, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (registrationCode !== undefined) {
            localVarFormParams['registration_code'] = ObjectSerializer.serialize(registrationCode, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates a <code>Reader</code> object by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>
     * @param reader 
     * @param expand Specifies which fields in the response should be expanded.
     * @param label The new label of the reader.
     * @param metadata 
     */
    public async postTerminalReadersReader (reader: string, expand?: Array<string>, label?: string, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: GetTerminalReadersReader200Response;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling postTerminalReadersReader.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (label !== undefined) {
            localVarFormParams['label'] = ObjectSerializer.serialize(label, "string");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: GetTerminalReadersReader200Response;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "GetTerminalReadersReader200Response");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancels the current reader action.</p>
     * @param reader 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTerminalReadersReaderCancelAction (reader: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}/cancel_action'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling postTerminalReadersReaderCancelAction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Initiates a payment flow on a Reader.</p>
     * @param reader 
     * @param paymentIntent PaymentIntent ID
     * @param expand Specifies which fields in the response should be expanded.
     * @param processConfig 
     */
    public async postTerminalReadersReaderProcessPaymentIntent (reader: string, paymentIntent: string, expand?: Array<string>, processConfig?: ProcessConfig, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}/process_payment_intent'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling postTerminalReadersReaderProcessPaymentIntent.');
        }

        // verify required parameter 'paymentIntent' is not null or undefined
        if (paymentIntent === null || paymentIntent === undefined) {
            throw new Error('Required parameter paymentIntent was null or undefined when calling postTerminalReadersReaderProcessPaymentIntent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (paymentIntent !== undefined) {
            localVarFormParams['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (processConfig !== undefined) {
            localVarFormParams['process_config'] = ObjectSerializer.serialize(processConfig, "ProcessConfig");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Initiates a setup intent flow on a Reader.</p>
     * @param reader 
     * @param customerConsentCollected Customer Consent Collected
     * @param setupIntent SetupIntent ID
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTerminalReadersReaderProcessSetupIntent (reader: string, customerConsentCollected: boolean, setupIntent: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}/process_setup_intent'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling postTerminalReadersReaderProcessSetupIntent.');
        }

        // verify required parameter 'customerConsentCollected' is not null or undefined
        if (customerConsentCollected === null || customerConsentCollected === undefined) {
            throw new Error('Required parameter customerConsentCollected was null or undefined when calling postTerminalReadersReaderProcessSetupIntent.');
        }

        // verify required parameter 'setupIntent' is not null or undefined
        if (setupIntent === null || setupIntent === undefined) {
            throw new Error('Required parameter setupIntent was null or undefined when calling postTerminalReadersReaderProcessSetupIntent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (customerConsentCollected !== undefined) {
            localVarFormParams['customer_consent_collected'] = ObjectSerializer.serialize(customerConsentCollected, "boolean");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (setupIntent !== undefined) {
            localVarFormParams['setup_intent'] = ObjectSerializer.serialize(setupIntent, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Initiates a refund on a Reader</p>
     * @param reader 
     * @param amount A positive integer in __cents__ representing how much of this charge to refund.
     * @param charge ID of the Charge to refund.
     * @param expand Specifies which fields in the response should be expanded.
     * @param paymentIntent ID of the PaymentIntent to refund.
     * @param refundApplicationFee Boolean indicating whether the application fee should be refunded when refunding this charge. If a full charge refund is given, the full application fee will be refunded. Otherwise, the application fee will be refunded in an amount proportional to the amount of the charge refunded. An application fee can be refunded only by the application that created the charge.
     * @param reverseTransfer Boolean indicating whether the transfer should be reversed when refunding this charge. The transfer will be reversed proportionally to the amount being refunded (either the entire or partial amount). A transfer can be reversed only by the application that created the charge.
     */
    public async postTerminalReadersReaderRefundPayment (reader: string, amount?: number, charge?: string, expand?: Array<string>, paymentIntent?: string, refundApplicationFee?: boolean, reverseTransfer?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}/refund_payment'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling postTerminalReadersReaderRefundPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (charge !== undefined) {
            localVarFormParams['charge'] = ObjectSerializer.serialize(charge, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (paymentIntent !== undefined) {
            localVarFormParams['payment_intent'] = ObjectSerializer.serialize(paymentIntent, "string");
        }

        if (refundApplicationFee !== undefined) {
            localVarFormParams['refund_application_fee'] = ObjectSerializer.serialize(refundApplicationFee, "boolean");
        }

        if (reverseTransfer !== undefined) {
            localVarFormParams['reverse_transfer'] = ObjectSerializer.serialize(reverseTransfer, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Sets reader display to show cart details.</p>
     * @param reader 
     * @param type Type
     * @param cart 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTerminalReadersReaderSetReaderDisplay (reader: string, type: string, cart?: Cart, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/terminal/readers/{reader}/set_reader_display'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling postTerminalReadersReaderSetReaderDisplay.');
        }

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling postTerminalReadersReaderSetReaderDisplay.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cart !== undefined) {
            localVarFormParams['cart'] = ObjectSerializer.serialize(cart, "Cart");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Create an incoming testmode bank transfer</p>
     * @param customer 
     * @param amount Amount to be used for this test cash balance transaction. A positive integer representing how much to fund in the [smallest currency unit](https://stripe.com/docs/currencies#zero-decimal) (e.g., 100 cents to fund $1.00 or 100 to fund ¥100, a zero-decimal currency).
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param expand Specifies which fields in the response should be expanded.
     * @param reference A description of the test funding. This simulates free-text references supplied by customers when making bank transfers to their cash balance. You can use this to test how Stripe\\\&#39;s [reconciliation algorithm](https://stripe.com/docs/payments/customer-balance/reconciliation) applies to different user inputs.
     */
    public async postTestHelpersCustomersCustomerFundCashBalance (customer: string, amount: number, currency: string, expand?: Array<string>, reference?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: CustomerCashBalanceTransaction;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/customers/{customer}/fund_cash_balance'
            .replace('{' + 'customer' + '}', encodeURIComponent(String(customer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'customer' is not null or undefined
        if (customer === null || customer === undefined) {
            throw new Error('Required parameter customer was null or undefined when calling postTestHelpersCustomersCustomerFundCashBalance.');
        }

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postTestHelpersCustomersCustomerFundCashBalance.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTestHelpersCustomersCustomerFundCashBalance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (reference !== undefined) {
            localVarFormParams['reference'] = ObjectSerializer.serialize(reference, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: CustomerCashBalanceTransaction;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "CustomerCashBalanceTransaction");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>delivered</code>.</p>
     * @param card 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersIssuingCardsCardShippingDeliver (card: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCard;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/issuing/cards/{card}/shipping/deliver'
            .replace('{' + 'card' + '}', encodeURIComponent(String(card)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling postTestHelpersIssuingCardsCardShippingDeliver.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCard;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCard");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>failure</code>.</p>
     * @param card 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersIssuingCardsCardShippingFail (card: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCard;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/issuing/cards/{card}/shipping/fail'
            .replace('{' + 'card' + '}', encodeURIComponent(String(card)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling postTestHelpersIssuingCardsCardShippingFail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCard;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCard");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>returned</code>.</p>
     * @param card 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersIssuingCardsCardShippingReturn (card: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCard;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/issuing/cards/{card}/shipping/return'
            .replace('{' + 'card' + '}', encodeURIComponent(String(card)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling postTestHelpersIssuingCardsCardShippingReturn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCard;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCard");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the shipping status of the specified Issuing <code>Card</code> object to <code>shipped</code>.</p>
     * @param card 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersIssuingCardsCardShippingShip (card: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: IssuingCard;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/issuing/cards/{card}/shipping/ship'
            .replace('{' + 'card' + '}', encodeURIComponent(String(card)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'card' is not null or undefined
        if (card === null || card === undefined) {
            throw new Error('Required parameter card was null or undefined when calling postTestHelpersIssuingCardsCardShippingShip.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: IssuingCard;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "IssuingCard");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Expire a refund with a status of <code>requires_action</code>.</p>
     * @param refund 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersRefundsRefundExpire (refund: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Refund;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/refunds/{refund}/expire'
            .replace('{' + 'refund' + '}', encodeURIComponent(String(refund)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'refund' is not null or undefined
        if (refund === null || refund === undefined) {
            throw new Error('Required parameter refund was null or undefined when calling postTestHelpersRefundsRefundExpire.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Refund;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Refund");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Presents a payment method on a simulated reader. Can be used to simulate accepting a payment, saving a card or refunding a transaction.</p>
     * @param reader 
     * @param cardPresent 
     * @param expand Specifies which fields in the response should be expanded.
     * @param interacPresent 
     * @param type Simulated payment type.
     */
    public async postTestHelpersTerminalReadersReaderPresentPaymentMethod (reader: string, cardPresent?: CardPresent, expand?: Array<string>, interacPresent?: InteracPresent, type?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TerminalReader;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/terminal/readers/{reader}/present_payment_method'
            .replace('{' + 'reader' + '}', encodeURIComponent(String(reader)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'reader' is not null or undefined
        if (reader === null || reader === undefined) {
            throw new Error('Required parameter reader was null or undefined when calling postTestHelpersTerminalReadersReaderPresentPaymentMethod.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cardPresent !== undefined) {
            localVarFormParams['card_present'] = ObjectSerializer.serialize(cardPresent, "CardPresent");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (interacPresent !== undefined) {
            localVarFormParams['interac_present'] = ObjectSerializer.serialize(interacPresent, "InteracPresent");
        }

        if (type !== undefined) {
            localVarFormParams['type'] = ObjectSerializer.serialize(type, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TerminalReader;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TerminalReader");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new test clock that can be attached to new customers and quotes.</p>
     * @param frozenTime The initial frozen time for this test clock.
     * @param expand Specifies which fields in the response should be expanded.
     * @param name The name for this test clock.
     */
    public async postTestHelpersTestClocks (frozenTime: number, expand?: Array<string>, name?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TestHelpersTestClock;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/test_clocks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'frozenTime' is not null or undefined
        if (frozenTime === null || frozenTime === undefined) {
            throw new Error('Required parameter frozenTime was null or undefined when calling postTestHelpersTestClocks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (frozenTime !== undefined) {
            localVarFormParams['frozen_time'] = ObjectSerializer.serialize(frozenTime, "number");
        }

        if (name !== undefined) {
            localVarFormParams['name'] = ObjectSerializer.serialize(name, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TestHelpersTestClock;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TestHelpersTestClock");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Starts advancing a test clock to a specified time in the future. Advancement is done when status changes to <code>Ready</code>.</p>
     * @param testClock 
     * @param frozenTime The time to advance the test clock. Must be after the test clock\\\&#39;s current frozen time. Cannot be more than two intervals in the future from the shortest subscription in this test clock. If there are no subscriptions in this test clock, it cannot be more than two years in the future.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersTestClocksTestClockAdvance (testClock: string, frozenTime: number, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TestHelpersTestClock;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/test_clocks/{test_clock}/advance'
            .replace('{' + 'test_clock' + '}', encodeURIComponent(String(testClock)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'testClock' is not null or undefined
        if (testClock === null || testClock === undefined) {
            throw new Error('Required parameter testClock was null or undefined when calling postTestHelpersTestClocksTestClockAdvance.');
        }

        // verify required parameter 'frozenTime' is not null or undefined
        if (frozenTime === null || frozenTime === undefined) {
            throw new Error('Required parameter frozenTime was null or undefined when calling postTestHelpersTestClocksTestClockAdvance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (frozenTime !== undefined) {
            localVarFormParams['frozen_time'] = ObjectSerializer.serialize(frozenTime, "number");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TestHelpersTestClock;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TestHelpersTestClock");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created InboundTransfer to the <code>failed</code> status. The InboundTransfer must already be in the <code>processing</code> state.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     * @param failureDetails 
     */
    public async postTestHelpersTreasuryInboundTransfersIdFail (id: string, expand?: Array<string>, failureDetails?: FailureDetailsParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/inbound_transfers/{id}/fail'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTestHelpersTreasuryInboundTransfersIdFail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (failureDetails !== undefined) {
            localVarFormParams['failure_details'] = ObjectSerializer.serialize(failureDetails, "FailureDetailsParams");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryInboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Marks the test mode InboundTransfer object as returned and links the InboundTransfer to a ReceivedDebit. The InboundTransfer must already be in the <code>succeeded</code> state.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersTreasuryInboundTransfersIdReturn (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/inbound_transfers/{id}/return'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTestHelpersTreasuryInboundTransfersIdReturn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryInboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created InboundTransfer to the <code>succeeded</code> status. The InboundTransfer must already be in the <code>processing</code> state.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersTreasuryInboundTransfersIdSucceed (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/inbound_transfers/{id}/succeed'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTestHelpersTreasuryInboundTransfersIdSucceed.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryInboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created OutboundPayment to the <code>failed</code> status. The OutboundPayment must already be in the <code>processing</code> state.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersTreasuryOutboundPaymentsIdFail (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/outbound_payments/{id}/fail'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTestHelpersTreasuryOutboundPaymentsIdFail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created OutboundPayment to the <code>posted</code> status. The OutboundPayment must already be in the <code>processing</code> state.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersTreasuryOutboundPaymentsIdPost (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/outbound_payments/{id}/post'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTestHelpersTreasuryOutboundPaymentsIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created OutboundPayment to the <code>returned</code> status. The OutboundPayment must already be in the <code>processing</code> state.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     * @param returnedDetails 
     */
    public async postTestHelpersTreasuryOutboundPaymentsIdReturn (id: string, expand?: Array<string>, returnedDetails?: ReturnedDetailsParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/outbound_payments/{id}/return'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTestHelpersTreasuryOutboundPaymentsIdReturn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (returnedDetails !== undefined) {
            localVarFormParams['returned_details'] = ObjectSerializer.serialize(returnedDetails, "ReturnedDetailsParams");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created OutboundTransfer to the <code>failed</code> status. The OutboundTransfer must already be in the <code>processing</code> state.</p>
     * @param outboundTransfer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersTreasuryOutboundTransfersOutboundTransferFail (outboundTransfer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/fail'
            .replace('{' + 'outbound_transfer' + '}', encodeURIComponent(String(outboundTransfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'outboundTransfer' is not null or undefined
        if (outboundTransfer === null || outboundTransfer === undefined) {
            throw new Error('Required parameter outboundTransfer was null or undefined when calling postTestHelpersTreasuryOutboundTransfersOutboundTransferFail.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created OutboundTransfer to the <code>posted</code> status. The OutboundTransfer must already be in the <code>processing</code> state.</p>
     * @param outboundTransfer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTestHelpersTreasuryOutboundTransfersOutboundTransferPost (outboundTransfer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/post'
            .replace('{' + 'outbound_transfer' + '}', encodeURIComponent(String(outboundTransfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'outboundTransfer' is not null or undefined
        if (outboundTransfer === null || outboundTransfer === undefined) {
            throw new Error('Required parameter outboundTransfer was null or undefined when calling postTestHelpersTreasuryOutboundTransfersOutboundTransferPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Transitions a test mode created OutboundTransfer to the <code>returned</code> status. The OutboundTransfer must already be in the <code>processing</code> state.</p>
     * @param outboundTransfer 
     * @param expand Specifies which fields in the response should be expanded.
     * @param returnedDetails 
     */
    public async postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn (outboundTransfer: string, expand?: Array<string>, returnedDetails?: ReturnedDetailsParams1, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/outbound_transfers/{outbound_transfer}/return'
            .replace('{' + 'outbound_transfer' + '}', encodeURIComponent(String(outboundTransfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'outboundTransfer' is not null or undefined
        if (outboundTransfer === null || outboundTransfer === undefined) {
            throw new Error('Required parameter outboundTransfer was null or undefined when calling postTestHelpersTreasuryOutboundTransfersOutboundTransferReturn.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (returnedDetails !== undefined) {
            localVarFormParams['returned_details'] = ObjectSerializer.serialize(returnedDetails, "ReturnedDetailsParams1");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Use this endpoint to simulate a test mode ReceivedCredit initiated by a third party. In live mode, you can’t directly create ReceivedCredits initiated by third parties.</p>
     * @param amount Amount (in cents) to be transferred.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param financialAccount The FinancialAccount to send funds to.
     * @param network The rails used for the object.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param initiatingPaymentMethodDetails 
     */
    public async postTestHelpersTreasuryReceivedCredits (amount: number, currency: string, financialAccount: string, network: string, description?: string, expand?: Array<string>, initiatingPaymentMethodDetails?: SourceParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCredit;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/received_credits';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postTestHelpersTreasuryReceivedCredits.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTestHelpersTreasuryReceivedCredits.');
        }

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling postTestHelpersTreasuryReceivedCredits.');
        }

        // verify required parameter 'network' is not null or undefined
        if (network === null || network === undefined) {
            throw new Error('Required parameter network was null or undefined when calling postTestHelpersTreasuryReceivedCredits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarFormParams['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (initiatingPaymentMethodDetails !== undefined) {
            localVarFormParams['initiating_payment_method_details'] = ObjectSerializer.serialize(initiatingPaymentMethodDetails, "SourceParams");
        }

        if (network !== undefined) {
            localVarFormParams['network'] = ObjectSerializer.serialize(network, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedCredit;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedCredit");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Use this endpoint to simulate a test mode ReceivedDebit initiated by a third party. In live mode, you can’t directly create ReceivedDebits initiated by third parties.</p>
     * @param amount Amount (in cents) to be transferred.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param financialAccount The FinancialAccount to pull funds from.
     * @param network The rails used for the object.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param initiatingPaymentMethodDetails 
     */
    public async postTestHelpersTreasuryReceivedDebits (amount: number, currency: string, financialAccount: string, network: string, description?: string, expand?: Array<string>, initiatingPaymentMethodDetails?: SourceParams, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebit;  }> {
        const localVarPath = this.basePath + '/v1/test_helpers/treasury/received_debits';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postTestHelpersTreasuryReceivedDebits.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTestHelpersTreasuryReceivedDebits.');
        }

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling postTestHelpersTreasuryReceivedDebits.');
        }

        // verify required parameter 'network' is not null or undefined
        if (network === null || network === undefined) {
            throw new Error('Required parameter network was null or undefined when calling postTestHelpersTreasuryReceivedDebits.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarFormParams['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (initiatingPaymentMethodDetails !== undefined) {
            localVarFormParams['initiating_payment_method_details'] = ObjectSerializer.serialize(initiatingPaymentMethodDetails, "SourceParams");
        }

        if (network !== undefined) {
            localVarFormParams['network'] = ObjectSerializer.serialize(network, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryReceivedDebit;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryReceivedDebit");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a single-use token that represents a bank account’s details. This token can be used with any API method in place of a bank account dictionary. This token can be used only once, by attaching it to a <a href=\"#accounts\">Custom account</a>.</p>
     * @param account 
     * @param bankAccount 
     * @param card 
     * @param customer The customer (owned by the application\\\&#39;s account) for which to create a token. This can be used only with an [OAuth access token](https://stripe.com/docs/connect/standard-accounts) or [Stripe-Account header](https://stripe.com/docs/connect/authentication). For more details, see [Cloning Saved Payment Methods](https://stripe.com/docs/connect/cloning-saved-payment-methods).
     * @param cvcUpdate 
     * @param expand Specifies which fields in the response should be expanded.
     * @param person 
     * @param pii 
     */
    public async postTokens (account?: ConnectJsAccountTokenSpecs, bankAccount?: TokenCreateBankAccount, card?: PostTokensRequestCard, customer?: string, cvcUpdate?: CvcParams, expand?: Array<string>, person?: PersonTokenSpecs, pii?: PiiTokenSpecs, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Token;  }> {
        const localVarPath = this.basePath + '/v1/tokens';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (account !== undefined) {
            localVarFormParams['account'] = ObjectSerializer.serialize(account, "ConnectJsAccountTokenSpecs");
        }

        if (bankAccount !== undefined) {
            localVarFormParams['bank_account'] = ObjectSerializer.serialize(bankAccount, "TokenCreateBankAccount");
        }

        if (card !== undefined) {
            localVarFormParams['card'] = ObjectSerializer.serialize(card, "PostTokensRequestCard");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (cvcUpdate !== undefined) {
            localVarFormParams['cvc_update'] = ObjectSerializer.serialize(cvcUpdate, "CvcParams");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (person !== undefined) {
            localVarFormParams['person'] = ObjectSerializer.serialize(person, "PersonTokenSpecs");
        }

        if (pii !== undefined) {
            localVarFormParams['pii'] = ObjectSerializer.serialize(pii, "PiiTokenSpecs");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Token;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Token");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Top up the balance of an account</p>
     * @param amount A positive integer representing how much to transfer.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param source The ID of a source to transfer funds from. For most users, this should be left unspecified which will use the bank account that was set up in the dashboard for the specified currency. In test mode, this can be a test bank token (see [Testing Top-ups](https://stripe.com/docs/connect/testing#testing-top-ups)).
     * @param statementDescriptor Extra information about a top-up for the source\\\&#39;s bank statement. Limited to 15 ASCII characters.
     * @param transferGroup A string that identifies this top-up as part of a group.
     */
    public async postTopups (amount: number, currency: string, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, source?: string, statementDescriptor?: string, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Topup;  }> {
        const localVarPath = this.basePath + '/v1/topups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postTopups.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTopups.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (source !== undefined) {
            localVarFormParams['source'] = ObjectSerializer.serialize(source, "string");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        if (transferGroup !== undefined) {
            localVarFormParams['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Topup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Topup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the metadata of a top-up. Other top-up details are not editable by design.</p>
     * @param topup 
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postTopupsTopup (topup: string, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Topup;  }> {
        const localVarPath = this.basePath + '/v1/topups/{topup}'
            .replace('{' + 'topup' + '}', encodeURIComponent(String(topup)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'topup' is not null or undefined
        if (topup === null || topup === undefined) {
            throw new Error('Required parameter topup was null or undefined when calling postTopupsTopup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Topup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Topup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancels a top-up. Only pending top-ups can be canceled.</p>
     * @param topup 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTopupsTopupCancel (topup: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Topup;  }> {
        const localVarPath = this.basePath + '/v1/topups/{topup}/cancel'
            .replace('{' + 'topup' + '}', encodeURIComponent(String(topup)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'topup' is not null or undefined
        if (topup === null || topup === undefined) {
            throw new Error('Required parameter topup was null or undefined when calling postTopupsTopupCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Topup;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Topup");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>To send funds from your Stripe account to a connected account, you create a new transfer object. Your <a href=\"#balance\">Stripe balance</a> must be able to cover the transfer amount, or you’ll receive an “Insufficient Funds” error.</p>
     * @param currency 3-letter [ISO code for currency](https://stripe.com/docs/payouts).
     * @param destination The ID of a connected Stripe account. &lt;a href&#x3D;\\\&quot;/docs/connect/charges-transfers\\\&quot;&gt;See the Connect documentation&lt;/a&gt; for details.
     * @param amount A positive integer in cents (or local equivalent) representing how much to transfer.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param sourceTransaction You can use this parameter to transfer funds from a charge before they are added to your available balance. A pending balance will transfer immediately but the funds will not become available until the original charge becomes available. [See the Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-availability) for details.
     * @param sourceType The source balance to use for this transfer. One of &#x60;bank_account&#x60;, &#x60;card&#x60;, or &#x60;fpx&#x60;. For most users, this will default to &#x60;card&#x60;.
     * @param transferGroup A string that identifies this transaction as part of a group. See the [Connect documentation](https://stripe.com/docs/connect/charges-transfers#transfer-options) for details.
     */
    public async postTransfers (currency: string, destination: string, amount?: number, description?: string, expand?: Array<string>, sourceTransaction?: string, sourceType?: string, transferGroup?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Transfer;  }> {
        const localVarPath = this.basePath + '/v1/transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTransfers.');
        }

        // verify required parameter 'destination' is not null or undefined
        if (destination === null || destination === undefined) {
            throw new Error('Required parameter destination was null or undefined when calling postTransfers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (destination !== undefined) {
            localVarFormParams['destination'] = ObjectSerializer.serialize(destination, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (sourceTransaction !== undefined) {
            localVarFormParams['source_transaction'] = ObjectSerializer.serialize(sourceTransaction, "string");
        }

        if (sourceType !== undefined) {
            localVarFormParams['source_type'] = ObjectSerializer.serialize(sourceType, "string");
        }

        if (transferGroup !== undefined) {
            localVarFormParams['transfer_group'] = ObjectSerializer.serialize(transferGroup, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Transfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Transfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>When you create a new reversal, you must specify a transfer to create it on.</p>  <p>When reversing transfers, you can optionally reverse part of the transfer. You can do so as many times as you wish until the entire transfer has been reversed.</p>  <p>Once entirely reversed, a transfer can’t be reversed again. This method will return an error when called on an already-reversed transfer, or when trying to reverse more money than is left on a transfer.</p>
     * @param id 
     * @param amount A positive integer in cents (or local equivalent) representing how much of this transfer to reverse. Can only reverse up to the unreversed amount remaining of the transfer. Partial transfer reversals are only allowed for transfers to Stripe Accounts. Defaults to the entire transfer amount.
     * @param description An arbitrary string which you can attach to a reversal object. It is displayed alongside the reversal in the Dashboard. This will be unset if you POST an empty value.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param refundApplicationFee Boolean indicating whether the application fee should be refunded when reversing this transfer. If a full transfer reversal is given, the full application fee will be refunded. Otherwise, the application fee will be refunded with an amount proportional to the amount of the transfer reversed.
     */
    public async postTransfersIdReversals (id: string, amount?: number, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, refundApplicationFee?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TransferReversal;  }> {
        const localVarPath = this.basePath + '/v1/transfers/{id}/reversals'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTransfersIdReversals.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (refundApplicationFee !== undefined) {
            localVarFormParams['refund_application_fee'] = ObjectSerializer.serialize(refundApplicationFee, "boolean");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TransferReversal;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TransferReversal");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified transfer by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request accepts only metadata as an argument.</p>
     * @param transfer 
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postTransfersTransfer (transfer: string, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: Transfer;  }> {
        const localVarPath = this.basePath + '/v1/transfers/{transfer}'
            .replace('{' + 'transfer' + '}', encodeURIComponent(String(transfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'transfer' is not null or undefined
        if (transfer === null || transfer === undefined) {
            throw new Error('Required parameter transfer was null or undefined when calling postTransfersTransfer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: Transfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "Transfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the specified reversal by setting the values of the parameters passed. Any parameters not provided will be left unchanged.</p>  <p>This request only accepts metadata and description as arguments.</p>
     * @param id 
     * @param transfer 
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postTransfersTransferReversalsId (id: string, transfer: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TransferReversal;  }> {
        const localVarPath = this.basePath + '/v1/transfers/{transfer}/reversals/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'transfer' + '}', encodeURIComponent(String(transfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTransfersTransferReversalsId.');
        }

        // verify required parameter 'transfer' is not null or undefined
        if (transfer === null || transfer === undefined) {
            throw new Error('Required parameter transfer was null or undefined when calling postTransfersTransferReversalsId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TransferReversal;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TransferReversal");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Reverses a ReceivedCredit and creates a CreditReversal object.</p>
     * @param receivedCredit The ReceivedCredit to reverse.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTreasuryCreditReversals (receivedCredit: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryCreditReversal;  }> {
        const localVarPath = this.basePath + '/v1/treasury/credit_reversals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'receivedCredit' is not null or undefined
        if (receivedCredit === null || receivedCredit === undefined) {
            throw new Error('Required parameter receivedCredit was null or undefined when calling postTreasuryCreditReversals.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (receivedCredit !== undefined) {
            localVarFormParams['received_credit'] = ObjectSerializer.serialize(receivedCredit, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryCreditReversal;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryCreditReversal");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Reverses a ReceivedDebit and creates a DebitReversal object.</p>
     * @param receivedDebit The ReceivedDebit to reverse.
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTreasuryDebitReversals (receivedDebit: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryDebitReversal;  }> {
        const localVarPath = this.basePath + '/v1/treasury/debit_reversals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'receivedDebit' is not null or undefined
        if (receivedDebit === null || receivedDebit === undefined) {
            throw new Error('Required parameter receivedDebit was null or undefined when calling postTreasuryDebitReversals.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (receivedDebit !== undefined) {
            localVarFormParams['received_debit'] = ObjectSerializer.serialize(receivedDebit, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryDebitReversal;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryDebitReversal");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates a new FinancialAccount. For now, each connected account can only have one FinancialAccount.</p>
     * @param supportedCurrencies The currencies the FinancialAccount can hold a balance in.
     * @param expand Specifies which fields in the response should be expanded.
     * @param features 
     * @param platformRestrictions 
     */
    public async postTreasuryFinancialAccounts (supportedCurrencies: Array<string>, expand?: Array<string>, features?: FeatureAccess, platformRestrictions?: PlatformRestrictions, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccount;  }> {
        const localVarPath = this.basePath + '/v1/treasury/financial_accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'supportedCurrencies' is not null or undefined
        if (supportedCurrencies === null || supportedCurrencies === undefined) {
            throw new Error('Required parameter supportedCurrencies was null or undefined when calling postTreasuryFinancialAccounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (features !== undefined) {
            localVarFormParams['features'] = ObjectSerializer.serialize(features, "FeatureAccess");
        }

        if (platformRestrictions !== undefined) {
            localVarFormParams['platform_restrictions'] = ObjectSerializer.serialize(platformRestrictions, "PlatformRestrictions");
        }

        if (supportedCurrencies !== undefined) {
            localVarFormParams['supported_currencies'] = ObjectSerializer.serialize(supportedCurrencies, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryFinancialAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the details of a FinancialAccount.</p>
     * @param financialAccount 
     * @param expand Specifies which fields in the response should be expanded.
     * @param features 
     * @param platformRestrictions 
     */
    public async postTreasuryFinancialAccountsFinancialAccount (financialAccount: string, expand?: Array<string>, features?: FeatureAccess1, platformRestrictions?: PlatformRestrictions, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccount;  }> {
        const localVarPath = this.basePath + '/v1/treasury/financial_accounts/{financial_account}'
            .replace('{' + 'financial_account' + '}', encodeURIComponent(String(financialAccount)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling postTreasuryFinancialAccountsFinancialAccount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (features !== undefined) {
            localVarFormParams['features'] = ObjectSerializer.serialize(features, "FeatureAccess1");
        }

        if (platformRestrictions !== undefined) {
            localVarFormParams['platform_restrictions'] = ObjectSerializer.serialize(platformRestrictions, "PlatformRestrictions");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccount;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryFinancialAccount");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the Features associated with a FinancialAccount.</p>
     * @param financialAccount 
     * @param cardIssuing 
     * @param depositInsurance 
     * @param expand Specifies which fields in the response should be expanded.
     * @param financialAddresses 
     * @param inboundTransfers 
     * @param intraStripeFlows 
     * @param outboundPayments 
     * @param outboundTransfers 
     */
    public async postTreasuryFinancialAccountsFinancialAccountFeatures (financialAccount: string, cardIssuing?: Access, depositInsurance?: Access1, expand?: Array<string>, financialAddresses?: FinancialAddresses, inboundTransfers?: InboundTransfers1, intraStripeFlows?: Access3, outboundPayments?: OutboundPayments, outboundTransfers?: OutboundTransfers, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccountFeatures;  }> {
        const localVarPath = this.basePath + '/v1/treasury/financial_accounts/{financial_account}/features'
            .replace('{' + 'financial_account' + '}', encodeURIComponent(String(financialAccount)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling postTreasuryFinancialAccountsFinancialAccountFeatures.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (cardIssuing !== undefined) {
            localVarFormParams['card_issuing'] = ObjectSerializer.serialize(cardIssuing, "Access");
        }

        if (depositInsurance !== undefined) {
            localVarFormParams['deposit_insurance'] = ObjectSerializer.serialize(depositInsurance, "Access1");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAddresses !== undefined) {
            localVarFormParams['financial_addresses'] = ObjectSerializer.serialize(financialAddresses, "FinancialAddresses");
        }

        if (inboundTransfers !== undefined) {
            localVarFormParams['inbound_transfers'] = ObjectSerializer.serialize(inboundTransfers, "InboundTransfers1");
        }

        if (intraStripeFlows !== undefined) {
            localVarFormParams['intra_stripe_flows'] = ObjectSerializer.serialize(intraStripeFlows, "Access3");
        }

        if (outboundPayments !== undefined) {
            localVarFormParams['outbound_payments'] = ObjectSerializer.serialize(outboundPayments, "OutboundPayments");
        }

        if (outboundTransfers !== undefined) {
            localVarFormParams['outbound_transfers'] = ObjectSerializer.serialize(outboundTransfers, "OutboundTransfers");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryFinancialAccountFeatures;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryFinancialAccountFeatures");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an InboundTransfer.</p>
     * @param amount Amount (in cents) to be transferred.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param financialAccount The FinancialAccount to send funds to.
     * @param originPaymentMethod The origin payment method to be debited for the InboundTransfer.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param expand Specifies which fields in the response should be expanded.
     * @param statementDescriptor The complete description that appears on your customers\\\&#39; statements. Maximum 10 characters.
     */
    public async postTreasuryInboundTransfers (amount: number, currency: string, financialAccount: string, originPaymentMethod: string, description?: string, expand?: Array<string>, statementDescriptor?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/treasury/inbound_transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postTreasuryInboundTransfers.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTreasuryInboundTransfers.');
        }

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling postTreasuryInboundTransfers.');
        }

        // verify required parameter 'originPaymentMethod' is not null or undefined
        if (originPaymentMethod === null || originPaymentMethod === undefined) {
            throw new Error('Required parameter originPaymentMethod was null or undefined when calling postTreasuryInboundTransfers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarFormParams['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (originPaymentMethod !== undefined) {
            localVarFormParams['origin_payment_method'] = ObjectSerializer.serialize(originPaymentMethod, "string");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryInboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancels an InboundTransfer.</p>
     * @param inboundTransfer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTreasuryInboundTransfersInboundTransferCancel (inboundTransfer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/treasury/inbound_transfers/{inbound_transfer}/cancel'
            .replace('{' + 'inbound_transfer' + '}', encodeURIComponent(String(inboundTransfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'inboundTransfer' is not null or undefined
        if (inboundTransfer === null || inboundTransfer === undefined) {
            throw new Error('Required parameter inboundTransfer was null or undefined when calling postTreasuryInboundTransfersInboundTransferCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryInboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryInboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an OutboundPayment.</p>
     * @param amount Amount (in cents) to be transferred.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param financialAccount The FinancialAccount to pull funds from.
     * @param customer ID of the customer to whom the OutboundPayment is sent. Must match the Customer attached to the &#x60;destination_payment_method&#x60; passed in.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param destinationPaymentMethod The PaymentMethod to use as the payment instrument for the OutboundPayment. Exclusive with &#x60;destination_payment_method_data&#x60;.
     * @param destinationPaymentMethodData 
     * @param destinationPaymentMethodOptions 
     * @param endUserDetails 
     * @param expand Specifies which fields in the response should be expanded.
     * @param statementDescriptor The description that appears on the receiving end for this OutboundPayment (for example, bank statement for external bank transfer). Maximum 10 characters for &#x60;ach&#x60; payments, 140 characters for &#x60;wire&#x60; payments, or 500 characters for &#x60;stripe&#x60; network transfers. The default value is &#x60;payment&#x60;.
     */
    public async postTreasuryOutboundPayments (amount: number, currency: string, financialAccount: string, customer?: string, description?: string, destinationPaymentMethod?: string, destinationPaymentMethodData?: PaymentMethodData, destinationPaymentMethodOptions?: PaymentMethodOptions2, endUserDetails?: EndUserDetailsParams, expand?: Array<string>, statementDescriptor?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postTreasuryOutboundPayments.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTreasuryOutboundPayments.');
        }

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling postTreasuryOutboundPayments.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (customer !== undefined) {
            localVarFormParams['customer'] = ObjectSerializer.serialize(customer, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (destinationPaymentMethod !== undefined) {
            localVarFormParams['destination_payment_method'] = ObjectSerializer.serialize(destinationPaymentMethod, "string");
        }

        if (destinationPaymentMethodData !== undefined) {
            localVarFormParams['destination_payment_method_data'] = ObjectSerializer.serialize(destinationPaymentMethodData, "PaymentMethodData");
        }

        if (destinationPaymentMethodOptions !== undefined) {
            localVarFormParams['destination_payment_method_options'] = ObjectSerializer.serialize(destinationPaymentMethodOptions, "PaymentMethodOptions2");
        }

        if (endUserDetails !== undefined) {
            localVarFormParams['end_user_details'] = ObjectSerializer.serialize(endUserDetails, "EndUserDetailsParams");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarFormParams['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Cancel an OutboundPayment.</p>
     * @param id 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTreasuryOutboundPaymentsIdCancel (id: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_payments/{id}/cancel'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling postTreasuryOutboundPaymentsIdCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundPayment;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundPayment");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Creates an OutboundTransfer.</p>
     * @param amount Amount (in cents) to be transferred.
     * @param currency Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).
     * @param financialAccount The FinancialAccount to pull funds from.
     * @param description An arbitrary string attached to the object. Often useful for displaying to users.
     * @param destinationPaymentMethod The PaymentMethod to use as the payment instrument for the OutboundTransfer.
     * @param destinationPaymentMethodOptions 
     * @param expand Specifies which fields in the response should be expanded.
     * @param statementDescriptor Statement descriptor to be shown on the receiving end of an OutboundTransfer. Maximum 10 characters for &#x60;ach&#x60; transfers or 140 characters for &#x60;wire&#x60; transfers. The default value is &#x60;transfer&#x60;.
     */
    public async postTreasuryOutboundTransfers (amount: number, currency: string, financialAccount: string, description?: string, destinationPaymentMethod?: string, destinationPaymentMethodOptions?: PaymentMethodOptions3, expand?: Array<string>, statementDescriptor?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_transfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'amount' is not null or undefined
        if (amount === null || amount === undefined) {
            throw new Error('Required parameter amount was null or undefined when calling postTreasuryOutboundTransfers.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling postTreasuryOutboundTransfers.');
        }

        // verify required parameter 'financialAccount' is not null or undefined
        if (financialAccount === null || financialAccount === undefined) {
            throw new Error('Required parameter financialAccount was null or undefined when calling postTreasuryOutboundTransfers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (amount !== undefined) {
            localVarFormParams['amount'] = ObjectSerializer.serialize(amount, "number");
        }

        if (currency !== undefined) {
            localVarFormParams['currency'] = ObjectSerializer.serialize(currency, "string");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (destinationPaymentMethod !== undefined) {
            localVarFormParams['destination_payment_method'] = ObjectSerializer.serialize(destinationPaymentMethod, "string");
        }

        if (destinationPaymentMethodOptions !== undefined) {
            localVarFormParams['destination_payment_method_options'] = ObjectSerializer.serialize(destinationPaymentMethodOptions, "PaymentMethodOptions3");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (financialAccount !== undefined) {
            localVarFormParams['financial_account'] = ObjectSerializer.serialize(financialAccount, "string");
        }

        if (statementDescriptor !== undefined) {
            localVarFormParams['statement_descriptor'] = ObjectSerializer.serialize(statementDescriptor, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>An OutboundTransfer can be canceled if the funds have not yet been paid out.</p>
     * @param outboundTransfer 
     * @param expand Specifies which fields in the response should be expanded.
     */
    public async postTreasuryOutboundTransfersOutboundTransferCancel (outboundTransfer: string, expand?: Array<string>, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }> {
        const localVarPath = this.basePath + '/v1/treasury/outbound_transfers/{outbound_transfer}/cancel'
            .replace('{' + 'outbound_transfer' + '}', encodeURIComponent(String(outboundTransfer)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'outboundTransfer' is not null or undefined
        if (outboundTransfer === null || outboundTransfer === undefined) {
            throw new Error('Required parameter outboundTransfer was null or undefined when calling postTreasuryOutboundTransfersOutboundTransferCancel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: TreasuryOutboundTransfer;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "TreasuryOutboundTransfer");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>A webhook endpoint must have a <code>url</code> and a list of <code>enabled_events</code>. You may optionally specify the Boolean <code>connect</code> parameter. If set to true, then a Connect webhook endpoint that notifies the specified <code>url</code> about events from all connected accounts is created; otherwise an account webhook endpoint that notifies the specified <code>url</code> only about events from your account is created. You can also create webhook endpoints in the <a href=\"https://dashboard.stripe.com/account/webhooks\">webhooks settings</a> section of the Dashboard.</p>
     * @param enabledEvents The list of events to enable for this endpoint. You may specify &#x60;[\\\&#39;*\\\&#39;]&#x60; to enable all events, except those that require explicit selection.
     * @param url The URL of the webhook endpoint.
     * @param apiVersion Events sent to this endpoint will be generated with this Stripe Version instead of your account\\\&#39;s default Stripe Version.
     * @param connect Whether this endpoint should receive events from connected accounts (&#x60;true&#x60;), or from your account (&#x60;false&#x60;). Defaults to &#x60;false&#x60;.
     * @param description An optional description of what the webhook is used for.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     */
    public async postWebhookEndpoints (enabledEvents: Array<string>, url: string, apiVersion?: string, connect?: boolean, description?: string, expand?: Array<string>, metadata?: IndividualSpecsMetadata, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WebhookEndpoint;  }> {
        const localVarPath = this.basePath + '/v1/webhook_endpoints';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'enabledEvents' is not null or undefined
        if (enabledEvents === null || enabledEvents === undefined) {
            throw new Error('Required parameter enabledEvents was null or undefined when calling postWebhookEndpoints.');
        }

        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling postWebhookEndpoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (apiVersion !== undefined) {
            localVarFormParams['api_version'] = ObjectSerializer.serialize(apiVersion, "string");
        }

        if (connect !== undefined) {
            localVarFormParams['connect'] = ObjectSerializer.serialize(connect, "boolean");
        }

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (enabledEvents !== undefined) {
            localVarFormParams['enabled_events'] = ObjectSerializer.serialize(enabledEvents, "Array<string>");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: WebhookEndpoint;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "WebhookEndpoint");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * <p>Updates the webhook endpoint. You may edit the <code>url</code>, the list of <code>enabled_events</code>, and the status of your endpoint.</p>
     * @param webhookEndpoint 
     * @param description An optional description of what the webhook is used for.
     * @param disabled Disable the webhook endpoint if set to true.
     * @param enabledEvents The list of events to enable for this endpoint. You may specify &#x60;[\\\&#39;*\\\&#39;]&#x60; to enable all events, except those that require explicit selection.
     * @param expand Specifies which fields in the response should be expanded.
     * @param metadata 
     * @param url The URL of the webhook endpoint.
     */
    public async postWebhookEndpointsWebhookEndpoint (webhookEndpoint: string, description?: string, disabled?: boolean, enabledEvents?: Array<string>, expand?: Array<string>, metadata?: IndividualSpecsMetadata, url?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: WebhookEndpoint;  }> {
        const localVarPath = this.basePath + '/v1/webhook_endpoints/{webhook_endpoint}'
            .replace('{' + 'webhook_endpoint' + '}', encodeURIComponent(String(webhookEndpoint)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'webhookEndpoint' is not null or undefined
        if (webhookEndpoint === null || webhookEndpoint === undefined) {
            throw new Error('Required parameter webhookEndpoint was null or undefined when calling postWebhookEndpointsWebhookEndpoint.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (description !== undefined) {
            localVarFormParams['description'] = ObjectSerializer.serialize(description, "string");
        }

        if (disabled !== undefined) {
            localVarFormParams['disabled'] = ObjectSerializer.serialize(disabled, "boolean");
        }

        if (enabledEvents !== undefined) {
            localVarFormParams['enabled_events'] = ObjectSerializer.serialize(enabledEvents, "Array<string>");
        }

        if (expand !== undefined) {
            localVarFormParams['expand'] = ObjectSerializer.serialize(expand, "Array<string>");
        }

        if (metadata !== undefined) {
            localVarFormParams['metadata'] = ObjectSerializer.serialize(metadata, "IndividualSpecsMetadata");
        }

        if (url !== undefined) {
            localVarFormParams['url'] = ObjectSerializer.serialize(url, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        if (this.authentications.basicAuth.username && this.authentications.basicAuth.password) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.basicAuth.applyToRequest(localVarRequestOptions));
        }
        if (this.authentications.bearerAuth.accessToken) {
            authenticationPromise = authenticationPromise.then(() => this.authentications.bearerAuth.applyToRequest(localVarRequestOptions));
        }
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: WebhookEndpoint;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "WebhookEndpoint");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
